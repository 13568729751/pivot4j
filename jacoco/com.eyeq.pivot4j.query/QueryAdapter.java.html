<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QueryAdapter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Pivot4J</a> &gt; <a href="index.html" class="el_package">com.eyeq.pivot4j.query</a> &gt; <span class="el_source">QueryAdapter.java</span></div><h1>QueryAdapter.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/*</span>
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 */
package com.eyeq.pivot4j.query;

import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import java_cup.runtime.Symbol;

import org.olap4j.CellSet;
import org.olap4j.CellSetAxis;
import org.olap4j.OlapException;
import org.olap4j.Position;
import org.olap4j.mdx.parser.MdxParser;
import org.olap4j.metadata.Dimension;
import org.olap4j.metadata.Hierarchy;
import org.olap4j.metadata.Member;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.eyeq.pivot4j.PivotException;
import com.eyeq.pivot4j.PivotModel;
import com.eyeq.pivot4j.StateHolder;
import com.eyeq.pivot4j.mdx.Exp;
import com.eyeq.pivot4j.mdx.FunCall;
import com.eyeq.pivot4j.mdx.Lexer;
import com.eyeq.pivot4j.mdx.Literal;
import com.eyeq.pivot4j.mdx.ParsedQuery;
import com.eyeq.pivot4j.mdx.Parser;
import com.eyeq.pivot4j.mdx.QueryAxis;
import com.eyeq.pivot4j.mdx.Syntax;

/**
 * Adapt the MDX query to the model
 */
<span class="fc" id="L47">public class QueryAdapter implements StateHolder {</span>

<span class="fc" id="L49">	protected static Logger logger = LoggerFactory</span>
<span class="fc" id="L50">			.getLogger(QueryAdapter.class);</span>

	private PivotModel model;

	private List&lt;Quax&gt; quaxes; // Array of query axis state object

<span class="fc" id="L56">	private boolean useQuax = false;</span>

<span class="fc" id="L58">	private boolean axesSwapped = false;</span>

	private Quax quaxToSort; // this is the Quax to be sorted

	private ParsedQuery parsedQuery;

	private ParsedQuery cloneQuery;

<span class="fc" id="L66">	private Collection&lt;QueryChangeListener&gt; listeners = new ArrayList&lt;QueryChangeListener&gt;();</span>

<span class="fc" id="L68">	private QuaxChangeListener quaxListener = new QuaxChangeListener() {</span>

		public void quaxChanged(QuaxChangeEvent e) {
<span class="fc" id="L71">			onQuaxChanged(e.getQuax(), e.isChangedByNavigator());</span>
<span class="fc" id="L72">		}</span>
	};

	/**
	 * @param model
	 * @param parser
	 */
<span class="fc" id="L79">	public QueryAdapter(PivotModel model, MdxParser parser) {</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">		if (model == null) {</span>
<span class="nc" id="L81">			throw new IllegalArgumentException(</span>
<span class="nc" id="L82">					&quot;Missing required argument 'model'.&quot;);</span>
		}

<span class="pc bpc" id="L85" title="1 of 2 branches missed.">		if (parser == null) {</span>
<span class="nc" id="L86">			throw new IllegalArgumentException(</span>
<span class="nc" id="L87">					&quot;Missing required argument 'parser'.&quot;);</span>
		}

<span class="fc" id="L90">		this.model = model;</span>
<span class="fc" id="L91">		this.parsedQuery = parseQuery(model.getMdx());</span>

<span class="fc" id="L93">		QueryAxis[] queryAxes = parsedQuery.getAxes();</span>

<span class="fc" id="L95">		this.quaxes = new ArrayList&lt;Quax&gt;(queryAxes.length);</span>

<span class="fc" id="L97">		int ordinal = 0;</span>
		for (@SuppressWarnings(&quot;unused&quot;)
<span class="fc bfc" id="L99" title="All 2 branches covered.">		QueryAxis queryAxis : queryAxes) {</span>
<span class="fc" id="L100">			Quax quax = new Quax(ordinal++, parser);</span>
<span class="fc" id="L101">			quax.addChangeListener(quaxListener);</span>

<span class="fc" id="L103">			quaxes.add(quax);</span>
		}
<span class="fc" id="L105">	}</span>

	/**
	 * @return the model
	 */
	public PivotModel getModel() {
<span class="nc" id="L111">		return model;</span>
	}

	/**
	 * register change listener
	 * 
	 * @param listener
	 */
	public void addChangeListener(QueryChangeListener listener) {
<span class="fc" id="L120">		listeners.add(listener);</span>
<span class="fc" id="L121">	}</span>

	/**
	 * unregister change listener
	 * 
	 * @param listener
	 */
	public void removeChangeListener(QueryChangeListener listener) {
<span class="fc" id="L129">		listeners.remove(listener);</span>
<span class="fc" id="L130">	}</span>

	protected void fireQueryChanged() {
<span class="fc" id="L133">		this.useQuax = true;</span>

<span class="fc" id="L135">		updateQuery();</span>

<span class="fc" id="L137">		QueryChangeEvent e = new QueryChangeEvent(this);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">		for (QueryChangeListener listener : listeners) {</span>
<span class="fc" id="L139">			listener.queryChanged(e);</span>
		}
<span class="fc" id="L141">	}</span>

	/**
	 * @return the XMLA Query object
	 */
	public ParsedQuery getParsedQuery() {
<span class="fc" id="L147">		return parsedQuery;</span>
	}

	/**
	 * @return
	 */
	public List&lt;Quax&gt; getQuaxes() {
<span class="nc" id="L154">		return Collections.unmodifiableList(quaxes);</span>
	}

	/**
	 * @return true if quas is to be used
	 */
	public boolean getUseQuax() {
<span class="nc" id="L161">		return useQuax;</span>
	}

	/**
	 * @return true, if axes are currently swapped
	 */
	public boolean isAxesSwapped() {
<span class="nc" id="L168">		return axesSwapped;</span>
	}

	/**
	 * @param axesSwapped
	 */
	public void setAxesSwapped(boolean axesSwapped) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">		if (parsedQuery.getAxes().length &gt;= 2) {</span>
<span class="nc" id="L176">			this.axesSwapped = axesSwapped;</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">			if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L179">				logger.info(&quot;swapAxes &quot; + axesSwapped);</span>
			}

<span class="nc" id="L182">			fireQueryChanged();</span>
		}
<span class="nc" id="L184">	}</span>

	/**
	 * @return the quaxToSort
	 */
	public Quax getQuaxToSort() {
<span class="nc" id="L190">		return quaxToSort;</span>
	}

	/**
	 * @param quaxToSort
	 *            the quaxToSort to set
	 */
	public void setQuaxToSort(Quax quaxToSort) {
<span class="nc" id="L198">		this.quaxToSort = quaxToSort;</span>
<span class="nc" id="L199">	}</span>

	protected boolean isSortOnQuery() {
<span class="pc bpc" id="L202" title="3 of 4 branches missed.">		return model.isSorting() &amp;&amp; model.getSortPosMembers() != null</span>
<span class="pc bnc" id="L203" title="All 2 branches missed.">				&amp;&amp; !model.getSortPosMembers().isEmpty();</span>
	}

	/**
	 * @return ordinal of quax to sort, if sorting is active
	 */
	protected int activeQuaxToSort() {
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">		if (isSortOnQuery()) {</span>
<span class="nc" id="L211">			return quaxToSort.getOrdinal();</span>
		} else {
<span class="fc" id="L213">			return -1;</span>
		}
	}

	/**
	 * find the Quax for a specific dimension
	 * 
	 * @param dim
	 *            Dimension
	 * @return Quax containg dimension
	 */
	public Quax findQuax(Dimension dim) {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">		for (Quax quax : quaxes) {</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">			if (quax.dimIdx(dim) &gt;= 0) {</span>
<span class="fc" id="L227">				return quax;</span>
			}
		}
<span class="nc" id="L230">		return null;</span>
	}

	/**
	 * Update the Query Object before Execute. The current query is build from -
	 * the original query - adding the drilldown groups - apply pending swap
	 * axes - apply pending sorts.
	 */
	public ParsedQuery updateQuery() {
		// if quax is to be used, generate axes from quax
<span class="fc bfc" id="L240" title="All 2 branches covered.">		if (useQuax) {</span>
<span class="fc" id="L241">			int iQuaxToSort = activeQuaxToSort();</span>

<span class="fc" id="L243">			QueryAxis[] qAxes = parsedQuery.getAxes();</span>

<span class="fc" id="L245">			int i = 0;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">			for (Quax quax : quaxes) {</span>
<span class="fc" id="L247">				boolean doHierarchize = false;</span>
<span class="pc bpc" id="L248" title="1 of 4 branches missed.">				if (quax.isHierarchizeNeeded() &amp;&amp; i != iQuaxToSort) {</span>
<span class="fc" id="L249">					doHierarchize = true;</span>

<span class="pc bpc" id="L251" title="1 of 2 branches missed.">					if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L252">						logger.debug(&quot;MDX Generation added Hierarchize()&quot;);</span>
					}
				}

<span class="fc" id="L256">				Exp eSet = (Exp) quax.genExp(doHierarchize);</span>
<span class="fc" id="L257">				qAxes[i].setExp(eSet);</span>

<span class="fc" id="L259">				i++;</span>
			}
		}

		// generate order function if neccessary
<span class="fc bfc" id="L264" title="All 2 branches covered.">		if (!useQuax) {</span>
			// if Quax is used, the axis exp's are re-generated every time.
			// if not -
			// adding a sort to the query must not be permanent.
			// Therefore, we clone the orig state of the query object and
			// use
			// the clone furthermore in order to avoid duplicate &quot;Order&quot;
			// functions.
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">			if (cloneQuery == null) {</span>
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">				if (isSortOnQuery()) {</span>
<span class="nc" id="L274">					this.cloneQuery = (ParsedQuery) parsedQuery.clone();</span>
				}
			} else {
				// reset to original state
<span class="nc bnc" id="L278" title="All 2 branches missed.">				if (isSortOnQuery()) {</span>
<span class="nc" id="L279">					this.parsedQuery = (ParsedQuery) cloneQuery.clone();</span>
				} else {
<span class="nc" id="L281">					this.parsedQuery = cloneQuery;</span>
				}
			}

<span class="fc" id="L285">			addSortToQuery();</span>
		}

		// swap axes function if neccessary
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">		if (axesSwapped) {</span>
<span class="nc" id="L290">			swapAxes();</span>
		}

<span class="fc" id="L293">		return parsedQuery;</span>
	}

	/**
	 * Apply sort to query
	 */
	public void addSortToQuery() {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">		if (isSortOnQuery()) {</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">			switch (model.getSortMode()) {</span>
			case ASC:
			case DESC:
			case BASC:
			case BDESC:
				// call sort
<span class="nc" id="L307">				orderAxis(parsedQuery);</span>
<span class="nc" id="L308">				break;</span>
			case TOPCOUNT:
<span class="nc" id="L310">				topBottomAxis(parsedQuery, &quot;TopCount&quot;);</span>
<span class="nc" id="L311">				break;</span>
			case BOTTOMCOUNT:
<span class="nc" id="L313">				topBottomAxis(parsedQuery, &quot;BottomCount&quot;);</span>
<span class="nc" id="L314">				break;</span>
			default:
<span class="nc" id="L316">				return; // do nothing</span>
			}
		}
<span class="fc" id="L319">	}</span>

	/**
	 * Add Order Funcall to QueryAxis
	 * 
	 * @param monAx
	 * @param monSortMode
	 */
	protected void orderAxis(ParsedQuery pq) {
		// Order(TopCount) is allowed, Order(Order) is not permitted
<span class="nc" id="L329">		QueryAxis[] queryAxes = pq.getAxes();</span>
<span class="nc" id="L330">		QueryAxis qa = queryAxes[quaxToSort.getOrdinal()];</span>

<span class="nc" id="L332">		Exp setForAx = qa.getExp();</span>

		// setForAx is the top level Exp of the axis
		// put an Order FunCall around
<span class="nc" id="L336">		Exp[] args = new Exp[3];</span>
<span class="nc" id="L337">		args[0] = setForAx; // the set to be sorted is the set representing the</span>
							// query axis
		// if we got more than 1 position member, generate a tuple for the 2.arg
		Exp sortExp;

<span class="nc" id="L342">		List&lt;Member&gt; sortPosMembers = model.getSortPosMembers();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">		if (sortPosMembers == null) {</span>
<span class="nc" id="L344">			return;</span>
		}

<span class="nc bnc" id="L347" title="All 2 branches missed.">		if (sortPosMembers.size() &gt; 1) {</span>
<span class="nc" id="L348">			Exp[] memberExp = new Exp[sortPosMembers.size()];</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">			for (int i = 0; i &lt; memberExp.length; i++) {</span>
<span class="nc" id="L350">				memberExp[i] = QuaxUtil.expForMember(sortPosMembers.get(i));</span>
			}

<span class="nc" id="L353">			sortExp = new FunCall(&quot;()&quot;, memberExp, Syntax.Parentheses);</span>
		} else {
<span class="nc" id="L355">			sortExp = QuaxUtil.expForMember(sortPosMembers.get(0));</span>
		}

<span class="nc" id="L358">		args[1] = sortExp;</span>
<span class="nc" id="L359">		args[2] = Literal.createString(model.getSortMode().name());</span>

<span class="nc" id="L361">		FunCall order = new FunCall(&quot;Order&quot;, args, Syntax.Function);</span>
<span class="nc" id="L362">		qa.setExp(order);</span>
<span class="nc" id="L363">	}</span>

	/**
	 * Add Top/BottomCount Funcall to QueryAxis
	 * 
	 * @param monAx
	 * @param nShow
	 */
	protected void topBottomAxis(ParsedQuery pq, String function) {
		// TopCount(TopCount) and TopCount(Order) is not permitted
<span class="nc" id="L373">		QueryAxis[] queryAxes = pq.getAxes();</span>
<span class="nc" id="L374">		QueryAxis qa = queryAxes[quaxToSort.getOrdinal()];</span>
<span class="nc" id="L375">		Exp setForAx = qa.getExp();</span>
		Exp sortExp;

<span class="nc" id="L378">		List&lt;Member&gt; sortPosMembers = model.getSortPosMembers();</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">		if (sortPosMembers == null) {</span>
<span class="nc" id="L380">			return;</span>
		}

		// if we got more than 1 position member, generate a tuple
<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (sortPosMembers.size() &gt; 1) {</span>
<span class="nc" id="L385">			Exp[] memberExp = new Exp[sortPosMembers.size()];</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">			for (int i = 0; i &lt; memberExp.length; i++) {</span>
<span class="nc" id="L387">				memberExp[i] = QuaxUtil.expForMember(sortPosMembers.get(i));</span>
			}
<span class="nc" id="L389">			sortExp = new FunCall(&quot;()&quot;, memberExp, Syntax.Parentheses);</span>
		} else {
<span class="nc" id="L391">			sortExp = QuaxUtil.expForMember(sortPosMembers.get(0));</span>
		}

<span class="nc" id="L394">		Exp[] args = new Exp[3];</span>
<span class="nc" id="L395">		args[0] = setForAx; // the set representing the query axis</span>
<span class="nc" id="L396">		args[1] = Literal.create(model.getTopBottomCount());</span>
<span class="nc" id="L397">		args[2] = sortExp;</span>

<span class="nc" id="L399">		FunCall topbottom = new FunCall(function, args, Syntax.Function);</span>
<span class="nc" id="L400">		qa.setExp(topbottom);</span>
<span class="nc" id="L401">	}</span>

	/**
	 * Swap axes in parsed query
	 */
	protected void swapAxes() {
<span class="nc" id="L407">		QueryAxis[] queryAxes = parsedQuery.getAxes();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">		if (queryAxes.length &gt;= 2) {</span>
<span class="nc" id="L409">			Exp exp = queryAxes[0].getExp();</span>
<span class="nc" id="L410">			queryAxes[0].setExp(queryAxes[1].getExp());</span>
<span class="nc" id="L411">			queryAxes[1].setExp(exp);</span>
		}
<span class="nc" id="L413">	}</span>

	/**
	 * @param mdxQuery
	 */
	protected ParsedQuery parseQuery(String mdxQuery) {
<span class="fc" id="L419">		Reader reader = new StringReader(mdxQuery);</span>
<span class="fc" id="L420">		Parser parser = new Parser(new Lexer(reader));</span>

		ParsedQuery parsedQuery;

		try {
<span class="fc" id="L425">			Symbol parseTree = parser.parse();</span>
<span class="fc" id="L426">			parsedQuery = (ParsedQuery) parseTree.value;</span>
<span class="nc" id="L427">		} catch (RuntimeException e) {</span>
<span class="nc" id="L428">			throw e;</span>
<span class="nc" id="L429">		} catch (Exception e) {</span>
<span class="nc" id="L430">			throw new PivotException(e);</span>
		}

<span class="fc" id="L433">		parsedQuery.afterParse();</span>

<span class="fc" id="L435">		return parsedQuery;</span>
	}

	/**
	 * After the startup query was run: get the current positions as array of
	 * array of member. Called from Model.getResult after the query was
	 * executed.
	 * 
	 * @param result
	 *            the result which redefines the query axes
	 */
	public void afterExecute(CellSet cellSet) {
<span class="fc" id="L447">		List&lt;CellSetAxis&gt; axes = cellSet.getAxes();</span>

		// initialization: get the result positions and set it to quax
		// if the quaxes are not yet used to generate the query
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">		if (!useQuax) {</span>
<span class="fc" id="L452">			int i = 0;</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">			for (CellSetAxis axis : axes) {</span>
<span class="fc" id="L454">				List&lt;Position&gt; positions = axis.getPositions();</span>

<span class="pc bpc" id="L456" title="1 of 2 branches missed.">				int index = axesSwapped ? (i + 1) % 2 : i;</span>
<span class="fc" id="L457">				quaxes.get(index).initialize(positions);</span>

<span class="fc" id="L459">				i++;</span>
			}
		} else {
			// hierarchize result if neccessary
<span class="nc" id="L463">			int i = 0;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">			for (Quax quax : quaxes) {</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">				int index = axesSwapped ? (i + 1) % 2 : i;</span>
<span class="nc" id="L466">				List&lt;Position&gt; positions = axes.get(index).getPositions();</span>

				// after a result for CalcSet.GENERATE was gotten
				// we have to re-initialize the quax,
				// so that we can navigate.
<span class="nc bnc" id="L471" title="All 2 branches missed.">				if (quax.getGenerateMode() == CalcSetMode.Generate) {</span>
<span class="nc" id="L472">					quax.resetGenerate();</span>
<span class="nc" id="L473">					quax.initialize(positions);</span>
				} else {
					// unknown function members are collected
					// - always for a &quot;Sticky generate&quot; unknown function
					// - on first result for any other unknown function
<span class="nc" id="L478">					int nDimension = quax.getNDimension();</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">					for (int j = 0; j &lt; nDimension; j++) {</span>
						// collect members for unknown functions on quax
<span class="nc bnc" id="L481" title="All 2 branches missed.">						if (quax.isUnknownFunction(j)) {</span>
<span class="nc" id="L482">							List&lt;Member&gt; members = memListForHier(j, positions);</span>
<span class="nc" id="L483">							quax.setHierMemberList(j, members);</span>
						}
					}
				}
<span class="nc" id="L487">				i++;</span>
			}
		}

<span class="pc bpc" id="L491" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
			// print the result positions to logger
<span class="fc bfc" id="L493" title="All 2 branches covered.">			for (CellSetAxis axis : axes) {</span>
<span class="fc" id="L494">				List&lt;Position&gt; positions = axis.getPositions();</span>
<span class="fc" id="L495">				logger.debug(&quot;Positions of axis &quot;</span>
<span class="fc" id="L496">						+ axis.getAxisOrdinal().axisOrdinal());</span>

<span class="pc bpc" id="L498" title="1 of 2 branches missed.">				if (positions.size() == 0) {</span>
					// the axis does not have any positions
<span class="nc" id="L500">					logger.debug(&quot;0 positions&quot;);</span>
				} else {
<span class="fc" id="L502">					int nDimension = positions.get(0).getMembers().size();</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">					for (Position position : positions) {</span>
<span class="fc" id="L504">						List&lt;Member&gt; members = position.getMembers();</span>

<span class="fc" id="L506">						StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">						for (int j = 0; j &lt; nDimension; j++) {</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">							if (j &gt; 0) {</span>
<span class="fc" id="L509">								sb.append(&quot; * &quot;);</span>
							}

<span class="fc" id="L512">							List&lt;Member&gt; memsj = new ArrayList&lt;Member&gt;(j + 1);</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">							for (int k = 0; k &lt;= j; k++) {</span>
<span class="fc" id="L514">								memsj.add(members.get(k));</span>
							}

<span class="fc bfc" id="L517" title="All 2 branches covered.">							if (this.canExpand(memsj)) {</span>
<span class="fc" id="L518">								sb.append(&quot;(+)&quot;);</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">							} else if (this.canCollapse(memsj)) {</span>
<span class="nc" id="L520">								sb.append(&quot;(-)&quot;);</span>
							} else {
<span class="fc" id="L522">								sb.append(&quot;   &quot;);</span>
							}

<span class="fc" id="L525">							sb.append(members.get(j).getUniqueName());</span>
						}
<span class="fc" id="L527">						logger.debug(sb.toString());</span>
					}
				}
			}
		}
<span class="fc" id="L532">	}</span>

	/**
	 * Extract members of hier from Result
	 * 
	 * @param hierIndex
	 * @return members of hier
	 */
	protected List&lt;Member&gt; memListForHier(int hierIndex,
			List&lt;Position&gt; positions) {
<span class="nc" id="L542">		List&lt;Member&gt; members = new ArrayList&lt;Member&gt;();</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">		for (Position position : positions) {</span>
<span class="nc" id="L544">			Member member = position.getMembers().get(hierIndex);</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">			if (!members.contains(member)) {</span>
<span class="nc" id="L546">				members.add(member);</span>
			}
		}

<span class="nc" id="L550">		return members;</span>
	}

	/**
	 * Create set expression for list of members
	 * 
	 * @param members
	 * @return set expression
	 */
	protected Object createMemberSet(List&lt;Member&gt; members) {
<span class="nc" id="L560">		Exp[] exps = new Exp[members.size()];</span>

<span class="nc" id="L562">		int i = 0;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">		for (Member member : members) {</span>
<span class="nc" id="L564">			exps[i++] = QuaxUtil.expForMember(member);</span>
		}

<span class="nc" id="L567">		return new FunCall(&quot;{}&quot;, exps, Syntax.Braces);</span>
	}

	/**
	 * Find out, whether a member can be expanded. this is true, if - the member
	 * is on an axis and - the member is not yet expanded and - the member has
	 * children
	 * 
	 * @param member
	 *            Member to be expanded
	 * @return true if the member can be expanded
	 */
	public boolean canExpand(Member member) {
		// a calculated member cannot be expanded
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">		if (member.isCalculated()) {</span>
<span class="nc" id="L582">			return false;</span>
		}

		try {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">			if (member.getChildMemberCount() &lt;= 0) {</span>
<span class="nc" id="L587">				return false;</span>
			}
<span class="nc" id="L589">		} catch (OlapException e) {</span>
<span class="nc" id="L590">			throw new PivotException(e);</span>
		}

<span class="fc" id="L593">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L594">		Quax quax = findQuax(dim);</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canExpand(member);</span>
	}

	/**
	 * @param pathMembers
	 *            Members to be expanded
	 * @return true if the member can be expanded
	 */
	public boolean canExpand(List&lt;Member&gt; pathMembers) {
<span class="fc" id="L604">		Member member = pathMembers.get(pathMembers.size() - 1);</span>
		// a calculated member cannot be expanded
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">		if (member.isCalculated()) {</span>
<span class="nc" id="L607">			return false;</span>
		}

		try {
<span class="fc bfc" id="L611" title="All 2 branches covered.">			if (member.getChildMemberCount() &lt;= 0) {</span>
<span class="fc" id="L612">				return false;</span>
			}
<span class="nc" id="L614">		} catch (OlapException e) {</span>
<span class="nc" id="L615">			throw new PivotException(e);</span>
		}

<span class="fc" id="L618">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L619">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L621" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canExpand(pathMembers);</span>
	}

	/**
	 * @param member
	 *            Member to be collapsed
	 * @return true if the member can be collapsed
	 */
	public boolean canCollapse(Member member) {
		// a calculated member cannot be collapsed
<span class="pc bpc" id="L631" title="1 of 2 branches missed.">		if (member.isCalculated()) {</span>
<span class="nc" id="L632">			return false;</span>
		}

<span class="fc" id="L635">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L636">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L638" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canCollapse(member);</span>
	}

	/**
	 * @param position
	 *            position to be expanded
	 * @return true if the position can be collapsed
	 */
	public boolean canCollapse(List&lt;Member&gt; pathMembers) {
<span class="fc" id="L647">		Member member = pathMembers.get(pathMembers.size() - 1);</span>
		// a calculated member cannot be expanded
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">		if (member.isCalculated()) {</span>
<span class="nc" id="L650">			return false;</span>
		}

<span class="fc" id="L653">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L654">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L656" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canCollapse(pathMembers);</span>
	}

	/**
	 * Expand a member in all positions this is done by applying
	 * ToggleDrillState to the Query
	 * 
	 * @param member
	 *            member to be expanded
	 */
	public void expand(Member member) {
<span class="fc" id="L667">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L668">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L670" title="1 of 2 branches missed.">		if (logger.isInfoEnabled()) {</span>
<span class="fc" id="L671">			logger.info(&quot;Expand member&quot; + getPositionString(null, member));</span>
		}

<span class="pc bpc" id="L674" title="2 of 4 branches missed.">		if ((quax == null) || !quax.canExpand(member)) {</span>
<span class="nc" id="L675">			String msg = &quot;Expand member failed for&quot; + member.getUniqueName();</span>
<span class="nc" id="L676">			throw new PivotException(msg);</span>
		}

<span class="fc" id="L679">		quax.expand(member);</span>

<span class="fc" id="L681">		fireQueryChanged();</span>
<span class="fc" id="L682">	}</span>

	/**
	 * Expand a member in a specific position
	 * 
	 * @param pathMembers
	 *            members to be expanded
	 */
	public void expand(List&lt;Member&gt; pathMembers) {
<span class="fc" id="L691">		Member member = pathMembers.get(pathMembers.size() - 1);</span>
<span class="fc" id="L692">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L693">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L695" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L696">			logger.info(&quot;Expand path&quot; + getPositionString(pathMembers, null));</span>
		}

<span class="pc bpc" id="L699" title="2 of 4 branches missed.">		if ((quax == null) || !quax.canExpand(pathMembers)) {</span>
<span class="nc" id="L700">			String msg = &quot;Expand failed for&quot;</span>
<span class="nc" id="L701">					+ getPositionString(pathMembers, null);</span>
<span class="nc" id="L702">			throw new PivotException(msg);</span>
		}

<span class="fc" id="L705">		quax.expand(pathMembers);</span>

<span class="fc" id="L707">		fireQueryChanged();</span>
<span class="fc" id="L708">	}</span>

	/**
	 * Collapse a member in all positions
	 * 
	 * @param member
	 *            Member to be collapsed
	 */
	public void collapse(Member member) {
<span class="fc" id="L717">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>

<span class="pc bpc" id="L719" title="1 of 2 branches missed.">		if (logger.isInfoEnabled()) {</span>
<span class="fc" id="L720">			logger.info(&quot;Collapse &quot; + member.getUniqueName());</span>
		}

<span class="fc" id="L723">		Quax quax = findQuax(dim);</span>
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">		if (quax == null) {</span>
<span class="nc" id="L725">			String msg = &quot;Collapse quax was null &quot; + member.getUniqueName();</span>
<span class="nc" id="L726">			throw new PivotException(msg);</span>
		}

<span class="fc" id="L729">		quax.collapse(member);</span>

<span class="fc" id="L731">		fireQueryChanged();</span>
<span class="fc" id="L732">	}</span>

	/**
	 * Collapse a member in a specific position
	 * 
	 * @param position
	 *            Position to be collapsed
	 */
	public void collapse(List&lt;Member&gt; pathMembers) {
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L742">			logger.debug(&quot;Collapse&quot; + getPositionString(pathMembers, null));</span>
		}

<span class="fc" id="L745">		Member member = pathMembers.get(pathMembers.size() - 1);</span>
<span class="fc" id="L746">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L747">		Quax quax = findQuax(dim);</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">		if (quax == null) {</span>
<span class="nc" id="L749">			String msg = &quot;Collapse quax was null&quot;</span>
<span class="nc" id="L750">					+ getPositionString(pathMembers, null);</span>
<span class="nc" id="L751">			throw new PivotException(msg);</span>
		}

<span class="fc" id="L754">		quax.collapse(pathMembers);</span>

<span class="fc" id="L756">		fireQueryChanged();</span>
<span class="fc" id="L757">	}</span>

	/**
	 * Drill down is possible if &lt;code&gt;member&lt;/code&gt; has children
	 * 
	 * @param member
	 *            Member to drill down
	 */
	public boolean canDrillDown(Member member) {
		try {
<span class="nc bnc" id="L767" title="All 2 branches missed.">			if (member.getChildMemberCount() &lt;= 0) {</span>
<span class="nc" id="L768">				return false;</span>
			}
<span class="nc" id="L770">		} catch (OlapException e) {</span>
<span class="nc" id="L771">			throw new PivotException(e);</span>
		}

<span class="nc" id="L774">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="nc" id="L775">		Quax quax = findQuax(dim);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">		return (quax == null) ? false : quax.canDrillDown(member);</span>
	}

	/**
	 * Drill up is possible if at least one member in the tree is not at the top
	 * level of this hierarchy.
	 */
	public boolean canDrillUp(Hierarchy hierarchy) {
<span class="nc" id="L784">		Quax quax = findQuax(hierarchy.getDimension());</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">		return (quax == null) ? false : quax.canDrillUp(hierarchy);</span>
	}

	/**
	 * After switch to Qubon mode: replaces the members. Let &lt;code&gt;H&lt;/code&gt; be
	 * the hierarchy that member belongs to. Then drillDown will replace all
	 * members from &lt;code&gt;H&lt;/code&gt; that are currently visible with the children
	 * of &lt;code&gt;member&lt;/code&gt;.
	 */
	public void drillDown(Member member) {
		// switch to Qubon mode, if not yet in
<span class="nc" id="L796">		Quax quax = findQuax(member.getLevel().getHierarchy().getDimension());</span>

<span class="nc bnc" id="L798" title="All 2 branches missed.">		if (quax == null) {</span>
<span class="nc" id="L799">			logger.info(&quot;drillDown Quax was null&quot;</span>
<span class="nc" id="L800">					+ getPositionString(null, member));</span>
<span class="nc" id="L801">			return;</span>
		}

		// replace dimension iDim by monMember.children
<span class="nc" id="L805">		quax.drillDown(member);</span>

<span class="nc" id="L807">		fireQueryChanged();</span>

<span class="nc bnc" id="L809" title="All 2 branches missed.">		if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L810">			logger.info(&quot;Drill down &quot; + getPositionString(null, member));</span>
		}
<span class="nc" id="L812">	}</span>

	/**
	 * After switch to Qubon mode: replaces all visible members of hier with the
	 * members of the next higher level.
	 */
	public void drillUp(Hierarchy hierarchy) {
		// switch to Qubon mode, if not yet in
<span class="nc" id="L820">		Quax quax = findQuax(hierarchy.getDimension());</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">		if (quax == null) {</span>
<span class="nc" id="L822">			String msg = &quot;Drill up hierarchy quax was null &quot;</span>
<span class="nc" id="L823">					+ hierarchy.getCaption();</span>
<span class="nc" id="L824">			throw new PivotException(msg);</span>
		}
<span class="nc" id="L826">		quax.drillUp(hierarchy);</span>

<span class="nc" id="L828">		fireQueryChanged();</span>

<span class="nc bnc" id="L830" title="All 2 branches missed.">		if (logger.isInfoEnabled())</span>
<span class="nc" id="L831">			logger.info(&quot;Drill up hierarchy &quot; + hierarchy.getCaption());</span>
<span class="nc" id="L832">	}</span>

	/**
	 * Display position member for debugging purposes
	 * 
	 * @param posMembers
	 * @param member
	 * @return
	 */
	protected String getPositionString(List&lt;Member&gt; posMembers, Member member) {
<span class="fc" id="L842">		StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">		if (posMembers != null) {</span>
<span class="fc" id="L844">			sb.append(&quot; Position=&quot;);</span>
<span class="fc" id="L845">			int i = 0;</span>
<span class="fc bfc" id="L846" title="All 2 branches covered.">			for (Member m : posMembers) {</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">				if (i &gt; 0) {</span>
<span class="fc" id="L848">					sb.append(&quot; &quot;);</span>
				}
<span class="fc" id="L850">				sb.append(m.getUniqueName());</span>
<span class="fc" id="L851">				i++;</span>
			}
		}

<span class="fc bfc" id="L855" title="All 2 branches covered.">		if (member != null) {</span>
<span class="fc" id="L856">			sb.append(&quot; Member=&quot;);</span>
<span class="fc" id="L857">			sb.append(member.getUniqueName());</span>
		}

<span class="fc" id="L860">		return sb.toString();</span>
	}

	/**
	 * @param quax
	 * @param changedByNavigator
	 */
	protected void onQuaxChanged(Quax quax, boolean changedByNavigator) {
		// if the axis to sort (normaly *not* the measures)
		// was changed by the Navi GUI, we want to switch sorting off
<span class="pc bpc" id="L870" title="5 of 6 branches missed.">		if (changedByNavigator &amp;&amp; model.isSorting() &amp;&amp; quax == getQuaxToSort()) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L872">				logger.debug(&quot;Quax changed by navi - switch sorting off&quot;);</span>
			}

<span class="nc" id="L875">			model.setSorting(false);</span>
		}

<span class="fc" id="L878">		fireQueryChanged();</span>
<span class="fc" id="L879">	}</span>

	/**
	 * @see com.eyeq.pivot4j.StateHolder#bookmarkState()
	 */
	public Serializable bookmarkState() {
<span class="nc" id="L885">		Serializable[] state = new Serializable[4];</span>

<span class="nc" id="L887">		state[0] = isAxesSwapped();</span>
<span class="nc" id="L888">		state[1] = getUseQuax();</span>

<span class="nc" id="L890">		Quax quaxToSort = getQuaxToSort();</span>

<span class="nc bnc" id="L892" title="All 2 branches missed.">		if (quaxToSort == null) {</span>
<span class="nc" id="L893">			state[2] = -1;</span>
		} else {
<span class="nc" id="L895">			state[2] = quaxToSort.getOrdinal();</span>
		}

<span class="nc bnc" id="L898" title="All 2 branches missed.">		if (getUseQuax()) {</span>
<span class="nc" id="L899">			List&lt;Quax&gt; quaxes = getQuaxes();</span>

<span class="nc" id="L901">			Serializable[] quaxStates = new Serializable[quaxes.size()];</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">			for (int i = 0; i &lt; quaxStates.length; i++) {</span>
<span class="nc" id="L903">				quaxStates[i] = quaxes.get(i).bookmarkState();</span>
			}

<span class="nc" id="L906">			state[3] = quaxStates;</span>
		} else {
<span class="nc" id="L908">			state[3] = null;</span>
		}

<span class="nc" id="L911">		return state;</span>
	}

	/**
	 * @see com.eyeq.pivot4j.StateHolder#restoreState(java.io.Serializable)
	 */
	public void restoreState(Serializable state) {
<span class="nc" id="L918">		Serializable[] states = (Serializable[]) state;</span>

<span class="nc" id="L920">		this.axesSwapped = (Boolean) states[0];</span>
<span class="nc" id="L921">		this.useQuax = (Boolean) states[1];</span>

<span class="nc" id="L923">		int quaxOrdinal = (Integer) states[2];</span>

<span class="nc" id="L925">		Quax quaxToSort = null;</span>

<span class="nc bnc" id="L927" title="All 2 branches missed.">		if (quaxOrdinal &gt; -1) {</span>
<span class="nc" id="L928">			List&lt;Quax&gt; quaxes = getQuaxes();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">			for (Quax quax : quaxes) {</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">				if (quaxOrdinal == quax.getOrdinal()) {</span>
<span class="nc" id="L931">					quaxToSort = quax;</span>
<span class="nc" id="L932">					break;</span>
				}
			}
		}

<span class="nc" id="L937">		this.quaxToSort = quaxToSort;</span>

<span class="nc bnc" id="L939" title="All 2 branches missed.">		if (useQuax) {</span>
<span class="nc" id="L940">			Serializable[] quaxStates = (Serializable[]) states[3];</span>

			// reset the quaxes to current state
<span class="nc" id="L943">			List&lt;Quax&gt; quaxes = getQuaxes();</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">			if (quaxes.size() != quaxStates.length) {</span>
<span class="nc" id="L945">				throw new IllegalArgumentException(</span>
<span class="nc" id="L946">						&quot;Stored quax state is not compatible with the current MDX.&quot;);</span>
			}

<span class="nc bnc" id="L949" title="All 2 branches missed.">			for (int i = 0; i &lt; quaxStates.length; i++) {</span>
<span class="nc" id="L950">				quaxes.get(i).restoreState(quaxStates[i]);</span>
			}
		}

<span class="nc" id="L954">		fireQueryChanged();</span>
<span class="nc" id="L955">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.10.201208310627</span></div></body></html>