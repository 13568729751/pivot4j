<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QueryAdapter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Pivot4J</a> &gt; <a href="index.html" class="el_package">com.eyeq.pivot4j.query</a> &gt; <span class="el_source">QueryAdapter.java</span></div><h1>QueryAdapter.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">/*</span>
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 */
package com.eyeq.pivot4j.query;

import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import java_cup.runtime.Symbol;

import org.olap4j.CellSet;
import org.olap4j.CellSetAxis;
import org.olap4j.OlapException;
import org.olap4j.Position;
import org.olap4j.mdx.parser.MdxParser;
import org.olap4j.metadata.Dimension;
import org.olap4j.metadata.Hierarchy;
import org.olap4j.metadata.Member;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.eyeq.pivot4j.PivotException;
import com.eyeq.pivot4j.PivotModel;
import com.eyeq.pivot4j.StateHolder;
import com.eyeq.pivot4j.mdx.Exp;
import com.eyeq.pivot4j.mdx.FunCall;
import com.eyeq.pivot4j.mdx.Lexer;
import com.eyeq.pivot4j.mdx.Literal;
import com.eyeq.pivot4j.mdx.ParsedQuery;
import com.eyeq.pivot4j.mdx.Parser;
import com.eyeq.pivot4j.mdx.QueryAxis;
import com.eyeq.pivot4j.mdx.Syntax;

/**
 * Adapt the MDX query to the model
 */
<span class="fc" id="L47">public class QueryAdapter implements StateHolder {</span>

<span class="fc" id="L49">	protected static Logger logger = LoggerFactory</span>
<span class="fc" id="L50">			.getLogger(QueryAdapter.class);</span>

	private PivotModel model;

	private List&lt;Quax&gt; quaxes; // Array of query axis state object

<span class="fc" id="L56">	private boolean useQuax = false;</span>

<span class="fc" id="L58">	private boolean axesSwapped = false;</span>

	private Quax quaxToSort; // this is the Quax to be sorted

	private ParsedQuery parsedQuery;

	private ParsedQuery cloneQuery;

<span class="fc" id="L66">	private Collection&lt;QueryChangeListener&gt; listeners = new ArrayList&lt;QueryChangeListener&gt;();</span>

<span class="fc" id="L68">	private QuaxChangeListener quaxListener = new QuaxChangeListener() {</span>

		public void quaxChanged(QuaxChangeEvent e) {
<span class="fc" id="L71">			onQuaxChanged(e.getQuax(), e.isChangedByNavigator());</span>
<span class="fc" id="L72">		}</span>
	};

	/**
	 * @param model
	 * @param parser
	 */
<span class="fc" id="L79">	public QueryAdapter(PivotModel model, MdxParser parser) {</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">		if (model == null) {</span>
<span class="nc" id="L81">			throw new IllegalArgumentException(</span>
<span class="nc" id="L82">					&quot;Missing required argument 'model'.&quot;);</span>
		}

<span class="pc bpc" id="L85" title="1 of 2 branches missed.">		if (parser == null) {</span>
<span class="nc" id="L86">			throw new IllegalArgumentException(</span>
<span class="nc" id="L87">					&quot;Missing required argument 'parser'.&quot;);</span>
		}

<span class="fc" id="L90">		this.model = model;</span>
<span class="fc" id="L91">		this.parsedQuery = parseQuery(model.getMdx());</span>

<span class="fc" id="L93">		QueryAxis[] queryAxes = parsedQuery.getAxes();</span>

<span class="fc" id="L95">		this.quaxes = new ArrayList&lt;Quax&gt;(queryAxes.length);</span>

<span class="fc" id="L97">		int ordinal = 0;</span>
		for (@SuppressWarnings(&quot;unused&quot;)
<span class="fc bfc" id="L99" title="All 2 branches covered.">		QueryAxis queryAxis : queryAxes) {</span>
<span class="fc" id="L100">			Quax quax = new Quax(ordinal++, parser);</span>
<span class="fc" id="L101">			quax.addChangeListener(quaxListener);</span>

<span class="fc" id="L103">			quaxes.add(quax);</span>
		}
<span class="fc" id="L105">	}</span>

	/**
	 * @return the model
	 */
	public PivotModel getModel() {
<span class="fc" id="L111">		return model;</span>
	}

	/**
	 * Register change listener
	 * 
	 * @param listener
	 */
	public void addChangeListener(QueryChangeListener listener) {
<span class="fc" id="L120">		listeners.add(listener);</span>
<span class="fc" id="L121">	}</span>

	/**
	 * Unregister change listener
	 * 
	 * @param listener
	 */
	public void removeChangeListener(QueryChangeListener listener) {
<span class="fc" id="L129">		listeners.remove(listener);</span>
<span class="fc" id="L130">	}</span>

	protected void fireQueryChanged() {
<span class="fc" id="L133">		fireQueryChanged(true);</span>
<span class="fc" id="L134">	}</span>

	protected void fireQueryChanged(boolean update) {
<span class="fc bfc" id="L137" title="All 2 branches covered.">		if (update) {</span>
<span class="fc" id="L138">			this.useQuax = true;</span>

<span class="fc" id="L140">			updateQuery();</span>
		}

<span class="fc" id="L143">		QueryChangeEvent e = new QueryChangeEvent(this);</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">		for (QueryChangeListener listener : listeners) {</span>
<span class="fc" id="L145">			listener.queryChanged(e);</span>
		}
<span class="fc" id="L147">	}</span>

	/**
	 * @return the XMLA Query object
	 */
	protected ParsedQuery getParsedQuery() {
<span class="nc" id="L153">		return parsedQuery;</span>
	}

	public String getCurrentMdx() {
<span class="fc" id="L157">		return parsedQuery.toMdx();</span>
	}

	/**
	 * @return
	 */
	public List&lt;Quax&gt; getQuaxes() {
<span class="nc" id="L164">		return Collections.unmodifiableList(quaxes);</span>
	}

	/**
	 * @return true if quas is to be used
	 */
	public boolean getUseQuax() {
<span class="nc" id="L171">		return useQuax;</span>
	}

	/**
	 * @return true, if axes are currently swapped
	 */
	public boolean isAxesSwapped() {
<span class="nc" id="L178">		return axesSwapped;</span>
	}

	/**
	 * @param axesSwapped
	 */
	public void setAxesSwapped(boolean axesSwapped) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">		if (parsedQuery.getAxes().length &gt;= 2) {</span>
<span class="nc" id="L186">			this.axesSwapped = axesSwapped;</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">			if (logger.isInfoEnabled()) {</span>
<span class="nc" id="L189">				logger.info(&quot;swapAxes &quot; + axesSwapped);</span>
			}

<span class="nc" id="L192">			fireQueryChanged();</span>
		}
<span class="nc" id="L194">	}</span>

	/**
	 * @return the quaxToSort
	 */
	public Quax getQuaxToSort() {
<span class="nc" id="L200">		return quaxToSort;</span>
	}

	/**
	 * @param quaxToSort
	 *            the quaxToSort to set
	 */
	public void setQuaxToSort(Quax quaxToSort) {
<span class="nc" id="L208">		this.quaxToSort = quaxToSort;</span>
<span class="nc" id="L209">	}</span>

	protected boolean isSortOnQuery() {
<span class="pc bpc" id="L212" title="3 of 4 branches missed.">		return model.isSorting() &amp;&amp; model.getSortPosMembers() != null</span>
<span class="pc bnc" id="L213" title="All 2 branches missed.">				&amp;&amp; !model.getSortPosMembers().isEmpty();</span>
	}

	/**
	 * @return ordinal of quax to sort, if sorting is active
	 */
	protected int activeQuaxToSort() {
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">		if (isSortOnQuery()) {</span>
<span class="nc" id="L221">			return quaxToSort.getOrdinal();</span>
		} else {
<span class="fc" id="L223">			return -1;</span>
		}
	}

	/**
	 * find the Quax for a specific dimension
	 * 
	 * @param dim
	 *            Dimension
	 * @return Quax containg dimension
	 */
	public Quax findQuax(Dimension dim) {
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">		for (Quax quax : quaxes) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">			if (quax.dimIdx(dim) &gt;= 0) {</span>
<span class="fc" id="L237">				return quax;</span>
			}
		}
<span class="nc" id="L240">		return null;</span>
	}

	/**
	 * Update the Query Object before Execute. The current query is build from -
	 * the original query - adding the drilldown groups - apply pending swap
	 * axes - apply pending sorts.
	 */
	public ParsedQuery updateQuery() {
		// if quax is to be used, generate axes from quax
<span class="fc bfc" id="L250" title="All 2 branches covered.">		if (useQuax) {</span>
<span class="fc" id="L251">			int iQuaxToSort = activeQuaxToSort();</span>

<span class="fc" id="L253">			QueryAxis[] qAxes = parsedQuery.getAxes();</span>

<span class="fc" id="L255">			int i = 0;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">			for (Quax quax : quaxes) {</span>
<span class="fc" id="L257">				boolean doHierarchize = false;</span>
<span class="pc bpc" id="L258" title="1 of 4 branches missed.">				if (quax.isHierarchizeNeeded() &amp;&amp; i != iQuaxToSort) {</span>
<span class="fc" id="L259">					doHierarchize = true;</span>

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">					if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L262">						logger.debug(&quot;MDX Generation added Hierarchize()&quot;);</span>
					}
				}

<span class="fc" id="L266">				Exp eSet = quax.genExp(doHierarchize);</span>
<span class="fc" id="L267">				qAxes[i].setExp(eSet);</span>

<span class="fc" id="L269">				i++;</span>
			}
		}

		// generate order function if neccessary
<span class="fc bfc" id="L274" title="All 2 branches covered.">		if (!useQuax) {</span>
			// if Quax is used, the axis exp's are re-generated every time.
			// if not -
			// adding a sort to the query must not be permanent.
			// Therefore, we clone the orig state of the query object and
			// use
			// the clone furthermore in order to avoid duplicate &quot;Order&quot;
			// functions.
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">			if (cloneQuery == null) {</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">				if (isSortOnQuery()) {</span>
<span class="nc" id="L284">					this.cloneQuery = parsedQuery.clone();</span>
				}
			} else {
				// reset to original state
<span class="nc bnc" id="L288" title="All 2 branches missed.">				if (isSortOnQuery()) {</span>
<span class="nc" id="L289">					this.parsedQuery = cloneQuery.clone();</span>
				} else {
<span class="nc" id="L291">					this.parsedQuery = cloneQuery;</span>
				}
			}

<span class="fc" id="L295">			addSortToQuery();</span>
		}

		// swap axes function if neccessary
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">		if (axesSwapped) {</span>
<span class="nc" id="L300">			swapAxes();</span>
		}

<span class="fc" id="L303">		return parsedQuery;</span>
	}

	/**
	 * Apply sort to query
	 */
	public void addSortToQuery() {
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">		if (isSortOnQuery()) {</span>
<span class="nc bnc" id="L311" title="All 4 branches missed.">			switch (model.getSortMode()) {</span>
			case ASC:
			case DESC:
			case BASC:
			case BDESC:
				// call sort
<span class="nc" id="L317">				orderAxis(parsedQuery);</span>
<span class="nc" id="L318">				break;</span>
			case TOPCOUNT:
<span class="nc" id="L320">				topBottomAxis(parsedQuery, &quot;TopCount&quot;);</span>
<span class="nc" id="L321">				break;</span>
			case BOTTOMCOUNT:
<span class="nc" id="L323">				topBottomAxis(parsedQuery, &quot;BottomCount&quot;);</span>
<span class="nc" id="L324">				break;</span>
			default:
<span class="nc" id="L326">				return; // do nothing</span>
			}
		}
<span class="fc" id="L329">	}</span>

	/**
	 * Add Order Funcall to QueryAxis
	 * 
	 * @param monAx
	 * @param monSortMode
	 */
	protected void orderAxis(ParsedQuery pq) {
		// Order(TopCount) is allowed, Order(Order) is not permitted
<span class="nc" id="L339">		QueryAxis[] queryAxes = pq.getAxes();</span>
<span class="nc" id="L340">		QueryAxis qa = queryAxes[quaxToSort.getOrdinal()];</span>

<span class="nc" id="L342">		Exp setForAx = qa.getExp();</span>

		// setForAx is the top level Exp of the axis
		// put an Order FunCall around
<span class="nc" id="L346">		Exp[] args = new Exp[3];</span>
<span class="nc" id="L347">		args[0] = setForAx; // the set to be sorted is the set representing the</span>
							// query axis
		// if we got more than 1 position member, generate a tuple for the 2.arg
		Exp sortExp;

<span class="nc" id="L352">		List&lt;Member&gt; sortPosMembers = model.getSortPosMembers();</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">		if (sortPosMembers == null) {</span>
<span class="nc" id="L354">			return;</span>
		}

<span class="nc bnc" id="L357" title="All 2 branches missed.">		if (sortPosMembers.size() &gt; 1) {</span>
<span class="nc" id="L358">			Exp[] memberExp = new Exp[sortPosMembers.size()];</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">			for (int i = 0; i &lt; memberExp.length; i++) {</span>
<span class="nc" id="L360">				memberExp[i] = QuaxUtil.expForMember(sortPosMembers.get(i));</span>
			}

<span class="nc" id="L363">			sortExp = new FunCall(&quot;()&quot;, memberExp, Syntax.Parentheses);</span>
		} else {
<span class="nc" id="L365">			sortExp = QuaxUtil.expForMember(sortPosMembers.get(0));</span>
		}

<span class="nc" id="L368">		args[1] = sortExp;</span>
<span class="nc" id="L369">		args[2] = Literal.createString(model.getSortMode().name());</span>

<span class="nc" id="L371">		FunCall order = new FunCall(&quot;Order&quot;, args, Syntax.Function);</span>
<span class="nc" id="L372">		qa.setExp(order);</span>
<span class="nc" id="L373">	}</span>

	/**
	 * Add Top/BottomCount Funcall to QueryAxis
	 * 
	 * @param monAx
	 * @param nShow
	 */
	protected void topBottomAxis(ParsedQuery pq, String function) {
		// TopCount(TopCount) and TopCount(Order) is not permitted
<span class="nc" id="L383">		QueryAxis[] queryAxes = pq.getAxes();</span>
<span class="nc" id="L384">		QueryAxis qa = queryAxes[quaxToSort.getOrdinal()];</span>
<span class="nc" id="L385">		Exp setForAx = qa.getExp();</span>
		Exp sortExp;

<span class="nc" id="L388">		List&lt;Member&gt; sortPosMembers = model.getSortPosMembers();</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">		if (sortPosMembers == null) {</span>
<span class="nc" id="L390">			return;</span>
		}

		// if we got more than 1 position member, generate a tuple
<span class="nc bnc" id="L394" title="All 2 branches missed.">		if (sortPosMembers.size() &gt; 1) {</span>
<span class="nc" id="L395">			Exp[] memberExp = new Exp[sortPosMembers.size()];</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">			for (int i = 0; i &lt; memberExp.length; i++) {</span>
<span class="nc" id="L397">				memberExp[i] = QuaxUtil.expForMember(sortPosMembers.get(i));</span>
			}
<span class="nc" id="L399">			sortExp = new FunCall(&quot;()&quot;, memberExp, Syntax.Parentheses);</span>
		} else {
<span class="nc" id="L401">			sortExp = QuaxUtil.expForMember(sortPosMembers.get(0));</span>
		}

<span class="nc" id="L404">		Exp[] args = new Exp[3];</span>
<span class="nc" id="L405">		args[0] = setForAx; // the set representing the query axis</span>
<span class="nc" id="L406">		args[1] = Literal.create(model.getTopBottomCount());</span>
<span class="nc" id="L407">		args[2] = sortExp;</span>

<span class="nc" id="L409">		FunCall topbottom = new FunCall(function, args, Syntax.Function);</span>
<span class="nc" id="L410">		qa.setExp(topbottom);</span>
<span class="nc" id="L411">	}</span>

	/**
	 * Swap axes in parsed query
	 */
	protected void swapAxes() {
<span class="nc" id="L417">		QueryAxis[] queryAxes = parsedQuery.getAxes();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">		if (queryAxes.length &gt;= 2) {</span>
<span class="nc" id="L419">			Exp exp = queryAxes[0].getExp();</span>
<span class="nc" id="L420">			queryAxes[0].setExp(queryAxes[1].getExp());</span>
<span class="nc" id="L421">			queryAxes[1].setExp(exp);</span>
		}
<span class="nc" id="L423">	}</span>

	/**
	 * @param mdxQuery
	 */
	protected ParsedQuery parseQuery(String mdxQuery) {
<span class="fc" id="L429">		Reader reader = new StringReader(mdxQuery);</span>
<span class="fc" id="L430">		Parser parser = new Parser(new Lexer(reader));</span>

		ParsedQuery parsedQuery;

		try {
<span class="fc" id="L435">			Symbol parseTree = parser.parse();</span>
<span class="fc" id="L436">			parsedQuery = (ParsedQuery) parseTree.value;</span>
<span class="nc" id="L437">		} catch (RuntimeException e) {</span>
<span class="nc" id="L438">			throw e;</span>
<span class="nc" id="L439">		} catch (Exception e) {</span>
<span class="nc" id="L440">			throw new PivotException(e);</span>
		}

<span class="fc" id="L443">		parsedQuery.afterParse();</span>

<span class="fc" id="L445">		return parsedQuery;</span>
	}

	/**
	 * After the startup query was run: get the current positions as array of
	 * array of member. Called from Model.getResult after the query was
	 * executed.
	 * 
	 * @param result
	 *            the result which redefines the query axes
	 */
	public void afterExecute(CellSet cellSet) {
<span class="fc" id="L457">		List&lt;CellSetAxis&gt; axes = cellSet.getAxes();</span>

		// initialization: get the result positions and set it to quax
		// if the quaxes are not yet used to generate the query
<span class="fc bfc" id="L461" title="All 2 branches covered.">		if (!useQuax) {</span>
<span class="fc" id="L462">			int i = 0;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">			for (CellSetAxis axis : axes) {</span>
<span class="fc" id="L464">				List&lt;Position&gt; positions = axis.getPositions();</span>

<span class="pc bpc" id="L466" title="1 of 2 branches missed.">				int index = axesSwapped ? (i + 1) % 2 : i;</span>
<span class="fc" id="L467">				quaxes.get(index).initialize(positions);</span>

<span class="fc" id="L469">				i++;</span>
			}
		} else {
			// hierarchize result if neccessary
<span class="fc" id="L473">			int i = 0;</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">			for (Quax quax : quaxes) {</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">				int index = axesSwapped ? (i + 1) % 2 : i;</span>
<span class="fc" id="L476">				List&lt;Position&gt; positions = axes.get(index).getPositions();</span>

				// after a result for CalcSet.GENERATE was gotten
				// we have to re-initialize the quax,
				// so that we can navigate.
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">				if (quax.getGenerateMode() == CalcSetMode.Generate) {</span>
<span class="nc" id="L482">					quax.resetGenerate();</span>
<span class="nc" id="L483">					quax.initialize(positions);</span>
				} else {
					// unknown function members are collected
					// - always for a &quot;Sticky generate&quot; unknown function
					// - on first result for any other unknown function
<span class="fc" id="L488">					int nDimension = quax.getNDimension();</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">					for (int j = 0; j &lt; nDimension; j++) {</span>
						// collect members for unknown functions on quax
<span class="pc bpc" id="L491" title="1 of 2 branches missed.">						if (quax.isUnknownFunction(j)) {</span>
<span class="nc" id="L492">							List&lt;Member&gt; members = memListForHier(j, positions);</span>
<span class="nc" id="L493">							quax.setHierMemberList(j, members);</span>
						}
					}
				}
<span class="fc" id="L497">				i++;</span>
			}
		}

<span class="pc bpc" id="L501" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
			// print the result positions to logger
<span class="fc bfc" id="L503" title="All 2 branches covered.">			for (CellSetAxis axis : axes) {</span>
<span class="fc" id="L504">				List&lt;Position&gt; positions = axis.getPositions();</span>
<span class="fc" id="L505">				logger.debug(&quot;Positions of axis &quot;</span>
<span class="fc" id="L506">						+ axis.getAxisOrdinal().axisOrdinal());</span>

<span class="pc bpc" id="L508" title="1 of 2 branches missed.">				if (positions.size() == 0) {</span>
					// the axis does not have any positions
<span class="nc" id="L510">					logger.debug(&quot;0 positions&quot;);</span>
				} else {
<span class="fc" id="L512">					int nDimension = positions.get(0).getMembers().size();</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">					for (Position position : positions) {</span>
<span class="fc" id="L514">						List&lt;Member&gt; members = position.getMembers();</span>

<span class="fc" id="L516">						StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">						for (int j = 0; j &lt; nDimension; j++) {</span>
<span class="fc bfc" id="L518" title="All 2 branches covered.">							if (j &gt; 0) {</span>
<span class="fc" id="L519">								sb.append(&quot; * &quot;);</span>
							}

<span class="fc" id="L522">							List&lt;Member&gt; memsj = new ArrayList&lt;Member&gt;(j + 1);</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">							for (int k = 0; k &lt;= j; k++) {</span>
<span class="fc" id="L524">								memsj.add(members.get(k));</span>
							}

<span class="fc bfc" id="L527" title="All 2 branches covered.">							if (this.canExpand(memsj)) {</span>
<span class="fc" id="L528">								sb.append(&quot;(+)&quot;);</span>
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">							} else if (this.canCollapse(memsj)) {</span>
<span class="nc" id="L530">								sb.append(&quot;(-)&quot;);</span>
							} else {
<span class="fc" id="L532">								sb.append(&quot;   &quot;);</span>
							}

<span class="fc" id="L535">							sb.append(members.get(j).getUniqueName());</span>
						}
<span class="fc" id="L537">						logger.debug(sb.toString());</span>
					}
				}
			}
		}
<span class="fc" id="L542">	}</span>

	/**
	 * Extract members of hier from Result
	 * 
	 * @param hierIndex
	 * @return members of hier
	 */
	protected List&lt;Member&gt; memListForHier(int hierIndex,
			List&lt;Position&gt; positions) {
<span class="nc" id="L552">		List&lt;Member&gt; members = new ArrayList&lt;Member&gt;();</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">		for (Position position : positions) {</span>
<span class="nc" id="L554">			Member member = position.getMembers().get(hierIndex);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">			if (!members.contains(member)) {</span>
<span class="nc" id="L556">				members.add(member);</span>
			}
		}

<span class="nc" id="L560">		return members;</span>
	}

	/**
	 * Create set expression for list of members
	 * 
	 * @param members
	 * @return set expression
	 */
	protected Object createMemberSet(List&lt;Member&gt; members) {
<span class="nc" id="L570">		Exp[] exps = new Exp[members.size()];</span>

<span class="nc" id="L572">		int i = 0;</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">		for (Member member : members) {</span>
<span class="nc" id="L574">			exps[i++] = QuaxUtil.expForMember(member);</span>
		}

<span class="nc" id="L577">		return new FunCall(&quot;{}&quot;, exps, Syntax.Braces);</span>
	}

	/**
	 * Find out, whether a member can be expanded. this is true, if - the member
	 * is on an axis and - the member is not yet expanded and - the member has
	 * children
	 * 
	 * @param member
	 *            Member to be expanded
	 * @return true if the member can be expanded
	 */
	public boolean canExpand(Member member) {
		// a calculated member cannot be expanded
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">		if (member.isCalculated()) {</span>
<span class="nc" id="L592">			return false;</span>
		}

		try {
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">			if (member.getChildMemberCount() &lt;= 0) {</span>
<span class="nc" id="L597">				return false;</span>
			}
<span class="nc" id="L599">		} catch (OlapException e) {</span>
<span class="nc" id="L600">			throw new PivotException(e);</span>
		}

<span class="fc" id="L603">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L604">		Quax quax = findQuax(dim);</span>
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canExpand(member);</span>
	}

	/**
	 * @param pathMembers
	 *            Members to be expanded
	 * @return true if the member can be expanded
	 */
	public boolean canExpand(List&lt;Member&gt; pathMembers) {
<span class="fc" id="L614">		Member member = pathMembers.get(pathMembers.size() - 1);</span>
		// a calculated member cannot be expanded
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">		if (member.isCalculated()) {</span>
<span class="nc" id="L617">			return false;</span>
		}

		try {
<span class="fc bfc" id="L621" title="All 2 branches covered.">			if (member.getChildMemberCount() &lt;= 0) {</span>
<span class="fc" id="L622">				return false;</span>
			}
<span class="nc" id="L624">		} catch (OlapException e) {</span>
<span class="nc" id="L625">			throw new PivotException(e);</span>
		}

<span class="fc" id="L628">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L629">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L631" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canExpand(pathMembers);</span>
	}

	/**
	 * @param member
	 *            Member to be collapsed
	 * @return true if the member can be collapsed
	 */
	public boolean canCollapse(Member member) {
		// a calculated member cannot be collapsed
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">		if (member.isCalculated()) {</span>
<span class="nc" id="L642">			return false;</span>
		}

<span class="fc" id="L645">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L646">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L648" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canCollapse(member);</span>
	}

	/**
	 * @param position
	 *            position to be expanded
	 * @return true if the position can be collapsed
	 */
	public boolean canCollapse(List&lt;Member&gt; pathMembers) {
<span class="fc" id="L657">		Member member = pathMembers.get(pathMembers.size() - 1);</span>
		// a calculated member cannot be expanded
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">		if (member.isCalculated()) {</span>
<span class="nc" id="L660">			return false;</span>
		}

<span class="fc" id="L663">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L664">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L666" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canCollapse(pathMembers);</span>
	}

	/**
	 * Expand a member in all positions this is done by applying
	 * ToggleDrillState to the Query
	 * 
	 * @param member
	 *            member to be expanded
	 */
	public void expand(Member member) {
<span class="fc" id="L677">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L678">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L680" title="1 of 2 branches missed.">		if (logger.isInfoEnabled()) {</span>
<span class="fc" id="L681">			logger.info(&quot;Expand member&quot; + getPositionString(null, member));</span>
		}

<span class="pc bpc" id="L684" title="2 of 4 branches missed.">		if ((quax == null) || !quax.canExpand(member)) {</span>
<span class="nc" id="L685">			String msg = &quot;Expand member failed for&quot; + member.getUniqueName();</span>
<span class="nc" id="L686">			throw new PivotException(msg);</span>
		}

<span class="fc" id="L689">		quax.expand(member);</span>

<span class="fc" id="L691">		fireQueryChanged();</span>
<span class="fc" id="L692">	}</span>

	/**
	 * Expand a member in a specific position
	 * 
	 * @param pathMembers
	 *            members to be expanded
	 */
	public void expand(List&lt;Member&gt; pathMembers) {
<span class="fc" id="L701">		Member member = pathMembers.get(pathMembers.size() - 1);</span>
<span class="fc" id="L702">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L703">		Quax quax = findQuax(dim);</span>

<span class="pc bpc" id="L705" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L706">			logger.info(&quot;Expand path&quot; + getPositionString(pathMembers, null));</span>
		}

<span class="pc bpc" id="L709" title="2 of 4 branches missed.">		if ((quax == null) || !quax.canExpand(pathMembers)) {</span>
<span class="nc" id="L710">			String msg = &quot;Expand failed for&quot;</span>
<span class="nc" id="L711">					+ getPositionString(pathMembers, null);</span>
<span class="nc" id="L712">			throw new PivotException(msg);</span>
		}

<span class="fc" id="L715">		quax.expand(pathMembers);</span>

<span class="fc" id="L717">		fireQueryChanged();</span>
<span class="fc" id="L718">	}</span>

	/**
	 * Collapse a member in all positions
	 * 
	 * @param member
	 *            Member to be collapsed
	 */
	public void collapse(Member member) {
<span class="fc" id="L727">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>

<span class="pc bpc" id="L729" title="1 of 2 branches missed.">		if (logger.isInfoEnabled()) {</span>
<span class="fc" id="L730">			logger.info(&quot;Collapse &quot; + member.getUniqueName());</span>
		}

<span class="fc" id="L733">		Quax quax = findQuax(dim);</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">		if (quax == null) {</span>
<span class="nc" id="L735">			String msg = &quot;Collapse quax was null &quot; + member.getUniqueName();</span>
<span class="nc" id="L736">			throw new PivotException(msg);</span>
		}

<span class="fc" id="L739">		quax.collapse(member);</span>

<span class="fc" id="L741">		fireQueryChanged();</span>
<span class="fc" id="L742">	}</span>

	/**
	 * Collapse a member in a specific position
	 * 
	 * @param position
	 *            Position to be collapsed
	 */
	public void collapse(List&lt;Member&gt; pathMembers) {
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L752">			logger.debug(&quot;Collapse&quot; + getPositionString(pathMembers, null));</span>
		}

<span class="fc" id="L755">		Member member = pathMembers.get(pathMembers.size() - 1);</span>
<span class="fc" id="L756">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L757">		Quax quax = findQuax(dim);</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">		if (quax == null) {</span>
<span class="nc" id="L759">			String msg = &quot;Collapse quax was null&quot;</span>
<span class="nc" id="L760">					+ getPositionString(pathMembers, null);</span>
<span class="nc" id="L761">			throw new PivotException(msg);</span>
		}

<span class="fc" id="L764">		quax.collapse(pathMembers);</span>

<span class="fc" id="L766">		fireQueryChanged();</span>
<span class="fc" id="L767">	}</span>

	/**
	 * Drill down is possible if &lt;code&gt;member&lt;/code&gt; has children
	 * 
	 * @param member
	 *            Member to drill down
	 */
	public boolean canDrillDown(Member member) {
		try {
<span class="fc bfc" id="L777" title="All 2 branches covered.">			if (member.getChildMemberCount() &lt;= 0) {</span>
<span class="fc" id="L778">				return false;</span>
			}
<span class="nc" id="L780">		} catch (OlapException e) {</span>
<span class="nc" id="L781">			throw new PivotException(e);</span>
		}

<span class="fc" id="L784">		Dimension dim = member.getLevel().getHierarchy().getDimension();</span>
<span class="fc" id="L785">		Quax quax = findQuax(dim);</span>
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canDrillDown(member);</span>
	}

	/**
	 * Drill up is possible if at least one member in the tree is not at the top
	 * level of this hierarchy.
	 */
	public boolean canDrillUp(Hierarchy hierarchy) {
<span class="fc" id="L794">		Quax quax = findQuax(hierarchy.getDimension());</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">		return (quax == null) ? false : quax.canDrillUp(hierarchy);</span>
	}

	/**
	 * After switch to Qubon mode: replaces the members. Let &lt;code&gt;H&lt;/code&gt; be
	 * the hierarchy that member belongs to. Then drillDown will replace all
	 * members from &lt;code&gt;H&lt;/code&gt; that are currently visible with the children
	 * of &lt;code&gt;member&lt;/code&gt;.
	 */
	public void drillDown(Member member) {
		// switch to Qubon mode, if not yet in
<span class="fc" id="L806">		Quax quax = findQuax(member.getLevel().getHierarchy().getDimension());</span>

<span class="pc bpc" id="L808" title="1 of 2 branches missed.">		if (quax == null) {</span>
<span class="nc" id="L809">			logger.info(&quot;drillDown Quax was null&quot;</span>
<span class="nc" id="L810">					+ getPositionString(null, member));</span>
<span class="nc" id="L811">			return;</span>
		}

		// replace dimension iDim by monMember.children
<span class="fc" id="L815">		quax.drillDown(member);</span>

<span class="fc" id="L817">		fireQueryChanged();</span>

<span class="pc bpc" id="L819" title="1 of 2 branches missed.">		if (logger.isInfoEnabled()) {</span>
<span class="fc" id="L820">			logger.info(&quot;Drill down &quot; + getPositionString(null, member));</span>
		}
<span class="fc" id="L822">	}</span>

	/**
	 * After switch to Qubon mode: replaces all visible members of hier with the
	 * members of the next higher level.
	 */
	public void drillUp(Hierarchy hierarchy) {
		// switch to Qubon mode, if not yet in
<span class="fc" id="L830">		Quax quax = findQuax(hierarchy.getDimension());</span>
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">		if (quax == null) {</span>
<span class="nc" id="L832">			String msg = &quot;Drill up hierarchy quax was null &quot;</span>
<span class="nc" id="L833">					+ hierarchy.getCaption();</span>
<span class="nc" id="L834">			throw new PivotException(msg);</span>
		}
<span class="fc" id="L836">		quax.drillUp(hierarchy);</span>

<span class="fc" id="L838">		fireQueryChanged();</span>

<span class="pc bpc" id="L840" title="1 of 2 branches missed.">		if (logger.isInfoEnabled())</span>
<span class="fc" id="L841">			logger.info(&quot;Drill up hierarchy &quot; + hierarchy.getCaption());</span>
<span class="fc" id="L842">	}</span>

	/**
	 * @param slicerExp
	 */
	public void changeSlicer(Exp exp) {
<span class="fc" id="L848">		parsedQuery.setSlicer(exp);</span>
<span class="fc" id="L849">		fireQueryChanged(false);</span>
<span class="fc" id="L850">	}</span>

	/**
	 * Display position member for debugging purposes
	 * 
	 * @param posMembers
	 * @param member
	 * @return
	 */
	protected String getPositionString(List&lt;Member&gt; posMembers, Member member) {
<span class="fc" id="L860">		StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">		if (posMembers != null) {</span>
<span class="fc" id="L862">			sb.append(&quot; Position=&quot;);</span>
<span class="fc" id="L863">			int i = 0;</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">			for (Member m : posMembers) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">				if (i &gt; 0) {</span>
<span class="fc" id="L866">					sb.append(&quot; &quot;);</span>
				}
<span class="fc" id="L868">				sb.append(m.getUniqueName());</span>
<span class="fc" id="L869">				i++;</span>
			}
		}

<span class="fc bfc" id="L873" title="All 2 branches covered.">		if (member != null) {</span>
<span class="fc" id="L874">			sb.append(&quot; Member=&quot;);</span>
<span class="fc" id="L875">			sb.append(member.getUniqueName());</span>
		}

<span class="fc" id="L878">		return sb.toString();</span>
	}

	/**
	 * @param quax
	 * @param changedByNavigator
	 */
	protected void onQuaxChanged(Quax quax, boolean changedByNavigator) {
		// if the axis to sort (normaly *not* the measures)
		// was changed by the Navi GUI, we want to switch sorting off
<span class="pc bpc" id="L888" title="5 of 6 branches missed.">		if (changedByNavigator &amp;&amp; model.isSorting() &amp;&amp; quax == getQuaxToSort()) {</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L890">				logger.debug(&quot;Quax changed by navi - switch sorting off&quot;);</span>
			}

<span class="nc" id="L893">			model.setSorting(false);</span>
		}

<span class="fc" id="L896">		fireQueryChanged();</span>
<span class="fc" id="L897">	}</span>

	/**
	 * @see com.eyeq.pivot4j.StateHolder#bookmarkState()
	 */
	public Serializable bookmarkState() {
<span class="nc" id="L903">		Serializable[] state = new Serializable[4];</span>

<span class="nc" id="L905">		state[0] = isAxesSwapped();</span>
<span class="nc" id="L906">		state[1] = getUseQuax();</span>

<span class="nc" id="L908">		Quax quaxToSort = getQuaxToSort();</span>

<span class="nc bnc" id="L910" title="All 2 branches missed.">		if (quaxToSort == null) {</span>
<span class="nc" id="L911">			state[2] = -1;</span>
		} else {
<span class="nc" id="L913">			state[2] = quaxToSort.getOrdinal();</span>
		}

<span class="nc bnc" id="L916" title="All 2 branches missed.">		if (getUseQuax()) {</span>
<span class="nc" id="L917">			List&lt;Quax&gt; quaxes = getQuaxes();</span>

<span class="nc" id="L919">			Serializable[] quaxStates = new Serializable[quaxes.size()];</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">			for (int i = 0; i &lt; quaxStates.length; i++) {</span>
<span class="nc" id="L921">				quaxStates[i] = quaxes.get(i).bookmarkState();</span>
			}

<span class="nc" id="L924">			state[3] = quaxStates;</span>
		} else {
<span class="nc" id="L926">			state[3] = null;</span>
		}

<span class="nc" id="L929">		return state;</span>
	}

	/**
	 * @see com.eyeq.pivot4j.StateHolder#restoreState(java.io.Serializable)
	 */
	public void restoreState(Serializable state) {
<span class="nc" id="L936">		Serializable[] states = (Serializable[]) state;</span>

<span class="nc" id="L938">		this.axesSwapped = (Boolean) states[0];</span>
<span class="nc" id="L939">		this.useQuax = (Boolean) states[1];</span>

<span class="nc" id="L941">		int quaxOrdinal = (Integer) states[2];</span>

<span class="nc" id="L943">		Quax quaxToSort = null;</span>

<span class="nc bnc" id="L945" title="All 2 branches missed.">		if (quaxOrdinal &gt; -1) {</span>
<span class="nc" id="L946">			List&lt;Quax&gt; quaxes = getQuaxes();</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">			for (Quax quax : quaxes) {</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">				if (quaxOrdinal == quax.getOrdinal()) {</span>
<span class="nc" id="L949">					quaxToSort = quax;</span>
<span class="nc" id="L950">					break;</span>
				}
			}
		}

<span class="nc" id="L955">		this.quaxToSort = quaxToSort;</span>

<span class="nc bnc" id="L957" title="All 2 branches missed.">		if (useQuax) {</span>
<span class="nc" id="L958">			Serializable[] quaxStates = (Serializable[]) states[3];</span>

			// reset the quaxes to current state
<span class="nc" id="L961">			List&lt;Quax&gt; quaxes = getQuaxes();</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">			if (quaxes.size() != quaxStates.length) {</span>
<span class="nc" id="L963">				throw new IllegalArgumentException(</span>
<span class="nc" id="L964">						&quot;Stored quax state is not compatible with the current MDX.&quot;);</span>
			}

<span class="nc bnc" id="L967" title="All 2 branches missed.">			for (int i = 0; i &lt; quaxStates.length; i++) {</span>
<span class="nc" id="L968">				quaxes.get(i).restoreState(quaxStates[i]);</span>
			}
		}

<span class="nc" id="L972">		fireQueryChanged();</span>
<span class="nc" id="L973">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.10.201208310627</span></div></body></html>