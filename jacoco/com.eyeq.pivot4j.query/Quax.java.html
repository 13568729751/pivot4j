<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Quax.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Pivot4J</a> &gt; <a href="index.html" class="el_package">com.eyeq.pivot4j.query</a> &gt; <span class="el_source">Quax.java</span></div><h1>Quax.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/*</span>
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 */
package com.eyeq.pivot4j.query;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.olap4j.OlapException;
import org.olap4j.Position;
import org.olap4j.mdx.parser.MdxParser;
import org.olap4j.metadata.Dimension;
import org.olap4j.metadata.Hierarchy;
import org.olap4j.metadata.Level;
import org.olap4j.metadata.Member;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.eyeq.pivot4j.PivotException;
import com.eyeq.pivot4j.StateHolder;
import com.eyeq.pivot4j.mdx.Exp;
import com.eyeq.pivot4j.mdx.ParseTreeNodeExp;
import com.eyeq.pivot4j.mdx.SetExp;
import com.eyeq.pivot4j.mdx.Syntax;
import com.eyeq.pivot4j.util.TreeNode;
import com.eyeq.pivot4j.util.TreeNodeCallback;

<span class="fc" id="L39">public class Quax implements StateHolder {</span>

<span class="fc" id="L41">	protected static Logger logger = LoggerFactory.getLogger(Quax.class);</span>

	private MdxParser parser;

	private int nDimension;

	private List&lt;Hierarchy&gt; hiers;

	// currently, we can handle the following Funcalls
	// member.children, member.descendants, level.members
	// other funcalls are &quot;unknown functions&quot;
	private boolean[] containsUF;

	private List&lt;List&lt;Member&gt;&gt; ufMemberLists; // if there are unknonwn functions

	// private UnknownFunction[] unknownFunctions;
<span class="fc" id="L57">	private TreeNode&lt;Exp&gt; posTreeRoot = null; // Position tree used in normal</span>
												// mode

	private int ordinal; // ordinal of query axis, never changed by swap

<span class="fc" id="L62">	private boolean qubonMode = false;</span>

<span class="fc" id="L64">	private boolean hierarchizeNeeded = false;</span>

	// if there are multiple hierarchies on this quax,
	// &quot;nHierExclude&quot; hierarchies (from right to left)
	// will *not* be included to the Hierarchize Function.
	// So MDX like
	// Crossjoin(Hierarchize(Dim1.A + Dim1.A.Children), {Measures.A.
	// Measures.B})
	// will be generated, so that the Measures are excluded from Hierarchize.
<span class="fc" id="L73">	private int nHierExclude = 0;</span>

<span class="fc" id="L75">	private CalcSetMode generateMode = CalcSetMode.Simple;</span>

<span class="fc" id="L77">	private int generateIndex = -1; // we handle generate for only 1 dimension</span>

<span class="fc" id="L79">	private Object expGenerate = null;</span>

<span class="fc" id="L81">	private Collection&lt;QuaxChangeListener&gt; changeListeners = new ArrayList&lt;QuaxChangeListener&gt;();</span>

<span class="fc" id="L83">	private Map&lt;Member, Boolean&gt; canExpandMemberMap = new HashMap&lt;Member, Boolean&gt;();</span>

<span class="fc" id="L85">	private Map&lt;List&lt;Member&gt;, Boolean&gt; canExpandPosMap = new HashMap&lt;List&lt;Member&gt;, Boolean&gt;();</span>

<span class="fc" id="L87">	private Map&lt;Member, Boolean&gt; canCollapseMemberMap = new HashMap&lt;Member, Boolean&gt;();</span>

<span class="fc" id="L89">	private Map&lt;List&lt;Member&gt;, Boolean&gt; canCollapsePosMap = new HashMap&lt;List&lt;Member&gt;, Boolean&gt;();</span>

	/**
	 * @param ordinal
	 * @param parser
	 */
<span class="fc" id="L95">	public Quax(int ordinal, MdxParser parser) {</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">		if (parser == null) {</span>
<span class="nc" id="L97">			throw new IllegalArgumentException(</span>
<span class="nc" id="L98">					&quot;Missing required argument 'parser'.&quot;);</span>
		}

<span class="fc" id="L101">		this.ordinal = ordinal;</span>
<span class="fc" id="L102">		this.parser = parser;</span>
<span class="fc" id="L103">	}</span>

	/**
	 * @return the parser
	 */
	protected MdxParser getParser() {
<span class="nc" id="L109">		return parser;</span>
	}

	/**
	 * register change listener
	 * 
	 * @param listener
	 */
	public void addChangeListener(QuaxChangeListener listener) {
<span class="fc" id="L118">		changeListeners.add(listener);</span>
<span class="fc" id="L119">	}</span>

	/**
	 * unregister change listener
	 * 
	 * @param listener
	 */
	public void removeChangeListener(QuaxChangeListener listener) {
<span class="nc" id="L127">		changeListeners.remove(listener);</span>
<span class="nc" id="L128">	}</span>

	/**
	 * Handle change
	 * 
	 * @param changedByNavigator
	 *            true if the memberset was changed by the navigator
	 */
	protected void fireQuaxChanged(boolean changedByNavigator) {
<span class="fc" id="L137">		QuaxChangeEvent e = new QuaxChangeEvent(this, changedByNavigator);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">		for (QuaxChangeListener listener : changeListeners) {</span>
<span class="fc" id="L139">			listener.quaxChanged(e);</span>
		}

<span class="fc" id="L142">		canExpandMemberMap.clear();</span>
<span class="fc" id="L143">		canExpandPosMap.clear();</span>
<span class="fc" id="L144">		canCollapseMemberMap.clear();</span>
<span class="fc" id="L145">		canCollapsePosMap.clear();</span>
<span class="fc" id="L146">	}</span>

	/**
	 * Initialize quax from result positions
	 * 
	 * @param positions
	 */
	public void initialize(List&lt;Position&gt; positions) {
		List&lt;List&lt;Member&gt;&gt; posMembers;

<span class="fc" id="L156">		int nDimension = 0;</span>

<span class="fc" id="L158">		this.hierarchizeNeeded = false;</span>
<span class="fc" id="L159">		this.nHierExclude = 0;</span>
<span class="fc" id="L160">		this.qubonMode = true;</span>

<span class="pc bpc" id="L162" title="1 of 2 branches missed.">		if (positions.isEmpty()) {</span>
			// the axis does not have any positions
<span class="nc" id="L164">			posMembers = new ArrayList&lt;List&lt;Member&gt;&gt;(0);</span>
<span class="nc" id="L165">			setHierarchies(new ArrayList&lt;Hierarchy&gt;(0));</span>
<span class="nc" id="L166">			return;</span>
		} else {
<span class="fc" id="L168">			nDimension = positions.get(0).getMembers().size();</span>
<span class="fc" id="L169">			posMembers = new ArrayList&lt;List&lt;Member&gt;&gt;(positions.size());</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">			for (Position position : positions) {</span>
<span class="fc" id="L172">				posMembers.add(new ArrayList&lt;Member&gt;(position.getMembers()));</span>
			}
		}

<span class="fc" id="L176">		List&lt;Hierarchy&gt; hiers = new ArrayList&lt;Hierarchy&gt;(nDimension);</span>

<span class="fc" id="L178">		List&lt;Member&gt; firstMembers = posMembers.get(0);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">		for (Member member : firstMembers) {</span>
<span class="fc" id="L180">			hiers.add(member.getLevel().getHierarchy());</span>
		}

<span class="fc" id="L183">		setHierarchies(hiers);</span>
<span class="fc" id="L184">		initPositions(posMembers);</span>

		// initialize the dimension flags
		// if there is only one set node per dimension,
		// we are in qubon mode
<span class="fc" id="L189">		posTreeRoot.walkTree(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback check qubon mode
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L195">				int iDim = node.getLevel();</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">				if (iDim == Quax.this.nDimension) {</span>
<span class="fc" id="L198">					return TreeNodeCallback.BREAK; // bottom reached</span>
				}

<span class="fc bfc" id="L201" title="All 2 branches covered.">				if (node.getChildren().size() == 1) {</span>
<span class="fc" id="L202">					return TreeNodeCallback.CONTINUE; // continue next level</span>
				} else {
					// more than one child - break out
<span class="fc" id="L205">					Quax.this.qubonMode = false;</span>
<span class="fc" id="L206">					return TreeNodeCallback.BREAK;</span>
				}
			}
		});

<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (qubonMode) {</span>
<span class="fc" id="L212">			nHierExclude = nDimension - 1; // nothing hierarchized</span>
		}
<span class="fc" id="L214">	}</span>

	/**
	 * Initialize position member list after first result gotten
	 * 
	 * @param posMemStart
	 */
	private void initPositions(List&lt;List&lt;Member&gt;&gt; posMemStart) {
		// no positions - no tree
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">		if (posMemStart.isEmpty()) {</span>
<span class="nc" id="L224">			this.posTreeRoot = null;</span>
<span class="nc" id="L225">			return;</span>
		}

		// before the position tree is created,
		// we want to hierarchize
		/*
		 * if (nDimension &gt; 1) hierarchizePositions(aPosMemStart);
		 */

		// init position tree
<span class="fc" id="L235">		this.posTreeRoot = new TreeNode&lt;Exp&gt;(null); // root</span>
<span class="fc" id="L236">		int end = addToPosTree(posMemStart, 0, posMemStart.size(), 0,</span>
<span class="fc" id="L237">				posTreeRoot);</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">		while (end &lt; posMemStart.size()) {</span>
<span class="fc" id="L239">			end = addToPosTree(posMemStart, end, posMemStart.size(), 0,</span>
<span class="fc" id="L240">					posTreeRoot);</span>
		}

		// try to factor out the members of the last dimension
<span class="fc" id="L244">		posTreeRoot.walkTree(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback create member set for last dimension
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L250">				int dimIndex = node.getLevel();</span>

<span class="fc bfc" id="L252" title="All 2 branches covered.">				if (dimIndex == Quax.this.nDimension - 1) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">					if (node.getChildren().size() &lt;= 1) {</span>
<span class="fc" id="L254">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					}
					// continue
					// next
					// sibling
					// more than one child in last dimension
					// create a single set function node
<span class="fc" id="L261">					Exp[] memArray = new Exp[node.getChildren().size()];</span>
<span class="fc" id="L262">					int i = 0;</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">					for (TreeNode&lt;Exp&gt; child : node.getChildren()) {</span>
<span class="fc" id="L264">						memArray[i++] = child.getReference();</span>
					}

<span class="fc" id="L267">					node.getChildren().clear();</span>

<span class="fc" id="L269">					Exp oFun = QuaxUtil.createFunCall(&quot;{}&quot;, memArray,</span>
<span class="fc" id="L270">							Syntax.Braces);</span>

<span class="fc" id="L272">					TreeNode&lt;Exp&gt; newChild = new TreeNode&lt;Exp&gt;(oFun);</span>
<span class="fc" id="L273">					node.addChild(newChild);</span>

<span class="fc" id="L275">					return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
					// sibling
				}
<span class="fc" id="L278">				return TreeNodeCallback.CONTINUE;</span>
			}
		});

<span class="fc" id="L282">		this.containsUF = new boolean[nDimension]; // init false</span>
<span class="fc" id="L283">		this.ufMemberLists = new ArrayList&lt;List&lt;Member&gt;&gt;(nDimension);</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">		for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="fc" id="L286">			ufMemberLists.add(null);</span>
		}

<span class="pc bpc" id="L289" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L290">			logger.debug(&quot;after initPositions &quot; + this.toString());</span>
		}
<span class="fc" id="L292">	}</span>

	/**
	 * add members of dimension to tree recursively
	 * 
	 * @param posMembers
	 *            positon member array
	 * @param startIndex
	 *            start position for this dimension
	 * @param endIndex
	 *            end position for this dimension
	 * @param dimIndex
	 *            index of this dimension
	 * @param parentNode
	 *            parent node (previous dimension)
	 * @return index of position where the member of this dimension changes
	 */
	protected int addToPosTree(List&lt;List&lt;Member&gt;&gt; posMembers, int startIndex,
			int endIndex, int dimIndex, TreeNode&lt;Exp&gt; parentNode) {
<span class="fc" id="L311">		Member currentOfDim = posMembers.get(startIndex).get(dimIndex);</span>

<span class="fc" id="L313">		Exp exp = QuaxUtil.expForMember(currentOfDim);</span>
<span class="fc" id="L314">		TreeNode&lt;Exp&gt; newNode = new TreeNode&lt;Exp&gt;(exp);</span>
<span class="fc" id="L315">		parentNode.addChild(newNode);</span>

		// check range where member of this dimension is constant
<span class="fc" id="L318">		int endRange = startIndex + 1;</span>
<span class="pc bfc" id="L319" title="All 2 branches covered.">		for (; endRange &lt; endIndex; endRange++) {</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">			if (!posMembers.get(endRange).get(dimIndex).equals(currentOfDim)) {</span>
<span class="fc" id="L321">				break;</span>
			}
		}

<span class="fc" id="L325">		int nextDim = dimIndex + 1;</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">		if (nextDim &lt; nDimension) {</span>
<span class="fc" id="L327">			int endChild = addToPosTree(posMembers, startIndex, endRange,</span>
<span class="fc" id="L328">					nextDim, newNode);</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">			while (endChild &lt; endRange) {</span>
<span class="nc" id="L330">				endChild = addToPosTree(posMembers, endChild, endRange,</span>
<span class="nc" id="L331">						nextDim, newNode);</span>
			}
		}

<span class="fc" id="L335">		return endRange;</span>
	}

	/**
	 * @return
	 */
	public int getNDimension() {
<span class="fc" id="L342">		return nDimension;</span>
	}

	/**
	 * @return posTreeRoot
	 */
	public TreeNode&lt;Exp&gt; getPosTreeRoot() {
<span class="nc" id="L349">		return posTreeRoot;</span>
	}

	/**
	 * @param posTreeRoot
	 * @param hiersChanged
	 */
	public void setPosTreeRoot(TreeNode&lt;Exp&gt; posTreeRoot, boolean hiersChanged) {
<span class="nc" id="L357">		this.posTreeRoot = posTreeRoot;</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">		if (hiersChanged) {</span>
			// count dimensions, set hierarchies
<span class="nc" id="L361">			TreeNode&lt;Exp&gt; firstNode = posTreeRoot;</span>

<span class="nc" id="L363">			List&lt;Hierarchy&gt; hiersList = new ArrayList&lt;Hierarchy&gt;();</span>
<span class="nc" id="L364">			List&lt;TreeNode&lt;Exp&gt;&gt; children = firstNode.getChildren();</span>

<span class="nc bnc" id="L366" title="All 2 branches missed.">			while (children.size() &gt; 0) {</span>
<span class="nc" id="L367">				firstNode = children.get(0);</span>
<span class="nc" id="L368">				Exp oExp = firstNode.getReference();</span>

				Hierarchy hier;
				try {
<span class="nc" id="L372">					hier = QuaxUtil.hierForExp(oExp);</span>
<span class="nc" id="L373">				} catch (UnknownExpressionException e) {</span>
<span class="nc" id="L374">					throw new PivotException(</span>
<span class="nc" id="L375">							&quot;Could not determine Hierarchy for set : &quot;</span>
<span class="nc" id="L376">									+ e.getExpression());</span>
				}

<span class="nc" id="L379">				hiersList.add(hier);</span>

<span class="nc" id="L381">				++nDimension;</span>
<span class="nc" id="L382">				children = firstNode.getChildren();</span>
			}

<span class="nc" id="L385">			hiers = hiersList;</span>

<span class="nc" id="L387">			nDimension = hiers.size();</span>

<span class="nc" id="L389">			containsUF = new boolean[nDimension]; // init false</span>
<span class="nc" id="L390">			ufMemberLists = new ArrayList&lt;List&lt;Member&gt;&gt;(nDimension);</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">			for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="nc" id="L393">				ufMemberLists.add(null);</span>
			}

			// go through nodes and check for Unknown functions
			// only one unknown function is possible in one hierarchy
<span class="nc" id="L398">			posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

				/**
				 * callback find unknown functions
				 */
				public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L404">					int nodeIndex = node.getLevel() - 1;</span>

<span class="nc" id="L406">					Exp oExp = node.getReference();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">					if (!QuaxUtil.canHandle(oExp)) {</span>
						// indicate that dimension i contains an unknown
						// function,
						// which cannot be handled in some cases.
						// this will cause the member list of this dimension to
						// be stored
<span class="nc" id="L413">						containsUF[nodeIndex] = true;</span>
					}

<span class="nc" id="L416">					return TreeNodeCallback.CONTINUE;</span>
				}
			});
		}
<span class="nc" id="L420">	}</span>

	public int getGenerateIndex() {
<span class="nc" id="L423">		return generateIndex;</span>
	}

	public void setGenerateIndex(int i) {
<span class="nc" id="L427">		this.generateIndex = i;</span>
<span class="nc" id="L428">	}</span>

	public CalcSetMode getGenerateMode() {
<span class="fc" id="L431">		return generateMode;</span>
	}

	public void setGenerateMode(CalcSetMode mode) {
<span class="nc" id="L435">		this.generateMode = mode;</span>
<span class="nc" id="L436">	}</span>

	/**
	 * reset generate &quot;topcount&quot;
	 */
	public void resetGenerate() {
<span class="nc" id="L442">		this.generateMode = CalcSetMode.Simple;</span>
<span class="nc" id="L443">		this.generateIndex = -1;</span>
<span class="nc" id="L444">		this.expGenerate = null;</span>
<span class="nc" id="L445">	}</span>

	/**
	 * @return Returns the nHierExclude.
	 */
	public int getNHierExclude() {
<span class="nc" id="L451">		return nHierExclude;</span>
	}

	/**
	 * @param hierExclude
	 *            The nHierExclude to set.
	 */
	public void setNHierExclude(int hierExclude) {
<span class="nc" id="L459">		this.nHierExclude = hierExclude;</span>
<span class="nc" id="L460">	}</span>

	/**
	 * only allow expand/collapse left of a &quot;sticky topcount&quot;
	 */
	private boolean allowNavigate(Member member, boolean qubon) {
<span class="fc" id="L466">		int iDim = dimIdx(member.getDimension());</span>
<span class="fc" id="L467">		return allowNavigate(iDim, qubon);</span>
	}

	/**
	 * Only allow expand/collapse left of a &quot;sticky topcount&quot;
	 */
	private boolean allowNavigate(int dimIndex, boolean qubon) {
<span class="pc bpc" id="L474" title="3 of 6 branches missed.">		if (qubon &amp;&amp; generateIndex &gt;= 0 &amp;&amp; generateMode == CalcSetMode.Sticky</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">				&amp;&amp; dimIndex == generateIndex) {</span>
<span class="nc" id="L476">			return false;</span>
<span class="pc bpc" id="L477" title="1 of 4 branches missed.">		} else if (!qubon &amp;&amp; generateIndex &gt;= 0</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">				&amp;&amp; generateMode == CalcSetMode.Sticky</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">				&amp;&amp; dimIndex &gt;= generateIndex) {</span>
<span class="nc" id="L480">			return false;</span>
		} else {
<span class="fc" id="L482">			return true;</span>
		}
	}

	/**
	 * @return
	 */
	public boolean isHierarchizeNeeded() {
<span class="fc" id="L490">		return hierarchizeNeeded;</span>
	}

	/**
	 * @param b
	 */
	public void setHierarchizeNeeded(boolean b) {
<span class="nc" id="L497">		hierarchizeNeeded = b;</span>
<span class="nc" id="L498">	}</span>

	/**
	 * get Ordinal for axis, this is the immutable id of the quax
	 * 
	 * @return ordinal
	 */
	public int getOrdinal() {
<span class="nc" id="L506">		return ordinal;</span>
	}

	/**
	 * @return hierarchies
	 */
	public List&lt;Hierarchy&gt; getHierarchies() {
<span class="nc" id="L513">		return hiers;</span>
	}

	/**
	 * @param hierarchies
	 */
	public void setHierarchies(List&lt;Hierarchy&gt; hierarchies) {
<span class="fc" id="L520">		this.hiers = hierarchies;</span>
<span class="fc" id="L521">		this.nDimension = hierarchies.size();</span>
<span class="fc" id="L522">	}</span>

	/**
	 * @return
	 */
	public boolean isQubonMode() {
<span class="nc" id="L528">		return qubonMode;</span>
	}

	/**
	 * @param qubonMode
	 */
	public void setQubonMode(boolean qubonMode) {
<span class="nc" id="L535">		this.qubonMode = qubonMode;</span>
<span class="nc" id="L536">	}</span>

	/**
	 * Find out, whether axis contains dimension
	 * 
	 * @param dim
	 * @return index of dimension, -1 if not there
	 */
	public int dimIdx(Dimension dim) {
<span class="pc bpc" id="L545" title="2 of 4 branches missed.">		if (hiers == null || hiers.isEmpty()) {</span>
<span class="nc" id="L546">			return -1; // quax was not initialized yet</span>
		}

<span class="fc" id="L549">		int i = 0;</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">		for (Hierarchy hierarchy : hiers) {</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">			if (hierarchy.getDimension().equals(dim)) {</span>
<span class="fc" id="L552">				return i;</span>
			}

<span class="fc" id="L555">			i++;</span>
		}

<span class="fc" id="L558">		return -1;</span>
	}

	/**
	 * Regenerate the position tree as crossjoin between sets
	 * 
	 * @param hiersChanged
	 *            indicates that the hierarchies were changed
	 */
	public void regeneratePosTree(List&lt;Exp&gt; sets, boolean hiersChanged) {
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">		if (hiersChanged) {</span>
<span class="nc" id="L569">			this.nDimension = sets.size();</span>
<span class="nc" id="L570">			this.hiers = new ArrayList&lt;Hierarchy&gt;(nDimension);</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">			for (Exp set : sets) {</span>
				try {
<span class="nc" id="L574">					hiers.add(QuaxUtil.hierForExp(set));</span>
<span class="nc" id="L575">				} catch (UnknownExpressionException e) {</span>
<span class="nc" id="L576">					throw new PivotException(&quot;Unknown expression : &quot;</span>
<span class="nc" id="L577">							+ e.getExpression());</span>
				}
			}

<span class="nc" id="L581">			this.containsUF = new boolean[nDimension]; // init false</span>
<span class="nc" id="L582">			this.ufMemberLists = new ArrayList&lt;List&lt;Member&gt;&gt;(nDimension);</span>

<span class="nc bnc" id="L584" title="All 2 branches missed.">			for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="nc" id="L585">				ufMemberLists.add(null);</span>
			}

<span class="nc" id="L588">			this.generateIndex = 0;</span>
<span class="nc" id="L589">			this.generateMode = CalcSetMode.Simple;</span>
		}

<span class="pc bpc" id="L592" title="1 of 2 branches missed.">		if (posTreeRoot == null) {</span>
<span class="nc" id="L593">			return;</span>
		}

<span class="fc" id="L596">		posTreeRoot.getChildren().clear();</span>

<span class="fc" id="L598">		TreeNode&lt;Exp&gt; current = posTreeRoot;</span>

		// it would be fine, if we could get rid of an existing Hierarchize
		// - but this is not easy to decide.
		// we will not do it, if there is a &quot;children&quot; function call
		// not on the highest Level. This indicates that we have drilled
		// down any member.
<span class="fc" id="L605">		this.nHierExclude = 0;</span>

<span class="fc" id="L607">		int nChildrenFound = 0;</span>
<span class="fc" id="L608">		boolean childrenFound = false;</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">		for (int i = 0; i &lt; nDimension; i++) {</span>
			TreeNode&lt;Exp&gt; newNode;

<span class="fc" id="L612">			Exp set = sets.get(i);</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">			if (set instanceof SetExp) {</span>
<span class="nc" id="L614">				SetExp setx = (SetExp) set;</span>
<span class="nc" id="L615">				newNode = new TreeNode&lt;Exp&gt;(setx.getExpression());</span>

<span class="nc" id="L617">				CalcSetMode mode = setx.getMode();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">				if (mode != CalcSetMode.Simple) {</span>
<span class="nc" id="L619">					this.generateMode = mode;</span>
<span class="nc" id="L620">					this.generateIndex = i;</span>
<span class="nc" id="L621">					this.expGenerate = setx.getExpression();</span>
				}
			} else {
				// can we remove an existing &quot;hierarchize needed&quot;?
<span class="fc" id="L625">				boolean bChildrenFound = findChildrenCall(set, 0);</span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">				if (bChildrenFound) {</span>
<span class="nc" id="L627">					childrenFound = true;</span>
<span class="nc" id="L628">					nChildrenFound = i + 1;</span>
				}

<span class="fc" id="L631">				newNode = new TreeNode&lt;Exp&gt;(set);</span>
<span class="pc bpc" id="L632" title="3 of 4 branches missed.">				if (generateIndex == i &amp;&amp; generateMode == CalcSetMode.Sticky) {</span>
					// there was a sticky generate on this hier
					// reset, if set expression is different now
<span class="nc bnc" id="L635" title="All 2 branches missed.">					if (!set.equals(expGenerate)) {</span>
<span class="nc" id="L636">						resetGenerate();</span>
					}
				}
			}
<span class="fc" id="L640">			current.addChild(newNode);</span>
<span class="fc" id="L641">			current = newNode;</span>

<span class="pc bpc" id="L643" title="1 of 2 branches missed.">			if (!QuaxUtil.canHandle(newNode.getReference())) {</span>
				// indicate that dimension i contains an unknown function,
				// which cannot be handled in some cases.
				// this will cause the member list of this dimension to be
				// stored
<span class="nc" id="L648">				containsUF[i] = true;</span>
			}
		}

<span class="fc" id="L652">		this.qubonMode = true;</span>
<span class="fc" id="L653">		this.nHierExclude = nDimension - nChildrenFound;</span>

<span class="pc bpc" id="L655" title="1 of 2 branches missed.">		if (!childrenFound) {</span>
<span class="fc" id="L656">			this.hierarchizeNeeded = false;</span>
		}
<span class="fc" id="L658">	}</span>

	/**
	 * Recursively find &quot;children&quot; Funcall
	 */
	private boolean findChildrenCall(Exp oExp, int level) {
<span class="fc bfc" id="L664" title="All 2 branches covered.">		if (!QuaxUtil.isFunCall(oExp))</span>
<span class="fc" id="L665">			return false; // member or level or ...</span>
<span class="pc bpc" id="L666" title="3 of 4 branches missed.">		if (level &gt; 0 &amp;&amp; QuaxUtil.isFunCallTo(oExp, &quot;children&quot;)) {</span>
<span class="nc" id="L667">			return true;</span>
		}

<span class="fc" id="L670">		int argCount = QuaxUtil.funCallArgCount(oExp);</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">		for (int i = 0; i &lt; argCount; i++) {</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">			if (findChildrenCall(QuaxUtil.funCallArg(oExp, i), level + 1)) {</span>
<span class="nc" id="L673">				return true;</span>
			}
		}

<span class="fc" id="L677">		return false;</span>
	}

	/**
	 * Check, whether a member in a specific position path can be expanded
	 * 
	 * @param memberPath
	 *            position path to be expanded
	 */
	public boolean canExpand(List&lt;Member&gt; memberPath) {
<span class="fc" id="L687">		int dimIndex = memberPath.size() - 1;</span>

		// we only allow expand / collapse for a dimension
		// left of a &quot;sticky topcount&quot;
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">		if (!allowNavigate(dimIndex, false)) {</span>
<span class="nc" id="L692">			return false;</span>
		}

		// first check the cache
<span class="fc bfc" id="L696" title="All 2 branches covered.">		if (canExpandPosMap.containsKey(memberPath)) {</span>
<span class="fc" id="L697">			Boolean bCanExpand = (Boolean) canExpandPosMap.get(memberPath);</span>
<span class="fc" id="L698">			return bCanExpand.booleanValue();</span>
		}

		// loop over Position Tree
		// reject expansion, if the axis already contains child-positions
<span class="fc" id="L703">		boolean childFound = checkChildPosition(memberPath);</span>

		// cache the result
<span class="fc bfc" id="L706" title="All 2 branches covered.">		Boolean bool = new Boolean(!childFound);</span>
<span class="fc" id="L707">		canExpandPosMap.put(memberPath, bool);</span>

<span class="fc bfc" id="L709" title="All 2 branches covered.">		return !childFound;</span>
	}

	/**
	 * Expand position path
	 * 
	 * @param memberPath
	 */
	public void expand(List&lt;Member&gt; memberPath) {
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">		if (qubonMode) {</span>
<span class="nc" id="L719">			resolveUnions();</span>

<span class="nc bnc" id="L721" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L722">				logger.debug(&quot;Expand after resolveUnions &quot; + this.toString());</span>
			}
		}

<span class="fc" id="L726">		int dimIndex = memberPath.size() - 1;</span>

		// update the position member tree
		// assume mPath = (Product.Drink,Time.2003,Customers.USA)
		// 1. find the node N1 for (Product.Drink,Time.2003)
		// 2. add the child node Customers.USA.Children to the node N1
		//
		// if the node N1 for (Product.Drink,Time.2003) was not found:
		// we look for a matching node and find for instance
		// node N2 = (Product.AllProducts.Children,Time.2003)
		// here, we cannot append Customers.USA.Children as a child node.
		// we add a new branch
		// (Product.Drink,Time.2003,Customers.USA.Children) to the tree.

<span class="fc" id="L740">		TreeNode&lt;Exp&gt; bestNode = findBestNode(memberPath);</span>
<span class="fc" id="L741">		int bestNodeIndex = bestNode.getLevel() - 1;</span>

		// add branch at startNode
		// example
		// dimensions: Product,MaritalStatus,Gender,Customer
		// mPath to Drill Down = (Product.AllProducts, MaritalStatus.M,
		// Gender.AllGender)
		// MaritalStatus.AllMaritalStatus was drilled down so best match is
		// (Product.AllProducts)
		// add the branch from MaritalStatus to this node giving
		// (Product.AllProducts,MaritalStatus.M,Gender.AllGender.children)
		// for the Customer Dimension, add all nodes matching
		// (Product.AllProducts, MaritalStatus.M, Gender.AllGender, * )

		List&lt;TreeNode&lt;Exp&gt;&gt; tailNodeList;
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">		if (memberPath.size() &lt; nDimension) {</span>
<span class="nc" id="L757">			tailNodeList = collectTailNodes(posTreeRoot, memberPath);</span>
		} else {
<span class="fc" id="L759">			tailNodeList = Collections.emptyList();</span>
		}

		TreeNode&lt;Exp&gt; newNode;

<span class="fc" id="L764">		Exp oMember = QuaxUtil.expForMember(memberPath.get(dimIndex));</span>
<span class="fc" id="L765">		Exp fChildren = QuaxUtil.createFunCall(&quot;Children&quot;,</span>
<span class="fc" id="L766">				new Exp[] { oMember }, Syntax.Property);</span>

<span class="fc" id="L768">		TreeNode&lt;Exp&gt; parent = bestNode;</span>

		// if bestNode is matching mPath[iDim]
		// we will add the children Funcall to its parent
		// otherwise create path from bestNode to mPath[iDim-1] and
		// add the children FunCall there
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">		if (bestNodeIndex == dimIndex) {</span>
<span class="fc" id="L775">			parent = bestNode.getParent();</span>
		} else {
<span class="nc bnc" id="L777" title="All 2 branches missed.">			for (int i = bestNodeIndex + 1; i &lt; memberPath.size() - 1; i++) {</span>
<span class="nc" id="L778">				oMember = QuaxUtil.expForMember(memberPath.get(i));</span>
<span class="nc" id="L779">				newNode = new TreeNode&lt;Exp&gt;(oMember);</span>

<span class="nc" id="L781">				parent.addChild(newNode);</span>
<span class="nc" id="L782">				parent = newNode;</span>
			}
		}

		// any dimension left and including iDim will *not* be excluded from
		// hierarchize
<span class="fc" id="L788">		int n = nDimension - dimIndex - 1;</span>
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">		if (n &lt; nHierExclude) {</span>
<span class="nc" id="L790">			this.nHierExclude = n;</span>
		}

<span class="fc" id="L793">		newNode = new TreeNode&lt;Exp&gt;(fChildren);</span>
<span class="fc" id="L794">		parent.addChild(newNode);</span>

<span class="pc bpc" id="L796" title="1 of 2 branches missed.">		if (memberPath.size() &lt; nDimension) {</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">			for (TreeNode&lt;Exp&gt; tailNode : tailNodeList) {</span>
<span class="nc" id="L798">				newNode.addChild(tailNode.deepCopy());</span>
			}
		}

<span class="pc bpc" id="L802" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L803">			logger.debug(&quot;After expand &quot; + this.toString());</span>
		}

<span class="fc" id="L806">		this.qubonMode = false;</span>
<span class="fc" id="L807">		this.hierarchizeNeeded = true;</span>

<span class="fc" id="L809">		fireQuaxChanged(false);</span>
<span class="fc" id="L810">	}</span>

	/**
	 * Check, whether a member can be expanded
	 * 
	 * @param member
	 *            member to be expanded
	 */
	public boolean canExpand(Member member) {
		// we only allow expand / collapse for a dimension
		// left of a &quot;sticky topcount&quot;
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">		if (!allowNavigate(member, false)) {</span>
<span class="nc" id="L822">			return false;</span>
		}

		// first check the cache
<span class="fc bfc" id="L826" title="All 2 branches covered.">		if (canExpandMemberMap.containsKey(member)) {</span>
<span class="fc" id="L827">			boolean canExpand = canExpandMemberMap.get(member);</span>
<span class="fc" id="L828">			return canExpand;</span>
		}

		// loop over Position Tree
		// reject expansion, if the axis already contains children of member
<span class="fc bfc" id="L833" title="All 2 branches covered.">		boolean found = !findMemberChild(member);</span>

		// cache the result
<span class="fc" id="L836">		canExpandMemberMap.put(member, found);</span>

<span class="fc" id="L838">		return found;</span>
	}

	/**
	 * Expand member all over position tree
	 * 
	 * @param member
	 */
	public void expand(final Member member) {
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">		if (qubonMode) {</span>
<span class="nc" id="L848">			resolveUnions();</span>

<span class="nc bnc" id="L850" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L851">				logger.debug(&quot;Expand after resolveUnions &quot; + this.toString());</span>
			}
		}

		// old stuff, always hierarchize everything
<span class="fc" id="L856">		this.nHierExclude = 0;</span>

<span class="fc" id="L858">		final int dimIndex = this.dimIdx(member.getDimension());</span>
<span class="fc" id="L859">		final List&lt;TreeNode&lt;Exp&gt;&gt; nodesForMember = new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;();</span>

		// update the position member tree
		// wherever we find monMember, expand it
		// collect all nodes for monMember in workList
<span class="fc" id="L864">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching member Path exactly
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L870">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="fc" id="L872">					return TreeNodeCallback.CONTINUE; // we are below iDim,</span>
					// don't care
				}

				// iDimNode == iDim
				// node Exp must contain children of member[iDim]
<span class="fc" id="L878">				Exp oExp = node.getReference();</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">				if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">					if (QuaxUtil.equalMember(oExp, member)) {</span>
<span class="fc" id="L881">						nodesForMember.add(node);</span>
					}
				} else {
					// must be FunCall
<span class="nc bnc" id="L885" title="All 2 branches missed.">					if (isMemberInFunCall(oExp, member, dimIndex)) {</span>
<span class="nc" id="L886">						nodesForMember.add(node);</span>
					}
				}

<span class="fc" id="L890">				return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
				// sibling
			}
		});

		// add children of member to each node in list
<span class="fc" id="L896">		Exp oMember = QuaxUtil.expForMember(member);</span>
<span class="fc" id="L897">		Exp fChildren = QuaxUtil.createFunCall(&quot;Children&quot;,</span>
<span class="fc" id="L898">				new Exp[] { oMember }, Syntax.Property);</span>

<span class="fc bfc" id="L900" title="All 2 branches covered.">		for (TreeNode&lt;Exp&gt; node : nodesForMember) {</span>
<span class="fc" id="L901">			TreeNode&lt;Exp&gt; newNode = new TreeNode&lt;Exp&gt;(fChildren);</span>

<span class="pc bpc" id="L903" title="1 of 2 branches missed.">			for (TreeNode&lt;Exp&gt; child : node.getChildren()) {</span>
<span class="nc" id="L904">				newNode.addChild(child.deepCopy());</span>
			}

<span class="fc" id="L907">			TreeNode&lt;Exp&gt; parent = node.getParent();</span>
<span class="fc" id="L908">			parent.addChild(newNode);</span>
		}

<span class="pc bpc" id="L911" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L912">			logger.debug(&quot;After expand member &quot; + this.toString());</span>
		}

<span class="fc" id="L915">		this.hierarchizeNeeded = true;</span>

<span class="fc" id="L917">		fireQuaxChanged(false);</span>
<span class="fc" id="L918">	}</span>

	/**
	 * Check, whether a member path can be collapsed this is true if there is a
	 * child position path
	 * 
	 * @param memberPath
	 *            position path to be collapsed
	 */
	public boolean canCollapse(List&lt;Member&gt; memberPath) {
<span class="fc" id="L928">		int dimIndex = memberPath.size() - 1;</span>

		// we only allow expand / collapse for a dimension
		// left of a &quot;sticky topcount&quot;
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">		if (!allowNavigate(dimIndex, false)) {</span>
<span class="nc" id="L933">			return false;</span>
		}

		// first check the cache
<span class="fc bfc" id="L937" title="All 2 branches covered.">		if (canCollapsePosMap.containsKey(memberPath)) {</span>
<span class="fc" id="L938">			boolean canCollapse = canCollapsePosMap.get(memberPath);</span>
<span class="fc" id="L939">			return canCollapse;</span>
		}

		// loop over Position Tree
		// collapse is possible, if the axis already contains child-positions
<span class="fc" id="L944">		boolean childFound = checkChildPosition(memberPath);</span>

		// cache the result
<span class="fc" id="L947">		canCollapsePosMap.put(memberPath, childFound);</span>

<span class="fc" id="L949">		return childFound;</span>
	}

	/**
	 * Remove child positions of mPath from position tree
	 * 
	 * @param memberPath
	 *            member path to be collapsed
	 */
	public void collapse(final List&lt;Member&gt; memberPath) {
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">		if (qubonMode) {</span>
<span class="nc" id="L960">			resolveUnions();</span>

<span class="nc bnc" id="L962" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L963">				logger.debug(&quot;Collapse after resolveUnions &quot; + this.toString());</span>
			}
		}

<span class="fc" id="L967">		final int dimIndex = memberPath.size() - 1;</span>

<span class="fc" id="L969">		int pathSize = memberPath.size();</span>

		// determine FunCall nodes to be split
<span class="fc" id="L972">		final List&lt;List&lt;TreeNode&lt;Exp&gt;&gt;&gt; splitLists = new ArrayList&lt;List&lt;TreeNode&lt;Exp&gt;&gt;&gt;(</span>
<span class="fc" id="L973">				pathSize);</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">		for (int i = 0; i &lt; pathSize; i++) {</span>
<span class="fc" id="L975">			splitLists.add(new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;());</span>
		}

<span class="fc" id="L978">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback Find child paths of member path. Collect FunCall nodes
			 * above in List. We have a list for any dimension, so that we can
			 * avoid dependency conflicts when we split the FunCalls.
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
				// check, whether this node matches mPath
<span class="fc" id="L987">				Exp oExp = node.getReference();</span>

<span class="fc" id="L989">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L990" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">					if (QuaxUtil.isMember(oExp)) {</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">						if (QuaxUtil.equalMember(oExp,</span>
<span class="fc" id="L993">								memberPath.get(nodeIndex))) {</span>
<span class="fc" id="L994">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="fc" id="L996">							return TreeNodeCallback.CONTINUE_SIBLING;</span>
						}
					} else {
						// Funcall
<span class="nc bnc" id="L1000" title="All 2 branches missed.">						if (isMemberInFunCall(oExp, memberPath.get(nodeIndex),</span>
<span class="nc" id="L1001">								nodeIndex)) {</span>
<span class="nc" id="L1002">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="nc" id="L1004">							return TreeNodeCallback.CONTINUE_SIBLING;</span>
						}
					}
				}
				// idi == iDim
				// oExp *must* be descendant of mPath[iDim] to get deleted
<span class="fc" id="L1010">				boolean found = false;</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">				if (QuaxUtil.isMember(oExp)) {</span>
					// Member
<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">					if (QuaxUtil.isDescendant(memberPath.get(dimIndex), oExp)) {</span>
<span class="nc" id="L1014">						found = true;</span>
					}
				} else {
					// FunCall
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">					if (isChildOfMemberInFunCall(oExp,</span>
<span class="fc" id="L1019">							memberPath.get(dimIndex), dimIndex)) {</span>
<span class="fc" id="L1020">						found = true;</span>
					}
				}

<span class="fc bfc" id="L1024" title="All 2 branches covered.">				if (found) {</span>
					// add this node and all parent nodes, if they are funcalls,
					// to split list
<span class="fc" id="L1027">					int level = node.getLevel();</span>
<span class="fc" id="L1028">					TreeNode&lt;Exp&gt; currentNode = node;</span>
<span class="fc bfc" id="L1029" title="All 2 branches covered.">					while (level &gt; 0) {</span>
<span class="fc" id="L1030">						Exp o = currentNode.getReference();</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">						if (!QuaxUtil.isMember(o)) {</span>
<span class="fc" id="L1032">							List&lt;TreeNode&lt;Exp&gt;&gt; list = splitLists</span>
<span class="fc" id="L1033">									.get(level - 1);</span>
							// Funcall
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">							if (!list.contains(currentNode)) {</span>
<span class="fc" id="L1036">								list.add(currentNode);</span>
							}
						}
<span class="fc" id="L1039">						currentNode = currentNode.getParent();</span>
<span class="fc" id="L1040">						level = currentNode.getLevel();</span>
					}
				}
<span class="fc" id="L1043">				return TreeNodeCallback.CONTINUE_SIBLING;</span>
			} // handleTreeNode
		});

		// split all FunCall nodes collected in worklist
		// start with higher levels to avoid dependency conflicts
<span class="fc bfc" id="L1049" title="All 2 branches covered.">		for (int i = pathSize - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1050">			List&lt;TreeNode&lt;Exp&gt;&gt; list = splitLists.get(i);</span>
<span class="fc" id="L1051">			Member member = memberPath.get(i);</span>
<span class="fc bfc" id="L1052" title="All 2 branches covered.">			for (TreeNode&lt;Exp&gt; node : list) {</span>
<span class="fc" id="L1053">				splitFunCall(node, member, i);</span>
			}
		}

		// remove child Paths of mPath from position tree
		// collect nodes to be deleted
<span class="fc" id="L1059">		final List&lt;TreeNode&lt;Exp&gt;&gt; removeList = new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;();</span>

<span class="fc" id="L1061">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>
			/**
			 * callback remove child nodes of member path, first collect nodes
			 * in workList
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
				// check, whether this node matches mPath
<span class="fc" id="L1068">				Exp oExp = node.getReference();</span>
<span class="fc" id="L1069">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L1070" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">					if (QuaxUtil.isMember(oExp)) {</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">						if (QuaxUtil.equalMember(oExp,</span>
<span class="fc" id="L1073">								memberPath.get(nodeIndex))) {</span>
<span class="fc" id="L1074">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="fc" id="L1076">							return TreeNodeCallback.CONTINUE_SIBLING;</span>
						}
					} else {
						// FunCall
						// cannot match as we just did the split of FunCalls
<span class="nc" id="L1081">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					}
<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">				} else if (nodeIndex == dimIndex) {</span>
					// *must* be descendant of mPath[iDim] to get deleted
<span class="fc bfc" id="L1085" title="All 2 branches covered.">					if (!QuaxUtil.isMember(oExp)) {</span>
						// FunCall
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">						if (QuaxUtil.isFunCallTo(oExp, &quot;Children&quot;)) {</span>
<span class="fc" id="L1088">							Exp oMember = QuaxUtil.funCallArg(oExp, 0);</span>

<span class="fc" id="L1090">							if (QuaxUtil.expForMember(memberPath.get(dimIndex))</span>
<span class="pc bpc" id="L1091" title="1 of 2 branches missed.">									.equals(oMember)</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">									|| QuaxUtil.isDescendant(</span>
<span class="nc" id="L1093">											memberPath.get(dimIndex), oMember)) {</span>
<span class="fc" id="L1094">								removeList.add(node); // add to delete list</span>
							}
<span class="nc bnc" id="L1096" title="All 2 branches missed.">						} else if (QuaxUtil.isFunCallTo(oExp, &quot;{}&quot;)) {</span>
							// set of members may be there as result of split,
							// we will remove any descendant member from the
							// set.
							// if the set is empty thereafter, we will add the
							// node
							// to the remove list.
<span class="nc" id="L1103">							int argCount = QuaxUtil.funCallArgCount(oExp);</span>
<span class="nc" id="L1104">							List&lt;Exp&gt; removeMembers = new ArrayList&lt;Exp&gt;();</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">							for (int i = 0; i &lt; argCount; i++) {</span>
<span class="nc" id="L1106">								Exp oSetMember = QuaxUtil.funCallArg(oExp, i);</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">								if (QuaxUtil.isDescendant(</span>
<span class="nc" id="L1108">										memberPath.get(dimIndex), oSetMember)) {</span>
<span class="nc" id="L1109">									removeMembers.add(oSetMember);</span>
								}
							}
<span class="nc" id="L1112">							int nRemove = removeMembers.size();</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">							if (nRemove == argCount) {</span>
								// all memers in set are descendants, remove the
								// node
<span class="nc" id="L1116">								removeList.add(node); // add to delete list</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">							} else if (nRemove &gt; 0) {</span>
								// remove descendant nodes from set
<span class="nc" id="L1119">								Exp[] remaining = new Exp[argCount - nRemove];</span>
<span class="nc" id="L1120">								int j = 0;</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">								for (int i = 0; i &lt; argCount; i++) {</span>
<span class="nc" id="L1122">									Exp oSetMember = QuaxUtil.funCallArg(oExp,</span>
<span class="nc" id="L1123">											i);</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">									if (!removeMembers.contains(oSetMember)) {</span>
<span class="nc" id="L1125">										remaining[j++] = oSetMember;</span>
									}
								}

<span class="nc bnc" id="L1129" title="All 2 branches missed.">								if (remaining.length == 1) {</span>
<span class="nc" id="L1130">									node.setReference(remaining[0]); // single</span>
									// member
								} else {
<span class="nc" id="L1133">									Exp newSet = QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L1134">											remaining, Syntax.Braces);</span>
<span class="nc" id="L1135">									node.setReference(newSet);</span>
								}
							}
<span class="nc bnc" id="L1138" title="All 2 branches missed.">						} else if (QuaxUtil.isFunCallTo(oExp, &quot;Union&quot;)) {</span>
							// HHTASK Cleanup, always use
							// removeDescendantsFromFunCall
<span class="nc" id="L1141">							Exp oRemain = removeDescendantsFromFunCall(oExp,</span>
<span class="nc" id="L1142">									memberPath.get(dimIndex), dimIndex);</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">							if (oRemain == null) {</span>
<span class="nc" id="L1144">								removeList.add(node);</span>
							} else {
<span class="nc" id="L1146">								node.setReference(oRemain);</span>
							}
						}
<span class="fc" id="L1149">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">					} else if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">						if (QuaxUtil.isDescendant(memberPath.get(dimIndex),</span>
<span class="fc" id="L1152">								oExp)) {</span>
<span class="nc" id="L1153">							removeList.add(node);</span>
						}
					}
<span class="fc" id="L1156">					return TreeNodeCallback.CONTINUE_SIBLING;</span>
					// always break on level iDim, next sibling
				} else {
					// should never get here
<span class="nc" id="L1160">					throw new PivotException(&quot;Unexpected tree node level &quot;</span>
<span class="nc" id="L1161">							+ nodeIndex + &quot; &quot;</span>
<span class="nc" id="L1162">							+ QuaxUtil.memberString(memberPath));</span>
				}
			}
		});

		// remove nodes collected in work list
<span class="fc bfc" id="L1168" title="All 2 branches covered.">		for (TreeNode&lt;Exp&gt; nodeToRemove : removeList) {</span>
<span class="fc" id="L1169">			removePathToNode(nodeToRemove);</span>
		}

		// any dimension left and including iDim will *not* be excluded from
		// hierarchize
<span class="fc" id="L1174">		int n = nDimension - dimIndex - 1;</span>
<span class="pc bpc" id="L1175" title="1 of 2 branches missed.">		if (n &lt; nHierExclude) {</span>
<span class="nc" id="L1176">			this.nHierExclude = n;</span>
		}

<span class="pc bpc" id="L1179" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L1180">			logger.debug(&quot;After collapse &quot; + this.toString());</span>
		}

<span class="fc" id="L1183">		fireQuaxChanged(false);</span>
<span class="fc" id="L1184">	}</span>

	/**
	 * Check, whether a member path can be collapsed this is true if there is a
	 * child position path
	 * 
	 * @param member
	 *            position path to be collapsed
	 */
	public boolean canCollapse(Member member) {
		// we only allow expand / collapse for a dimension
		// left of a &quot;sticky topcount&quot;
<span class="pc bpc" id="L1196" title="1 of 2 branches missed.">		if (!allowNavigate(member, false)) {</span>
<span class="nc" id="L1197">			return false;</span>
		}

		// first check the cache
<span class="pc bpc" id="L1201" title="1 of 2 branches missed.">		if (canCollapseMemberMap.containsKey(member)) {</span>
<span class="nc" id="L1202">			boolean canCollapse = canCollapseMemberMap.get(member);</span>
<span class="nc" id="L1203">			return canCollapse;</span>
		}

		// loop over Position Tree
		// can collapse, if we find a descendant of member
<span class="fc" id="L1208">		boolean found = findMemberChild(member);</span>

		// cache the result
<span class="fc" id="L1211">		canCollapseMemberMap.put(member, found);</span>

<span class="fc" id="L1213">		return found;</span>
	}

	/**
	 * Remove child nodes of monMember
	 * 
	 * @param member
	 *            member to be collapsed
	 */
	public void collapse(final Member member) {
<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">		if (qubonMode) {</span>
<span class="nc" id="L1224">			resolveUnions();</span>

<span class="nc bnc" id="L1226" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1227">				logger.debug(&quot;collapse member after resolveUnions &quot;</span>
<span class="nc" id="L1228">						+ this.toString());</span>
			}
		}

<span class="fc" id="L1232">		final int dimIndex = this.dimIdx(member.getDimension());</span>

<span class="fc" id="L1234">		final List&lt;TreeNode&lt;Exp&gt;&gt; nodesForMember = new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;();</span>

		// update the position member tree
		// wherever we find a descendant node of monMember, split and remove it
		// collect all descendant nodes for monMember in workList
<span class="fc" id="L1239">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching member Path exactly
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1245">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L1246" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="fc" id="L1247">					return TreeNodeCallback.CONTINUE; // we are below iDim,</span>
					// don't care
				}

				// iDimNode == iDim
				// node Exp must contain children of member[iDim]
<span class="fc" id="L1253">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L1254" title="All 2 branches covered.">				if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">					if (QuaxUtil.isDescendant(member, oExp)) {</span>
<span class="nc" id="L1256">						nodesForMember.add(node);</span>
					}
				} else {
					// must be FunCall
<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">					if (isDescendantOfMemberInFunCall(oExp, member, nodeIndex)) {</span>
<span class="fc" id="L1261">						nodesForMember.add(node);</span>
					}
				}
<span class="fc" id="L1264">				return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
				// sibling
			}
		});

<span class="fc bfc" id="L1269" title="All 2 branches covered.">		for (TreeNode&lt;Exp&gt; node : nodesForMember) {</span>
<span class="fc" id="L1270">			Exp oExp = node.getReference();</span>
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">			if (QuaxUtil.isMember(oExp)) {</span>
<span class="nc" id="L1272">				removePathToNode(node);</span>
			} else {
				// FunCall
<span class="fc" id="L1275">				Exp oComplement = removeDescendantsFromFunCall(oExp, member,</span>
<span class="fc" id="L1276">						dimIndex);</span>
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">				if (oComplement == null) {</span>
<span class="fc" id="L1278">					removePathToNode(node);</span>
				} else {
<span class="nc" id="L1280">					node.setReference(oComplement); // replace node object by</span>
													// complement
				}
			}
		}

<span class="pc bpc" id="L1286" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L1287">			logger.debug(&quot;After collapse &quot; + this.toString());</span>
		}

<span class="fc" id="L1290">		fireQuaxChanged(false);</span>
<span class="fc" id="L1291">	}</span>

	/**
	 * drill down is possible if there is no sticky generate
	 */
	public boolean canDrillDown(Member member) {
<span class="fc" id="L1297">		return allowNavigate(member, true);</span>
	}

	/**
	 * Drill down
	 * 
	 * @param member
	 *            drill down member
	 */
	public void drillDown(Member member) {
<span class="fc" id="L1307">		final int dimIndex = this.dimIdx(member.getDimension());</span>

		// collect the Exp's of all dimensions except iDim
<span class="fc" id="L1310">		List&lt;Exp&gt; sets = new ArrayList&lt;Exp&gt;(nDimension);</span>

<span class="fc" id="L1312">		Exp oMember = QuaxUtil.expForMember(member);</span>
<span class="fc" id="L1313">		Exp fChildren = QuaxUtil.createFunCall(&quot;Children&quot;,</span>
<span class="fc" id="L1314">				new Exp[] { oMember }, Syntax.Property);</span>

<span class="fc bfc" id="L1316" title="All 2 branches covered.">		for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">			if (i == dimIndex) {</span>
				// replace drilldown dimension by member.children
<span class="fc" id="L1319">				sets.add(fChildren);</span>
			} else {
				// generate exp for all nodes of this dimension
<span class="fc" id="L1322">				sets.add(genExpForDim(i));</span>
			}
		}

		// regenerate the position tree as crossjoin of sets
<span class="fc" id="L1327">		regeneratePosTree(sets, false);</span>

<span class="fc" id="L1329">		fireQuaxChanged(false);</span>
<span class="fc" id="L1330">	}</span>

	/**
	 * Drill up is possible if at least one member in the tree is not at the top
	 * level of this hierarchy.
	 */
	public boolean canDrillUp(Hierarchy hierarchy) {
<span class="fc" id="L1337">		final int dimIndex = this.dimIdx(hierarchy.getDimension());</span>

<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">		if (!allowNavigate(dimIndex, true)) {</span>
<span class="nc" id="L1340">			return false;</span>
		}

<span class="fc" id="L1343">		int result = posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * Callback check for member of hierarchy not on top level
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1349">				int nodeIndex = node.getLevel() - 1;</span>
<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="nc" id="L1351">					return TreeNodeCallback.CONTINUE;</span>
				}

				// iDimNode == workInt
<span class="fc" id="L1355">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">					if (isFunCallNotTopLevel(oExp, nodeIndex)) {</span>
<span class="fc" id="L1359">						return TreeNodeCallback.BREAK; // got it</span>
					} else {
<span class="nc" id="L1361">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					}
				} else {
					// member
<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">					if (QuaxUtil.levelDepthForMember(oExp) &gt; 0) {</span>
<span class="nc" id="L1366">						return TreeNodeCallback.BREAK; // got it</span>
					} else {
<span class="fc" id="L1368">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					}
				}
			}
		});

<span class="fc bfc" id="L1374" title="All 2 branches covered.">		return (result == TreeNodeCallback.BREAK);</span>
	}

	/**
	 * Drill up
	 * 
	 * @param hierarchy
	 *            drill down member
	 */
	public void drillUp(Hierarchy hierarchy) {
<span class="fc" id="L1384">		int dimIndex = dimIdx(hierarchy.getDimension());</span>

		// collect the Exp's of all dimensions
<span class="fc" id="L1387">		List&lt;Exp&gt; sets = new ArrayList&lt;Exp&gt;(nDimension);</span>

<span class="fc bfc" id="L1389" title="All 2 branches covered.">		for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="fc bfc" id="L1390" title="All 2 branches covered.">			if (i == dimIndex) {</span>
				// replace drillup dimension by drillup set
<span class="fc" id="L1392">				sets.add(drillupExp(dimIndex, hierarchy));</span>
			} else {
<span class="fc" id="L1394">				sets.add(genExpForDim(i));</span>
			}
		}

		// regenerate the position tree as crossjoin of sets
<span class="fc" id="L1399">		regeneratePosTree(sets, false);</span>

<span class="fc" id="L1401">		fireQuaxChanged(false);</span>
<span class="fc" id="L1402">	}</span>

	/**
	 * MDX Generation generate Exp from tree
	 * 
	 * @return Exp for axis set
	 */
	public Exp genExp(boolean genHierarchize) {
<span class="pc bpc" id="L1410" title="3 of 4 branches missed.">		if (generateMode != CalcSetMode.Simple &amp;&amp; generateIndex &gt; 0) {</span>
<span class="nc" id="L1411">			return genGenerateExp(genHierarchize);</span>
		} else {
<span class="fc" id="L1413">			return genNormalExp(genHierarchize);</span>
		}
	}

	/**
	 * Normal MDX Generation - no Generate
	 * 
	 * @return Exp for axis set
	 */
	private Exp genNormalExp(boolean genHierarchize) {
<span class="fc" id="L1423">		ExpGenerator expGenerator = new ExpGenerator();</span>

<span class="fc bfc" id="L1425" title="All 2 branches covered.">		if (!genHierarchize) {</span>
			// no Hierarchize
<span class="fc" id="L1427">			expGenerator.init(posTreeRoot, hiers.size());</span>
<span class="fc" id="L1428">			return expGenerator.generate();</span>
		}

		// do we need a special hierarchize ?
		// this will be true, if nHierExclude &gt; 0
<span class="pc bpc" id="L1433" title="1 of 2 branches missed.">		if (nHierExclude == 0) {</span>
			// no special hierarchize needed
<span class="fc" id="L1435">			expGenerator.init(posTreeRoot, hiers.size());</span>

<span class="fc" id="L1437">			Exp exp = expGenerator.generate();</span>
			// Hierarchize around &quot;everything&quot;
<span class="fc" id="L1439">			return QuaxUtil.createFunCall(&quot;Hierarchize&quot;, new Exp[] { exp },</span>
<span class="fc" id="L1440">					Syntax.Function);</span>
		}

		// special hierarchize to be generated
		// the Qubon Mode Hierarchies are factored out,
		// as they consist only of a single set of members.
		// the left expression will be generated and then hierarchized,
		// *before* beeing crossjoined to the right Expression.
<span class="nc" id="L1448">		return genLeftRight(expGenerator, nDimension - nHierExclude,</span>
<span class="nc" id="L1449">				nHierExclude);</span>
	}

	/**
	 * Generate an expression with hierarchize for the hierarchies &lt;
	 * nHierExclude without hierarchize for the hierarchies &gt;= nHierExclude
	 */
	private Exp genLeftRight(ExpGenerator expGenerator, int leftDepth,
			int rightDepth) {
		// generate left expression to be hierarchized
<span class="nc" id="L1459">		Exp leftExp = null;</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">		if (leftDepth &gt; 0) {</span>
<span class="nc" id="L1461">			TreeNode&lt;Exp&gt; leftRoot = posTreeRoot.deepCopyPrune(leftDepth);</span>
<span class="nc" id="L1462">			leftRoot.setReference(null);</span>

<span class="nc" id="L1464">			List&lt;Hierarchy&gt; leftHiers = new ArrayList&lt;Hierarchy&gt;(leftDepth);</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">			for (int i = 0; i &lt; leftDepth; i++) {</span>
<span class="nc" id="L1466">				leftHiers.add(hiers.get(i));</span>
			}

<span class="nc" id="L1469">			expGenerator.init(leftRoot, leftHiers.size());</span>

<span class="nc" id="L1471">			leftExp = QuaxUtil.createFunCall(&quot;Hierarchize&quot;,</span>
<span class="nc" id="L1472">					new Exp[] { expGenerator.generate() }, Syntax.Function);</span>
		}

		// generate the right expression, not to be hierarchized
<span class="nc" id="L1476">		Exp rightExp = null;</span>

<span class="nc" id="L1478">		List&lt;Hierarchy&gt; rightHiers = new ArrayList&lt;Hierarchy&gt;(rightDepth);</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">		for (int i = 0; i &lt; rightDepth; i++) {</span>
<span class="nc" id="L1480">			rightHiers.add(hiers.get(leftDepth + i));</span>
		}

		// go down to the first hier to be excluded from hierarchize
		// note: the subtree tree under any node of the hierarchy above
		// is always the same, so we can replicate any subtree under
		// a node of hierarchy nLeft-1
<span class="nc" id="L1487">		TreeNode&lt;Exp&gt; rightRoot = new TreeNode&lt;Exp&gt;(null);</span>
<span class="nc" id="L1488">		TreeNode&lt;Exp&gt; current = posTreeRoot;</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">		for (int i = 0; i &lt; leftDepth; i++) {</span>
<span class="nc" id="L1490">			List&lt;TreeNode&lt;Exp&gt;&gt; list = current.getChildren();</span>
<span class="nc" id="L1491">			current = list.get(0);</span>
		}

<span class="nc" id="L1494">		List&lt;TreeNode&lt;Exp&gt;&gt; list = current.getChildren();</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">		for (TreeNode&lt;Exp&gt; node : list) {</span>
<span class="nc" id="L1496">			rightRoot.addChild(node.deepCopy());</span>
		}

<span class="nc" id="L1499">		expGenerator.init(rightRoot, rightHiers.size());</span>

<span class="nc" id="L1501">		rightExp = expGenerator.generate();</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">		if (leftExp == null) {</span>
<span class="nc" id="L1503">			return rightExp;</span>
		}

<span class="nc" id="L1506">		Exp exp = QuaxUtil.createFunCall(&quot;CrossJoin&quot;, new Exp[] { leftExp,</span>
<span class="nc" id="L1507">				rightExp }, Syntax.Function);</span>

<span class="nc" id="L1509">		return exp;</span>
	}

	/**
	 * MDX Generation for Generate
	 * 
	 * @return Exp for axis set
	 */
	private Exp genGenerateExp(boolean genHierarchize) {
<span class="nc" id="L1518">		ExpGenerator expGenerator = new ExpGenerator();</span>

		// Generate(GSet, FSet) to be generated
		// hierarchies &gt;= generateIndex will not be &quot;hierarchized&quot;
		// we expect the hierarchies &gt;= generateIndex to be excluded
		// from hierarchize.
<span class="nc bnc" id="L1524" title="All 4 branches missed.">		if (nDimension - generateIndex &gt; nHierExclude &amp;&amp; logger.isWarnEnabled()) {</span>
<span class="nc" id="L1525">			logger.warn(&quot;Unexpected values: nHierExclude=&quot; + nHierExclude</span>
<span class="nc" id="L1526">					+ &quot; generateIndex=&quot; + generateIndex);</span>
		}

		// assume following situation:
		// 3 hierarchies
		// time - customers - product
		// we want top 5 customers, generated for each time member
		// 1. step
		// generate expression until customers (only time here), result = set1
		// if neccessary, put hierarchize around
		// 2. step
		// Generate(set1, Topcount(Crossjoin ({Time.Currentmember}, Set for
		// Customers),
		// 5, condition))
		// result = set2
		// 3.step
		// append the tail nodes , here Product
		// Crossjoin(set2 , Product dimension nodes)
		//
		// 1. step left expression, potentially hierarchized

<span class="nc" id="L1547">		Exp leftExp = null;</span>
		// if nHierExclude &gt; nDimension - generateIndex
		// and nHierExclude &lt; nDimension
		// the the left expression (inside Generate) will be partly
		// hierarchized
<span class="nc bnc" id="L1552" title="All 4 branches missed.">		if (genHierarchize &amp;&amp; nHierExclude &gt; nDimension - generateIndex</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">				&amp;&amp; nHierExclude &lt; nDimension) {</span>
<span class="nc" id="L1554">			int leftDepth = nDimension - nHierExclude;</span>
<span class="nc" id="L1555">			int rightDepth = generateIndex - leftDepth;</span>

<span class="nc" id="L1557">			leftExp = genLeftRight(expGenerator, leftDepth, rightDepth);</span>
		} else {
<span class="nc" id="L1559">			TreeNode&lt;Exp&gt; leftRoot = posTreeRoot.deepCopyPrune(generateIndex);</span>
<span class="nc" id="L1560">			leftRoot.setReference(null);</span>

<span class="nc" id="L1562">			List&lt;Hierarchy&gt; leftHiers = new ArrayList&lt;Hierarchy&gt;(generateIndex);</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">			for (int i = 0; i &lt; generateIndex; i++) {</span>
<span class="nc" id="L1564">				leftHiers.add(hiers.get(i));</span>
			}

<span class="nc" id="L1567">			expGenerator.init(leftRoot, leftHiers.size());</span>
<span class="nc" id="L1568">			leftExp = expGenerator.generate();</span>

<span class="nc bnc" id="L1570" title="All 2 branches missed.">			if (genHierarchize) {</span>
<span class="nc" id="L1571">				leftExp = QuaxUtil.createFunCall(&quot;Hierarchize&quot;,</span>
<span class="nc" id="L1572">						new Exp[] { leftExp }, Syntax.Function);</span>
			}
		}

		// 2. step Generate(set1, Topcount())
<span class="nc" id="L1577">		TreeNode&lt;Exp&gt; topCountNode = posTreeRoot;</span>
		// top count node can be anything like topcount, bottomcount, filter
<span class="nc bnc" id="L1579" title="All 2 branches missed.">		for (int i = 0; i &lt;= generateIndex; i++) {</span>
			// the path to the topcount node at generateIndex does not matter
<span class="nc" id="L1581">			List&lt;TreeNode&lt;Exp&gt;&gt; children = topCountNode.getChildren();</span>
<span class="nc" id="L1582">			topCountNode = children.get(0);</span>
		}

<span class="nc" id="L1585">		Exp topcount = topCountNode.getReference();</span>
		// we have to replace the &quot;set&quot; of the topcount function
<span class="nc" id="L1587">		Exp origTopcountSet = QuaxUtil.funCallArg(topcount, 0);</span>

		// generate the Tuple of dimension.currentmember until generateIndex
<span class="nc" id="L1590">		Exp currentMembersTuple = genCurrentTuple();</span>
<span class="nc" id="L1591">		Exp ocj = QuaxUtil.createFunCall(&quot;Crossjoin&quot;, new Exp[] {</span>
<span class="nc" id="L1592">				currentMembersTuple, origTopcountSet }, Syntax.Function);</span>

		// replace the topcout original set
<span class="nc" id="L1595">		String fun = QuaxUtil.funCallName(topcount);</span>

<span class="nc" id="L1597">		int n = QuaxUtil.funCallArgCount(topcount);</span>
<span class="nc" id="L1598">		Exp[] args = new Exp[n];</span>
<span class="nc bnc" id="L1599" title="All 2 branches missed.">		for (int i = 1; i &lt; n; i++) {</span>
<span class="nc" id="L1600">			args[i] = QuaxUtil.funCallArg(topcount, i);</span>
		}

<span class="nc" id="L1603">		args[0] = ocj;</span>

<span class="nc" id="L1605">		Exp newTopcount = QuaxUtil.createFunCall(fun, args, Syntax.Function);</span>
<span class="nc" id="L1606">		Exp oGenerate = QuaxUtil.createFunCall(&quot;Generate&quot;, new Exp[] { leftExp,</span>
<span class="nc" id="L1607">				newTopcount }, Syntax.Function);</span>

<span class="nc bnc" id="L1609" title="All 2 branches missed.">		if (generateIndex + 1 == nDimension) {</span>
<span class="nc" id="L1610">			return oGenerate;</span>
		}

		// 3. step append the tail nodes
		// generate CrossJoin
<span class="nc" id="L1615">		int nRight = nDimension - generateIndex - 1;</span>
<span class="nc" id="L1616">		Hierarchy[] rightHiers = new Hierarchy[nRight];</span>
<span class="nc bnc" id="L1617" title="All 2 branches missed.">		for (int i = 1; i &lt;= nRight; i++) {</span>
<span class="nc" id="L1618">			rightHiers[nRight - i] = hiers.get(nDimension - i);</span>
		}

<span class="nc" id="L1621">		TreeNode&lt;Exp&gt; root = new TreeNode&lt;Exp&gt;(null);</span>
<span class="nc" id="L1622">		List&lt;TreeNode&lt;Exp&gt;&gt; list = topCountNode.getChildren();</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">		for (TreeNode&lt;Exp&gt; node : list) {</span>
<span class="nc" id="L1624">			root.addChild(node.deepCopy());</span>
		}

<span class="nc" id="L1627">		expGenerator.init(root, rightHiers.length);</span>
<span class="nc" id="L1628">		Exp rightExp = expGenerator.generate();</span>

<span class="nc" id="L1630">		Exp exp = QuaxUtil.createFunCall(&quot;CrossJoin&quot;, new Exp[] { oGenerate,</span>
<span class="nc" id="L1631">				rightExp }, Syntax.Function);</span>

<span class="nc" id="L1633">		return exp;</span>
	}

	/**
	 * Generate {(dim1.Currentmember, dim2.Currentmember, ... )}
	 */
	private Exp genCurrentTuple() {
<span class="nc" id="L1640">		Exp[] currentsOfDim = new Exp[generateIndex];</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">		for (int i = 0; i &lt; currentsOfDim.length; i++) {</span>
<span class="nc" id="L1642">			Dimension dim = hiers.get(i).getDimension();</span>

<span class="nc" id="L1644">			currentsOfDim[i] = QuaxUtil.createFunCall(&quot;CurrentMember&quot;,</span>
<span class="nc" id="L1645">					new Exp[] { QuaxUtil.expForDim(dim) }, Syntax.Property);</span>
		}

		Exp oTuple;
<span class="nc bnc" id="L1649" title="All 2 branches missed.">		if (generateIndex &gt; 1) {</span>
<span class="nc" id="L1650">			oTuple = QuaxUtil.createFunCall(&quot;()&quot;, currentsOfDim,</span>
<span class="nc" id="L1651">					Syntax.Parentheses);</span>
		} else {
<span class="nc" id="L1653">			oTuple = currentsOfDim[0]; // just dimension.currentmember</span>
		}

		// generate set braces around tuple
<span class="nc" id="L1657">		Exp oSet = QuaxUtil.createFunCall(&quot;{}&quot;, new Exp[] { oTuple },</span>
<span class="nc" id="L1658">				Syntax.Braces);</span>

<span class="nc" id="L1660">		return oSet;</span>
	}

	/**
	 * @return true if child position can be found
	 */
	private boolean checkChildPosition(final List&lt;Member&gt; memberPath) {

<span class="fc" id="L1668">		int result = posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching member Path exactly
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1674">				int dimIndex = memberPath.size() - 1;</span>
<span class="fc" id="L1675">				int nodeIndex = node.getLevel() - 1;</span>

<span class="fc" id="L1677">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L1678" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
					// node Exp must match member[iDim]
<span class="fc bfc" id="L1680" title="All 2 branches covered.">					if (QuaxUtil.isMember(oExp)) {</span>
<span class="fc bfc" id="L1681" title="All 2 branches covered.">						if (QuaxUtil.equalMember(oExp,</span>
<span class="fc" id="L1682">								memberPath.get(nodeIndex))) {</span>
<span class="fc" id="L1683">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="fc" id="L1685">							return TreeNodeCallback.CONTINUE_SIBLING; // continue</span>
							// next
							// sibling
						}
					} else {
						// must be FunCall
<span class="pc bpc" id="L1691" title="1 of 2 branches missed.">						if (isMemberInFunCall(oExp, memberPath.get(nodeIndex),</span>
<span class="fc" id="L1692">								nodeIndex)) {</span>
<span class="fc" id="L1693">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="nc" id="L1695">							return TreeNodeCallback.CONTINUE_SIBLING; // continue</span>
							// next
							// sibling
						}
					}
				}

				// iDimNode == iDim
				// node Exp must contain children of member[iDim]
<span class="fc bfc" id="L1704" title="All 2 branches covered.">				if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L1705" title="1 of 2 branches missed.">					if (QuaxUtil.checkParent(memberPath.get(nodeIndex), oExp)) {</span>
<span class="nc" id="L1706">						return TreeNodeCallback.BREAK; // found</span>
					} else {
<span class="fc" id="L1708">						return TreeNodeCallback.CONTINUE_SIBLING; // continue</span>
						// next
						// sibling
					}
				} else {
					// must be FunCall
<span class="fc bfc" id="L1714" title="All 2 branches covered.">					if (isChildOfMemberInFunCall(oExp,</span>
<span class="fc" id="L1715">							memberPath.get(nodeIndex), nodeIndex)) {</span>
<span class="fc" id="L1716">						return TreeNodeCallback.BREAK; // found</span>
					} else {
<span class="fc" id="L1718">						return TreeNodeCallback.CONTINUE_SIBLING; // continue</span>
						// next
						// sibling
					}
				}
			}
		});

<span class="fc bfc" id="L1726" title="All 2 branches covered.">		return (result == TreeNodeCallback.BREAK);</span>
	}

	/**
	 * Resolve the qubon mode unions and crossjoins only used in &quot;old&quot; expand
	 * mode
	 */
	private void resolveUnions() {
<span class="nc" id="L1734">		final List&lt;List&lt;Exp&gt;&gt; setLists = new ArrayList&lt;List&lt;Exp&gt;&gt;(nDimension);</span>

<span class="nc bnc" id="L1736" title="All 2 branches missed.">		for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="nc" id="L1737">			setLists.add(new ArrayList&lt;Exp&gt;());</span>
		}

<span class="nc" id="L1740">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback resolve sets of any dimension
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L1746">				int nodeIndex = node.getLevel() - 1;</span>
<span class="nc" id="L1747">				Exp oExp = node.getReference();</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall
<span class="nc" id="L1750">					funToList(oExp, setLists.get(nodeIndex));</span>
				} else {
					// member
<span class="nc" id="L1753">					setLists.get(nodeIndex).add(oExp);</span>
				}
<span class="nc" id="L1755">				return TreeNodeCallback.CONTINUE;</span>
			}
		});

		// unions and sets are resolved, now resolve crossjoins
<span class="nc" id="L1760">		this.posTreeRoot = new TreeNode&lt;Exp&gt;(null);</span>
<span class="nc" id="L1761">		crossJoinTree(setLists, posTreeRoot, 0);</span>

<span class="nc" id="L1763">		this.qubonMode = false;</span>
<span class="nc" id="L1764">	}</span>

	/**
	 * Find the best tree node for member path (longest match)
	 */
	private TreeNode&lt;Exp&gt; findBestNode(final List&lt;Member&gt; memberPath) {
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1771">		final TreeNode&lt;Exp&gt;[] bestNode = new TreeNode[1];</span>
<span class="fc" id="L1772">		bestNode[0] = posTreeRoot;</span>

<span class="fc" id="L1774">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching member Path exactly
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1780">				int dimIndex = memberPath.size() - 1;</span>
<span class="fc" id="L1781">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc" id="L1782">				Exp oExp = node.getReference();</span>

<span class="pc bpc" id="L1784" title="1 of 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
<span class="nc" id="L1785">					return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
					// sibling
				}

<span class="pc bpc" id="L1789" title="1 of 2 branches missed.">				if (QuaxUtil.equalMember(oExp, memberPath.get(nodeIndex))) {</span>
					// match
<span class="fc bfc" id="L1791" title="All 2 branches covered.">					if (nodeIndex == dimIndex) {</span>
						// found exactly matching node
<span class="fc" id="L1793">						bestNode[0] = node;</span>
<span class="fc" id="L1794">						return TreeNodeCallback.BREAK;</span>
					} else {
						// best match up to now
<span class="fc" id="L1797">						bestNode[0] = node;</span>
<span class="fc" id="L1798">						return TreeNodeCallback.CONTINUE;</span>
					}
				} else {
					// no match
<span class="nc" id="L1802">					return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
					// sibling
				}
			}
		});

<span class="fc" id="L1808">		return bestNode[0];</span>
	}

	/**
	 * Collect tail nodes for all nodes matching member path
	 */
	private List&lt;TreeNode&lt;Exp&gt;&gt; collectTailNodes(TreeNode&lt;Exp&gt; startNode,
			final List&lt;Member&gt; memberPath) {

<span class="nc" id="L1817">		final List&lt;TreeNode&lt;Exp&gt;&gt; tailNodes = new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;();</span>
<span class="nc" id="L1818">		startNode.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching mPath collect tail nodes
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L1824">				int dimIndex = memberPath.size() - 1;</span>
<span class="nc" id="L1825">				int nodeIndex = node.getLevel() - 1;</span>

<span class="nc" id="L1827">				Exp oExp = node.getReference();</span>
<span class="nc" id="L1828">				boolean match = false;</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">				if (QuaxUtil.isMember(oExp)) {</span>
					// exp is member
<span class="nc bnc" id="L1831" title="All 2 branches missed.">					if (QuaxUtil.equalMember(oExp, memberPath.get(nodeIndex))) {</span>
<span class="nc" id="L1832">						match = true;</span>
					}
				} else {
					// must be FunCall
<span class="nc bnc" id="L1836" title="All 2 branches missed.">					if (isMemberInFunCall(oExp, memberPath.get(nodeIndex),</span>
<span class="nc" id="L1837">							nodeIndex)) {</span>
<span class="nc" id="L1838">						match = true;</span>
					}
				}

<span class="nc bnc" id="L1842" title="All 2 branches missed.">				if (match) {</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">					if (nodeIndex == dimIndex) {</span>
						// add the children to the tail list
<span class="nc" id="L1845">						tailNodes.addAll(node.getChildren());</span>
<span class="nc" id="L1846">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					} else {
						// iDimNode &lt; iDim
<span class="nc" id="L1849">						return TreeNodeCallback.CONTINUE;</span>
					}
				} else
<span class="nc" id="L1852">					return TreeNodeCallback.CONTINUE_SIBLING; // no match,</span>
				// continue next
				// sibling
			}
		});

<span class="nc" id="L1858">		return tailNodes;</span>
	}

	private boolean findMemberChild(final Member member) {
<span class="fc" id="L1862">		final int iDim = this.dimIdx(member.getDimension());</span>

<span class="fc" id="L1864">		int result = posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find child node of member
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1870">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L1871" title="All 2 branches covered.">				if (nodeIndex &lt; iDim) {</span>
<span class="fc" id="L1872">					return TreeNodeCallback.CONTINUE; // we are below iDim,</span>
					// don't care
				}

				// iDimNode == iDim
				// node Exp must contain children of member[iDim]
<span class="fc" id="L1878">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L1879" title="All 2 branches covered.">				if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L1880" title="1 of 2 branches missed.">					if (QuaxUtil.checkParent(member, oExp)) {</span>
<span class="nc" id="L1881">						return TreeNodeCallback.BREAK; // found</span>
					}
				} else {
					// must be FunCall
<span class="pc bpc" id="L1885" title="1 of 2 branches missed.">					if (isChildOfMemberInFunCall(oExp, member, nodeIndex)) {</span>
<span class="fc" id="L1886">						return TreeNodeCallback.BREAK; // found</span>
					}
				}
<span class="fc" id="L1889">				return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
				// sibling
			}
		});

<span class="fc bfc" id="L1894" title="All 2 branches covered.">		return (result == TreeNodeCallback.BREAK);</span>
	}

	/**
	 * Build tree resolving crossjoin
	 * 
	 * @param currentNode
	 * @param dimIndex
	 */
	private void crossJoinTree(List&lt;List&lt;Exp&gt;&gt; setLists,
			TreeNode&lt;Exp&gt; currentNode, int dimIndex) {
<span class="nc bnc" id="L1905" title="All 2 branches missed.">		for (Exp oExp : setLists.get(dimIndex)) {</span>
<span class="nc" id="L1906">			TreeNode&lt;Exp&gt; newNode = new TreeNode&lt;Exp&gt;(oExp);</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">			if (dimIndex &lt; nDimension - 1) {</span>
<span class="nc" id="L1908">				crossJoinTree(setLists, newNode, dimIndex + 1);</span>
			}

<span class="nc" id="L1911">			currentNode.addChild(newNode);</span>
		}
<span class="nc" id="L1913">	}</span>

	/**
	 * Split Funcall to node and complement
	 */
	private void splitFunCall(TreeNode&lt;Exp&gt; funCall, Member member,
			int hierIndex) {
<span class="fc" id="L1920">		Exp oExp = funCall.getReference();</span>

		// it is possible (if the split member is of dimension to be collapsed),
		// that this funcall does not contain member.
		// Then - there is nothing to split.
<span class="pc bpc" id="L1925" title="1 of 2 branches missed.">		if (!isMemberInFunCall(oExp, member, funCall.getLevel() - 1)) {</span>
<span class="fc" id="L1926">			return; // nothing to split</span>
		}

<span class="nc" id="L1929">		Exp oComplement = createComplement(oExp, member, hierIndex); // can be</span>
																		// null
<span class="nc bnc" id="L1931" title="All 2 branches missed.">		if (oComplement == null) {</span>
			// this means, that the set resolves to a single member,
			// mPath[iDimNode]
<span class="nc" id="L1934">			funCall.setReference(QuaxUtil.expForMember(member));</span>
			// nothing to split
<span class="nc" id="L1936">			return;</span>
		}

		// split the Funcall
<span class="nc" id="L1940">		TreeNode&lt;Exp&gt; newNodeComplement = new TreeNode&lt;Exp&gt;(oComplement);</span>
<span class="nc" id="L1941">		TreeNode&lt;Exp&gt; newNodeMember = new TreeNode&lt;Exp&gt;(</span>
<span class="nc" id="L1942">				QuaxUtil.expForMember(member));</span>

		// add the children
<span class="nc bnc" id="L1945" title="All 2 branches missed.">		for (TreeNode&lt;Exp&gt; child : funCall.getChildren()) {</span>
<span class="nc" id="L1946">			newNodeComplement.addChild(child.deepCopy());</span>
<span class="nc" id="L1947">			newNodeMember.addChild(child.deepCopy());</span>
		}

<span class="nc" id="L1950">		TreeNode&lt;Exp&gt; insert = funCall.getParent();</span>
<span class="nc" id="L1951">		funCall.remove();</span>

<span class="nc" id="L1953">		insert.addChild(newNodeComplement);</span>
<span class="nc" id="L1954">		insert.addChild(newNodeMember);</span>
<span class="nc" id="L1955">	}</span>

	/**
	 * Remove Children node
	 * 
	 * @param nodeToRemove
	 */
	private void removePathToNode(TreeNode&lt;Exp&gt; nodeToRemove) {
<span class="pc bpc" id="L1963" title="1 of 2 branches missed.">		if (nodeToRemove.getParent().getChildren().size() &gt; 1) {</span>
			// this node has siblings, just remove it
<span class="fc" id="L1965">			nodeToRemove.remove();</span>
		} else {
			// no siblings, remove the first parent node having siblings
<span class="nc" id="L1968">			TreeNode&lt;Exp&gt; parent = nodeToRemove.getParent();</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">			while (parent.getParent().getChildren().size() == 1) {</span>
<span class="nc" id="L1970">				parent = parent.getParent();</span>
			}

<span class="nc bnc" id="L1973" title="All 2 branches missed.">			if (parent.getLevel() &gt; 0) { // should always be true</span>
<span class="nc" id="L1974">				parent.remove();</span>
			}
		}
<span class="fc" id="L1977">	}</span>

	/**
	 * generate Exp for all nodes of dimension iDimension
	 * 
	 * @param dimIndex
	 * @return Exp for all nodes
	 */
	public Exp genExpForDim(int dimIndex) {
		// if we got a generate function on this hier, preserve it
<span class="pc bpc" id="L1987" title="3 of 4 branches missed.">		if (generateIndex &gt;= 0 &amp;&amp; generateIndex == dimIndex</span>
<span class="nc bnc" id="L1988" title="All 2 branches missed.">				&amp;&amp; generateMode != CalcSetMode.Simple) {</span>
<span class="nc" id="L1989">			TreeNode&lt;Exp&gt; topCountNode = posTreeRoot.getChildren().get(0);</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">			for (int i = 0; i &lt; generateIndex; i++) {</span>
				// the path to the topcount node at generateIndex does not
				// matter
<span class="nc" id="L1993">				List&lt;TreeNode&lt;Exp&gt;&gt; children = topCountNode.getChildren();</span>
<span class="nc" id="L1994">				topCountNode = children.get(0);</span>
			}

<span class="nc" id="L1997">			Exp topcount = topCountNode.getReference();</span>

<span class="nc" id="L1999">			SetExp setexp = new SetExp(generateMode, topcount,</span>
<span class="nc" id="L2000">					hiers.get(dimIndex));</span>

<span class="nc" id="L2002">			return setexp;</span>
		}

<span class="fc" id="L2005">		List&lt;Exp&gt; funCallList = collectFunCalls(dimIndex);</span>
<span class="fc" id="L2006">		List&lt;Exp&gt; memberList = collectMembers(dimIndex);</span>

<span class="fc" id="L2008">		cleanupMemberList(funCallList, memberList, dimIndex);</span>

<span class="pc bpc" id="L2010" title="2 of 4 branches missed.">		if (funCallList.isEmpty() &amp;&amp; memberList.size() == 1) {</span>
<span class="fc" id="L2011">			return memberList.get(0); // single member only</span>
		}

<span class="nc" id="L2014">		Exp mSet = null;</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">		if (memberList.size() &gt; 0) {</span>
<span class="nc" id="L2016">			Exp[] aExp = memberList.toArray(new Exp[0]);</span>
<span class="nc" id="L2017">			mSet = QuaxUtil.createFunCall(&quot;{}&quot;, aExp, Syntax.Braces);</span>
		}

<span class="nc bnc" id="L2020" title="All 2 branches missed.">		if (funCallList.isEmpty()) {</span>
<span class="nc" id="L2021">			return mSet;</span>
		}

<span class="nc bnc" id="L2024" title="All 4 branches missed.">		if (funCallList.size() == 1 &amp;&amp; mSet == null) {</span>
<span class="nc" id="L2025">			return funCallList.get(0);</span>
		}

		Exp set;

		int start;
<span class="nc bnc" id="L2031" title="All 2 branches missed.">		if (mSet != null) {</span>
<span class="nc" id="L2032">			set = mSet;</span>
<span class="nc" id="L2033">			start = 0;</span>
		} else {
<span class="nc" id="L2035">			set = funCallList.get(0);</span>
<span class="nc" id="L2036">			start = 1;</span>
		}
<span class="nc bnc" id="L2038" title="All 2 branches missed.">		for (int j = start; j &lt; funCallList.size(); j++) {</span>
<span class="nc" id="L2039">			set = QuaxUtil.createFunCall(&quot;Union&quot;,</span>
<span class="nc" id="L2040">					new Exp[] { set, funCallList.get(j) }, Syntax.Function);</span>
		}

<span class="nc" id="L2043">		return set;</span>
	}

	/**
	 * Create drillup expression for dimension
	 * 
	 * @param dimIndex
	 *            dimension to be drilled up
	 * @return
	 */
	private Exp drillupExp(int dimIndex, Hierarchy hierarchy) {
		// the drillup logic is:
		// for all members of this dimension find the deepest level.
		// find the members of this deepest level
		// find the grandfathers of those deepest members
		// drill up goes to the children of those grandfathers.
		// special cases:
		// the deepest level has all members (level.members)
		// the drillup goes to parent_level.members

<span class="fc" id="L2063">		final int[] maxLevel = new int[1];</span>
<span class="fc" id="L2064">		maxLevel[0] = 0;</span>

<span class="fc" id="L2066">		List&lt;Exp&gt; drillupList = collectDrillup(dimIndex, maxLevel);</span>

<span class="fc" id="L2068">		Exp expForHier = null;</span>
<span class="pc bpc" id="L2069" title="1 of 2 branches missed.">		if (maxLevel[0] == 0) {</span>
			// drillup goes to top level members
			// we generate an explicit member set rather than level.members
			// usually, this is a single member &quot;All xy&quot;
<span class="fc" id="L2073">			expForHier = QuaxUtil.topLevelMembers(hierarchy, false);</span>
		} else {
<span class="nc bnc" id="L2075" title="All 2 branches missed.">			if (drillupList.size() == 1) {</span>
<span class="nc" id="L2076">				expForHier = drillupList.get(0);</span>
			} else {
				// more than 1 set expression , need union
<span class="nc bnc" id="L2079" title="All 2 branches missed.">				for (Exp oExp : drillupList) {</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">					if (expForHier == null) {</span>
<span class="nc" id="L2081">						expForHier = oExp;</span>
					} else {
<span class="nc" id="L2083">						expForHier = QuaxUtil.createFunCall(&quot;Union&quot;, new Exp[] {</span>
<span class="nc" id="L2084">								expForHier, oExp }, Syntax.Function);</span>
					}
				}
			}
		}

<span class="fc" id="L2090">		return expForHier;</span>
	}

	/**
	 * Collect drillup Exps of dimension i
	 * 
	 * @param dimIndex
	 */
	private List&lt;Exp&gt; collectDrillup(final int dimIndex, final int[] maxLevel) {
<span class="fc" id="L2099">		final List&lt;Exp&gt; drillupList = new ArrayList&lt;Exp&gt;();</span>

<span class="fc" id="L2101">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback collect GrandFathers of deepest for dimension workInt
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L2107">				int nodeIndex = node.getLevel() - 1;</span>
<span class="pc bpc" id="L2108" title="1 of 2 branches missed.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="nc" id="L2109">					return TreeNodeCallback.CONTINUE;</span>
				}

				// iDimNode == workInt
<span class="fc" id="L2113">				Exp oExp = node.getReference();</span>
<span class="pc bpc" id="L2114" title="1 of 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall
<span class="fc" id="L2116">					addFunCallToDrillup(drillupList, oExp, maxLevel);</span>
				} else {
					// member
<span class="nc" id="L2119">					Member m = QuaxUtil.memberForExp(oExp);</span>
<span class="nc" id="L2120">					QuaxUtil.addMemberUncles(drillupList, m, maxLevel);</span>
				}

<span class="fc" id="L2123">				return TreeNodeCallback.CONTINUE_SIBLING;</span>
			}
		});

<span class="fc" id="L2127">		return drillupList;</span>
	}

	/**
	 * Collect FunCalls of dimension iDim
	 * 
	 * @param dimIndex
	 */
	private List&lt;Exp&gt; collectFunCalls(final int dimIndex) {
<span class="pc bpc" id="L2136" title="1 of 2 branches missed.">		if (posTreeRoot == null) {</span>
<span class="nc" id="L2137">			return Collections.emptyList();</span>
		}

<span class="fc" id="L2140">		final List&lt;Exp&gt; funCalls = new ArrayList&lt;Exp&gt;();</span>
<span class="fc" id="L2141">		final List&lt;String&gt; uniqueNames = new ArrayList&lt;String&gt;();</span>

<span class="fc" id="L2143">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback collect Funcalls of dimension workInt
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L2149">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L2150" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="fc" id="L2151">					return TreeNodeCallback.CONTINUE;</span>
				}

				// iDimNode == workInt
<span class="fc" id="L2155">				Exp oExp = node.getReference();</span>
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall need unique representation in order to avoid
					// doubles
<span class="nc" id="L2159">					String unique = QuaxUtil.funString(oExp).toString();</span>
<span class="nc bnc" id="L2160" title="All 2 branches missed.">					if (!uniqueNames.contains(unique)) {</span>
<span class="nc" id="L2161">						funCalls.add(oExp);</span>
<span class="nc" id="L2162">						uniqueNames.add(unique);</span>
					}
				}

<span class="fc" id="L2166">				return TreeNodeCallback.CONTINUE_SIBLING;</span>
			}
		});

<span class="fc" id="L2170">		return funCalls;</span>
	}

	/**
	 * Remove members from member list being in FunCall list
	 * 
	 * @param funCalls
	 * @param memberList
	 * @param dimIndex
	 */
	private void cleanupMemberList(List&lt;Exp&gt; funCalls, List&lt;Exp&gt; memberList,
			int dimIndex) {
<span class="pc bpc" id="L2182" title="3 of 4 branches missed.">		if (!funCalls.isEmpty() &amp;&amp; !memberList.isEmpty()) {</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">			MemberLoop: for (Iterator&lt;Exp&gt; itMem = memberList.iterator(); itMem</span>
<span class="nc" id="L2184">					.hasNext();) {</span>
<span class="nc" id="L2185">				Exp oMember = itMem.next();</span>

<span class="nc" id="L2187">				Member m = QuaxUtil.memberForExp(oMember);</span>
<span class="nc bnc" id="L2188" title="All 2 branches missed.">				for (Iterator&lt;Exp&gt; itFun = funCalls.iterator(); itFun.hasNext();) {</span>
<span class="nc" id="L2189">					Exp oFun = itFun.next();</span>
<span class="nc bnc" id="L2190" title="All 2 branches missed.">					if (isMemberInFunCall(oFun, m, dimIndex)) {</span>
<span class="nc" id="L2191">						itMem.remove();</span>
<span class="nc" id="L2192">						continue MemberLoop;</span>
					}
				}
			}
		}
<span class="fc" id="L2197">	}</span>

	/**
	 * Collect Members of dimension iDim
	 * 
	 * @param dimIndex
	 */
	private List&lt;Exp&gt; collectMembers(final int dimIndex) {
<span class="pc bpc" id="L2205" title="1 of 2 branches missed.">		if (posTreeRoot == null) {</span>
<span class="nc" id="L2206">			return Collections.emptyList();</span>
		}

<span class="fc" id="L2209">		final List&lt;Exp&gt; memberList = new ArrayList&lt;Exp&gt;();</span>

<span class="fc" id="L2211">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback collect Funcalls of dimension workInt
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L2217">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L2218" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="fc" id="L2219">					return TreeNodeCallback.CONTINUE;</span>
				}

				// iDimNode == workInt
<span class="fc" id="L2223">				Exp oExp = node.getReference();</span>
<span class="pc bpc" id="L2224" title="2 of 4 branches missed.">				if (QuaxUtil.isMember(oExp) &amp;&amp; !memberList.contains(oExp)) {</span>
<span class="fc" id="L2225">					memberList.add(oExp);</span>
				}

<span class="fc" id="L2228">				return TreeNodeCallback.CONTINUE_SIBLING;</span>
			}
		});

<span class="fc" id="L2232">		return memberList;</span>
	}

	/**
	 * Add a Funcall to Drillup list
	 */
	private void addFunCallToDrillup(List&lt;Exp&gt; list, Exp oFun, int[] maxLevel) {
<span class="pc bpc" id="L2239" title="1 of 2 branches missed.">		if (QuaxUtil.isFunCallTo(oFun, &quot;Union&quot;)) {</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">			for (int i = 0; i &lt; 2; i++) {</span>
<span class="nc" id="L2241">				Exp fExp = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc" id="L2242">				addFunCallToDrillup(list, fExp, maxLevel);</span>
			}
<span class="pc bpc" id="L2244" title="1 of 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;{}&quot;)) {</span>
			// set of members
<span class="nc bnc" id="L2246" title="All 2 branches missed.">			for (int i = 0; i &lt; QuaxUtil.funCallArgCount(oFun); i++) {</span>
<span class="nc" id="L2247">				Exp oMember = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc" id="L2248">				Member m = QuaxUtil.memberForExp(oMember);</span>
<span class="nc" id="L2249">				QuaxUtil.addMemberUncles(list, m, maxLevel);</span>
			}
<span class="pc bpc" id="L2251" title="1 of 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Children&quot;)) {</span>
<span class="fc" id="L2252">			Exp oMember = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="fc" id="L2253">			Member m = QuaxUtil.memberForExp(oMember);</span>
<span class="fc" id="L2254">			QuaxUtil.addMemberSiblings(list, m, maxLevel);</span>
<span class="nc bnc" id="L2255" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Descendants&quot;)) {</span>
<span class="nc" id="L2256">			Exp oMember = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2257">			Member m = QuaxUtil.memberForExp(oMember);</span>
<span class="nc" id="L2258">			Exp oLevel = QuaxUtil.funCallArg(oFun, 1);</span>
<span class="nc" id="L2259">			Level lev = QuaxUtil.levelForExp(oLevel);</span>

<span class="nc" id="L2261">			int level = m.getLevel().getDepth();</span>
<span class="nc" id="L2262">			int levlev = lev.getDepth();</span>
<span class="nc bnc" id="L2263" title="All 2 branches missed.">			if (levlev == level + 1) {</span>
<span class="nc" id="L2264">				QuaxUtil.addMemberSiblings(list, m, maxLevel); // same as</span>
																// children
<span class="nc bnc" id="L2266" title="All 2 branches missed.">			} else if (levlev == level + 2) {</span>
<span class="nc" id="L2267">				QuaxUtil.addMemberChildren(list, m, maxLevel); // m *is*</span>
																// grandfather
			} else {
				// add descendants of parent level
<span class="nc" id="L2271">				Level parentLevel = QuaxUtil.getParentLevel(lev);</span>
<span class="nc" id="L2272">				QuaxUtil.addMemberDescendants(list, m, parentLevel, maxLevel);</span>
			}
<span class="nc bnc" id="L2274" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Members&quot;)) {</span>
			// add parent level members
<span class="nc" id="L2276">			Exp oLevel = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2277">			Level lev = QuaxUtil.levelForExp(oLevel);</span>

<span class="nc" id="L2279">			int levlev = lev.getDepth();</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">			if (levlev == 0) {</span>
<span class="nc" id="L2281">				return; // cannot drill up</span>
			}

<span class="nc" id="L2284">			Level parentLevel = QuaxUtil.getParentLevel(lev);</span>
<span class="nc" id="L2285">			QuaxUtil.addLevelMembers(list, parentLevel, maxLevel);</span>
		} else {
			// must be Top/Bottom Function with arg[0] being base set
<span class="nc" id="L2288">			Exp oFun2 = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2289">			addFunCallToDrillup(list, oFun2, maxLevel); // do not have a better</span>
														// solution
		}
<span class="fc" id="L2292">	}</span>

	/**
	 * Add FunCall to list
	 * 
	 * @param oFun
	 * @param list
	 */
	private void funToList(Exp oFun, List&lt;Exp&gt; list) {
<span class="nc bnc" id="L2301" title="All 2 branches missed.">		if (QuaxUtil.isFunCallTo(oFun, &quot;Union&quot;)) {</span>
<span class="nc" id="L2302">			Exp arg0 = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2303">			Exp arg1 = QuaxUtil.funCallArg(oFun, 1);</span>

<span class="nc" id="L2305">			funToList(arg0, list);</span>
<span class="nc" id="L2306">			funToList(arg1, list);</span>
<span class="nc bnc" id="L2307" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;{}&quot;)) {</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">			for (int i = 0; i &lt; QuaxUtil.funCallArgCount(oFun); i++) {</span>
				// member sets are resolved to single members
<span class="nc" id="L2310">				Exp oMember = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc" id="L2311">				list.add(oMember);</span>
			}
		} else {
<span class="nc" id="L2314">			list.add(oFun);</span>
		}
<span class="nc" id="L2316">	}</span>

	/**
	 * Check, whether member is in set defined by funcall
	 * 
	 * @param oExp
	 *            set funcall
	 * @param member
	 * @return
	 */
	private boolean isMemberInFunCall(Exp oExp, Member member, int hierIndex) {
<span class="fc" id="L2327">		boolean result = false;</span>

		try {
<span class="fc" id="L2330">			result = QuaxUtil.isMemberInFunCall(oExp, member);</span>
<span class="nc" id="L2331">		} catch (UnknownExpressionException e) {</span>
			// it is an Unkown FunCall
			// assume &quot;true&quot; if the member is in the List for this dimension
<span class="nc bnc" id="L2334" title="All 2 branches missed.">			if (ufMemberLists.get(hierIndex) == null)</span>
<span class="nc" id="L2335">				throw new PivotException(</span>
<span class="nc" id="L2336">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2337">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>

<span class="nc" id="L2339">			result = ufMemberLists.get(hierIndex).contains(member);</span>
		}

<span class="fc" id="L2342">		return result;</span>
	}

	/**
	 * Check whether a Funcall does NOT resolve to top level of hierarchy
	 */
	private boolean isFunCallNotTopLevel(Exp oExp, int hierIndex) {
<span class="fc" id="L2349">		boolean result = false;</span>

		try {
<span class="fc" id="L2352">			result = QuaxUtil.isFunCallNotTopLevel(oExp);</span>
<span class="nc" id="L2353">		} catch (UnknownExpressionException e) {</span>
			// it is an Unkown FunCall
			// assume &quot;true&quot; if the member is in the List for this dimension
<span class="nc bnc" id="L2356" title="All 2 branches missed.">			if (ufMemberLists.get(hierIndex) == null) {</span>
<span class="nc" id="L2357">				throw new PivotException(</span>
<span class="nc" id="L2358">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2359">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2362">			List&lt;Member&gt; members = ufMemberLists.get(hierIndex);</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">			for (Member member : members) {</span>
<span class="nc bnc" id="L2364" title="All 2 branches missed.">				if (member.getLevel().getDepth() &gt; 0) {</span>
<span class="nc" id="L2365">					result = true;</span>
<span class="nc" id="L2366">					break;</span>
				}
			}
		}

<span class="fc" id="L2371">		return result;</span>
	}

	/**
	 * Check whether a Funcall contains child of member
	 */
	private boolean isChildOfMemberInFunCall(Exp oExp, Member member,
			int hierIndex) {
<span class="fc" id="L2379">		boolean result = false;</span>

		try {
<span class="fc" id="L2382">			result = QuaxUtil.isChildOfMemberInFunCall(oExp, member);</span>
<span class="nc" id="L2383">		} catch (UnknownExpressionException e) {</span>
			// it is an Unkown FunCall
			// assume &quot;true&quot; if the member List for this dimension contains
			// child of member
<span class="nc bnc" id="L2387" title="All 2 branches missed.">			if (ufMemberLists.get(hierIndex) == null) {</span>
<span class="nc" id="L2388">				throw new PivotException(</span>
<span class="nc" id="L2389">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2390">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2393">			List&lt;Member&gt; members = ufMemberLists.get(hierIndex);</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">				if (QuaxUtil.checkParent(member, QuaxUtil.expForMember(m))) {</span>
<span class="nc" id="L2396">					result = true;</span>
<span class="nc" id="L2397">					break;</span>
				}
			}
		}

<span class="fc" id="L2402">		return result;</span>
	}

	/**
	 * Check whether a Funcall contains descendant of member
	 */
	private boolean isDescendantOfMemberInFunCall(Exp oExp, Member member,
			int hierIndex) {
<span class="fc" id="L2410">		boolean result = false;</span>

		try {
<span class="fc" id="L2413">			result = QuaxUtil.isDescendantOfMemberInFunCall(oExp, member);</span>
<span class="nc" id="L2414">		} catch (UnknownExpressionException e) {</span>
			// it is an Unkown FunCall
			// assume &quot;true&quot; if the member List for this dimension contains
			// descendant of member
<span class="nc bnc" id="L2418" title="All 2 branches missed.">			if (ufMemberLists.get(hierIndex) == null) {</span>
<span class="nc" id="L2419">				throw new PivotException(</span>
<span class="nc" id="L2420">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2421">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2424">			List&lt;Member&gt; members = ufMemberLists.get(hierIndex);</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2426" title="All 2 branches missed.">				if (QuaxUtil.checkDescendantM(member, m)) {</span>
<span class="nc" id="L2427">					result = true;</span>
<span class="nc" id="L2428">					break;</span>
				}
			}
		}

<span class="fc" id="L2433">		return result;</span>
	}

	/**
	 * Remove descendants of member from Funcall set
	 * 
	 * @return the remainder after descendants were removed
	 */
	private Exp removeDescendantsFromFunCall(Exp oFun, Member member,
			int hierIndex) {
		try {
<span class="fc" id="L2444">			return removeDescendantsFromFunCall(oFun, member);</span>
<span class="nc" id="L2445">		} catch (UnknownExpressionException e) {</span>
			// the FunCall was not handled,
			// assume that it is an &quot;Unkown FunCall&quot; which was resolved by the
			// latest result
			// the &quot;Unknown Functions&quot; are probably not properly resolved
<span class="nc bnc" id="L2450" title="All 2 branches missed.">			if (logger.isErrorEnabled()) {</span>
<span class="nc" id="L2451">				logger.error(&quot;Unkown FunCall &quot; + QuaxUtil.funCallName(oFun));</span>
			}

<span class="nc bnc" id="L2454" title="All 2 branches missed.">			if (ufMemberLists.get(hierIndex) == null) {</span>
<span class="nc" id="L2455">				throw new PivotException(</span>
<span class="nc" id="L2456">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2457">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2460">			List&lt;Exp&gt; newList = new ArrayList&lt;Exp&gt;();</span>

<span class="nc" id="L2462">			List&lt;Member&gt; members = ufMemberLists.get(hierIndex);</span>
<span class="nc bnc" id="L2463" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2464" title="All 2 branches missed.">				if (!QuaxUtil.checkDescendantM(member, m)) {</span>
<span class="nc" id="L2465">					newList.add(QuaxUtil.expForMember(m));</span>
				}
			}

<span class="nc" id="L2469">			return QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L2470">					newList.toArray(new Exp[newList.size()]), Syntax.Braces);</span>
		}
	}

	/**
	 * Remove descendants of member from Funcall set
	 * 
	 * @return the remainder after descendants were removed
	 */
	private Exp removeDescendantsFromFunCall(Exp oFun, Member member)
			throws UnknownExpressionException {
<span class="pc bpc" id="L2481" title="1 of 2 branches missed.">		if (QuaxUtil.isFunCallTo(oFun, &quot;Children&quot;)) {</span>
			// as we know, that there is a descendent of m in x.children,
			// we know that *all* x.children are descendants of m
<span class="fc" id="L2484">			return null;</span>
<span class="nc bnc" id="L2485" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Descendants&quot;)) {</span>
			// as we know, that there is a descendent of m in x.descendants
			// we know that *all* x.descendants are descendants of m
<span class="nc" id="L2488">			return null;</span>
<span class="nc bnc" id="L2489" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Members&quot;)) {</span>
<span class="nc" id="L2490">			Level level = member.getLevel();</span>

			List&lt;Member&gt; members;
			try {
<span class="nc" id="L2494">				members = level.getMembers();</span>
<span class="nc" id="L2495">			} catch (OlapException e) {</span>
<span class="nc" id="L2496">				throw new PivotException(e);</span>
			}

<span class="nc" id="L2499">			List&lt;Member&gt; remainder = new ArrayList&lt;Member&gt;(members.size());</span>
<span class="nc bnc" id="L2500" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">				if (!QuaxUtil.isDescendant(member, m))</span>
<span class="nc" id="L2502">					remainder.add(m);</span>
			}

<span class="nc" id="L2505">			return QuaxUtil.createMemberSet(remainder);</span>
<span class="nc bnc" id="L2506" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;{}&quot;)) {</span>
<span class="nc" id="L2507">			List&lt;Member&gt; remainder = new ArrayList&lt;Member&gt;();</span>

<span class="nc bnc" id="L2509" title="All 2 branches missed.">			for (int i = 0; i &lt; QuaxUtil.funCallArgCount(oFun); i++) {</span>
<span class="nc" id="L2510">				Exp arg = QuaxUtil.funCallArg(oFun, i);</span>

<span class="nc bnc" id="L2512" title="All 2 branches missed.">				if (!QuaxUtil.isDescendant(member, arg)) {</span>
<span class="nc" id="L2513">					remainder.add(QuaxUtil.memberForExp(arg));</span>
				}
			}

<span class="nc" id="L2517">			return QuaxUtil.createMemberSet(remainder);</span>
<span class="nc bnc" id="L2518" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Union&quot;)) {</span>
<span class="nc" id="L2519">			Exp[] uargs = new Exp[2];</span>
<span class="nc" id="L2520">			uargs[0] = removeDescendantsFromFunCall(</span>
<span class="nc" id="L2521">					QuaxUtil.funCallArg(oFun, 0), member);</span>
<span class="nc" id="L2522">			uargs[1] = removeDescendantsFromFunCall(</span>
<span class="nc" id="L2523">					QuaxUtil.funCallArg(oFun, 0), member);</span>

<span class="nc bnc" id="L2525" title="All 4 branches missed.">			if (uargs[0] == null &amp;&amp; uargs[1] == null) {</span>
<span class="nc" id="L2526">				return null;</span>
			}

<span class="nc bnc" id="L2529" title="All 2 branches missed.">			if (uargs[1] == null) {</span>
<span class="nc" id="L2530">				return uargs[0];</span>
			}

<span class="nc bnc" id="L2533" title="All 2 branches missed.">			if (uargs[0] == null) {</span>
<span class="nc" id="L2534">				return uargs[1];</span>
			}

<span class="nc bnc" id="L2537" title="All 2 branches missed.">			if (QuaxUtil.isMember(uargs[0])) {</span>
<span class="nc" id="L2538">				uargs[0] = QuaxUtil.createFunCall(&quot;{}&quot;, new Exp[] { uargs[0] },</span>
<span class="nc" id="L2539">						Syntax.Braces);</span>
			}

<span class="nc bnc" id="L2542" title="All 2 branches missed.">			if (QuaxUtil.isMember(uargs[1])) {</span>
<span class="nc" id="L2543">				uargs[1] = QuaxUtil.createFunCall(&quot;{}&quot;, new Exp[] { uargs[1] },</span>
<span class="nc" id="L2544">						Syntax.Braces);</span>
			}

<span class="nc bnc" id="L2547" title="All 2 branches missed.">			if (QuaxUtil.isFunCallTo(uargs[0], &quot;{}&quot;)</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">					&amp;&amp; QuaxUtil.isFunCallTo(uargs[1], &quot;{}&quot;)) {</span>
<span class="nc" id="L2549">				return unionOfSets(uargs[0], uargs[1]);</span>
			}

<span class="nc" id="L2552">			return QuaxUtil.createFunCall(&quot;Union&quot;, uargs, Syntax.Function);</span>
		}

<span class="nc" id="L2555">		throw new UnknownExpressionException(QuaxUtil.funCallName(oFun));</span>
	}

	/**
	 * Determine complement set (set minus member)
	 */
	private Exp createComplement(Exp oFun, Member member, int hierIndex) {
		try {
<span class="nc" id="L2563">			return createComplement(oFun, member);</span>
<span class="nc" id="L2564">		} catch (UnknownExpressionException e) {</span>
			// the FunCall was not handled,
			// assume that it is an &quot;Unkown FunCall&quot; which was resolved by the
			// latest result
			// the &quot;Unknown Functions&quot; are probably not properly resolved
<span class="nc bnc" id="L2569" title="All 2 branches missed.">			if (logger.isErrorEnabled()) {</span>
<span class="nc" id="L2570">				logger.error(&quot;Unkown FunCall &quot; + QuaxUtil.funCallName(oFun));</span>
			}

<span class="nc bnc" id="L2573" title="All 2 branches missed.">			if (ufMemberLists.get(hierIndex) == null) {</span>
<span class="nc" id="L2574">				throw new PivotException(</span>
<span class="nc" id="L2575">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2576">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2579">			List&lt;Exp&gt; newList = new ArrayList&lt;Exp&gt;();</span>

<span class="nc" id="L2581">			List&lt;Member&gt; members = ufMemberLists.get(hierIndex);</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2583" title="All 2 branches missed.">				if (!member.equals(m)) {</span>
<span class="nc" id="L2584">					newList.add(QuaxUtil.expForMember(m));</span>
				}
			}

<span class="nc" id="L2588">			return QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L2589">					newList.toArray(new Exp[newList.size()]), Syntax.Braces);</span>
		}
	}

	/**
	 * Determine complement set (set minus member)
	 * 
	 * @throws UnknownExpressionException
	 */
	private Exp createComplement(Exp oFun, Member member)
			throws UnknownExpressionException {
<span class="nc bnc" id="L2600" title="All 2 branches missed.">		if (QuaxUtil.isFunCallTo(oFun, &quot;Children&quot;)) {</span>
<span class="nc" id="L2601">			Exp oParent = QuaxUtil.funCallArg(oFun, 0);</span>

			// if member is NOT a child of Funcall arg, then the complement is
			// the original set
<span class="nc" id="L2605">			Exp oMember = QuaxUtil.expForMember(member);</span>
<span class="nc bnc" id="L2606" title="All 2 branches missed.">			if (!QuaxUtil.checkChild(member, oParent)) {</span>
<span class="nc" id="L2607">				return oFun;</span>
			}

<span class="nc" id="L2610">			List&lt;Exp&gt; oChildren = QuaxUtil.getChildMembers(oParent);</span>
<span class="nc bnc" id="L2611" title="All 2 branches missed.">			if (oChildren.size() &lt; 2) {</span>
<span class="nc" id="L2612">				return null;</span>
			}

<span class="nc" id="L2615">			Exp[] mComplement = new Exp[oChildren.size() - 1];</span>
<span class="nc" id="L2616">			int ii = 0;</span>
<span class="nc bnc" id="L2617" title="All 2 branches missed.">			for (Exp child : oChildren) {</span>
<span class="nc bnc" id="L2618" title="All 2 branches missed.">				if (!child.equals(oMember)) {</span>
<span class="nc" id="L2619">					mComplement[ii++] = child;</span>
				}
			}

<span class="nc bnc" id="L2623" title="All 2 branches missed.">			if (mComplement.length == 1) {</span>
<span class="nc" id="L2624">				return mComplement[0]; // single member</span>
			}

<span class="nc" id="L2627">			Exp oComplement = QuaxUtil.createFunCall(&quot;{}&quot;, mComplement,</span>
<span class="nc" id="L2628">					Syntax.Braces);</span>

<span class="nc" id="L2630">			return oComplement;</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;{}&quot;)) {</span>
<span class="nc" id="L2632">			int nComp = 0;</span>
<span class="nc" id="L2633">			int nArg = QuaxUtil.funCallArgCount(oFun);</span>

<span class="nc" id="L2635">			Exp oMember = QuaxUtil.expForMember(member);</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">			for (int i = 0; i &lt; nArg; i++) {</span>
<span class="nc" id="L2637">				Exp o = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">				if (!(o.equals(oMember))) {</span>
<span class="nc" id="L2639">					++nComp;</span>
				}
			}

<span class="nc bnc" id="L2643" title="All 2 branches missed.">			if (nComp == 0) {</span>
<span class="nc" id="L2644">				return null;</span>
			}

<span class="nc bnc" id="L2647" title="All 2 branches missed.">			if (nComp == nArg) {</span>
				// complement = same
<span class="nc" id="L2649">				return oFun;</span>
			}

<span class="nc" id="L2652">			Exp[] mComplement = new Exp[nComp];</span>
<span class="nc" id="L2653">			int ii = 0;</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">			for (int i = 0; i &lt; nArg; i++) {</span>
<span class="nc" id="L2655">				Exp o = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc bnc" id="L2656" title="All 2 branches missed.">				if (!(o.equals(oMember)))</span>
<span class="nc" id="L2657">					mComplement[ii++] = o;</span>
			}

<span class="nc bnc" id="L2660" title="All 2 branches missed.">			if (mComplement.length == 1) {</span>
<span class="nc" id="L2661">				return mComplement[0]; // single member</span>
			}

<span class="nc" id="L2664">			Exp oComplement = QuaxUtil.createFunCall(&quot;{}&quot;, mComplement,</span>
<span class="nc" id="L2665">					Syntax.Braces);</span>

<span class="nc" id="L2667">			return oComplement;</span>
<span class="nc bnc" id="L2668" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Union&quot;)) {</span>
			// Union of FunCalls, recursive
			// Complement(Union(a,b)) = Union(Complement(a), Complement(b))
<span class="nc" id="L2671">			Exp[] complements = new Exp[2];</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">			for (int i = 0; i &lt; 2; i++) {</span>
<span class="nc" id="L2673">				Exp o = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc" id="L2674">				complements[i] = createComplement(o, member);</span>
			}

<span class="nc bnc" id="L2677" title="All 4 branches missed.">			if (complements[0] == null &amp;&amp; complements[1] == null) {</span>
<span class="nc" id="L2678">				return null;</span>
<span class="nc bnc" id="L2679" title="All 4 branches missed.">			} else if (complements[0] != null &amp;&amp; complements[1] == null) {</span>
<span class="nc" id="L2680">				return complements[0]; // No Union needed</span>
<span class="nc bnc" id="L2681" title="All 4 branches missed.">			} else if (complements[0] == null &amp;&amp; complements[1] != null) {</span>
<span class="nc" id="L2682">				return complements[1]; // No Union needed</span>
			} else {
				// complement can be single member
<span class="nc bnc" id="L2685" title="All 2 branches missed.">				if (!QuaxUtil.isFunCall(complements[0])) {</span>
<span class="nc" id="L2686">					complements[0] = QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L2687">							new Exp[] { complements[0] }, Syntax.Braces);</span>
				}

<span class="nc bnc" id="L2690" title="All 2 branches missed.">				if (!QuaxUtil.isFunCall(complements[1])) {</span>
<span class="nc" id="L2691">					complements[1] = QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L2692">							new Exp[] { complements[1] }, Syntax.Braces);</span>
				}

<span class="nc bnc" id="L2695" title="All 2 branches missed.">				if (QuaxUtil.isFunCallTo(complements[0], &quot;{}&quot;)</span>
<span class="nc bnc" id="L2696" title="All 2 branches missed.">						&amp;&amp; QuaxUtil.isFunCallTo(complements[1], &quot;{}&quot;)) {</span>
					// create single set as union ow two sets
<span class="nc" id="L2698">					return unionOfSets(complements[0], complements[1]);</span>
				}

<span class="nc" id="L2701">				Exp newUnion = QuaxUtil.createFunCall(&quot;Union&quot;, complements,</span>
<span class="nc" id="L2702">						Syntax.Function);</span>

<span class="nc" id="L2704">				return newUnion;</span>
			}
		}

		// the fun call is not supported
<span class="nc" id="L2709">		throw new UnknownExpressionException(QuaxUtil.funCallName(oFun));</span>
	}

	/**
	 * Create new set as union of 2 sets
	 */
	private Exp unionOfSets(Exp set1, Exp set2) {
		// create single set as union ow two sets
<span class="nc" id="L2717">		int n1 = QuaxUtil.funCallArgCount(set1);</span>
<span class="nc" id="L2718">		int n2 = QuaxUtil.funCallArgCount(set2);</span>

<span class="nc" id="L2720">		Exp[] newSet = new Exp[n1 + n2];</span>
<span class="nc" id="L2721">		int i = 0;</span>
<span class="nc bnc" id="L2722" title="All 2 branches missed.">		for (int j = 0; j &lt; n1; j++) {</span>
<span class="nc" id="L2723">			newSet[i++] = QuaxUtil.funCallArg(set1, j);</span>
		}

<span class="nc bnc" id="L2726" title="All 2 branches missed.">		for (int j = 0; j &lt; n2; j++) {</span>
<span class="nc" id="L2727">			newSet[i++] = QuaxUtil.funCallArg(set2, j);</span>
		}
<span class="nc" id="L2729">		return QuaxUtil.createFunCall(&quot;{}&quot;, newSet, Syntax.Braces);</span>
	}

	/**
	 * @param iHier
	 *            index of Hierarchy
	 * @param list
	 *            Member List
	 */
	public void setHierMemberList(int iHier, List&lt;Member&gt; list) {
<span class="nc" id="L2739">		ufMemberLists.set(iHier, list);</span>
<span class="nc" id="L2740">	}</span>

	/**
	 * 
	 * @param iHier
	 *            index of Hierarchy
	 * @return true, if the Hierarchy has an unknown function
	 */
	public boolean isUnknownFunction(int iHier) {
<span class="fc" id="L2749">		return containsUF[iHier];</span>
	}

	/**
	 * @see com.eyeq.pivot4j.StateHolder#bookmarkState()
	 */
	public Serializable bookmarkState() {
<span class="nc" id="L2756">		Serializable[] state = new Serializable[8];</span>

<span class="nc" id="L2758">		state[0] = this.qubonMode;</span>
<span class="nc" id="L2759">		state[1] = this.ordinal;</span>
<span class="nc" id="L2760">		state[2] = this.nDimension;</span>
<span class="nc" id="L2761">		state[3] = this.hierarchizeNeeded;</span>
<span class="nc" id="L2762">		state[4] = this.generateIndex;</span>
<span class="nc" id="L2763">		state[5] = this.generateMode;</span>
<span class="nc" id="L2764">		state[6] = this.nHierExclude;</span>
<span class="nc" id="L2765">		state[7] = posTreeRoot.getReference();</span>

<span class="nc" id="L2767">		return state;</span>
	}

	/**
	 * @see com.eyeq.pivot4j.StateHolder#restoreState(java.io.Serializable)
	 */
	public void restoreState(Serializable state) {
<span class="nc" id="L2774">		Serializable[] states = (Serializable[]) state;</span>

<span class="nc" id="L2776">		this.qubonMode = (Boolean) states[0];</span>
<span class="nc" id="L2777">		this.ordinal = (Integer) states[1];</span>
<span class="nc" id="L2778">		this.nDimension = (Integer) states[2];</span>
<span class="nc" id="L2779">		this.hierarchizeNeeded = (Boolean) states[3];</span>
<span class="nc" id="L2780">		this.generateIndex = (Integer) states[4];</span>
<span class="nc" id="L2781">		this.generateMode = (CalcSetMode) states[5];</span>
<span class="nc" id="L2782">		this.nHierExclude = (Integer) states[6];</span>

<span class="nc" id="L2784">		Exp exp = (Exp) states[7];</span>

<span class="nc" id="L2786">		TreeNode&lt;Exp&gt; node = new TreeNode&lt;Exp&gt;(exp);</span>
<span class="nc" id="L2787">		posTreeRoot.walkTree(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * @param node
			 * @return
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc bnc" id="L2794" title="All 2 branches missed.">				if (node.getReference() instanceof ParseTreeNodeExp) {</span>
<span class="nc" id="L2795">					((ParseTreeNodeExp) node.getReference()).restore(parser);</span>
				}

<span class="nc" id="L2798">				return CONTINUE;</span>
			}
		});

<span class="nc" id="L2802">		this.posTreeRoot = node;</span>
<span class="nc" id="L2803">	}</span>

	/**
	 * String representation (debugging)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
<span class="fc" id="L2812">		final StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L2813">		builder.append(&quot;Number of hierarchies excluded from HIEARARCHIZE=&quot;</span>
<span class="fc" id="L2814">				+ nHierExclude);</span>
<span class="fc" id="L2815">		builder.append('\n');</span>

<span class="pc bpc" id="L2817" title="1 of 2 branches missed.">		if (posTreeRoot == null) {</span>
<span class="nc" id="L2818">			builder.append(&quot;Root=null&quot;);</span>
<span class="nc" id="L2819">			return builder.toString();</span>
		}

<span class="fc" id="L2822">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback quax to String
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L2828">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc" id="L2829">				builder.append(&quot;\n&quot;);</span>

<span class="pc bpc" id="L2831" title="1 of 2 branches missed.">				for (int i = 0; i &lt; nodeIndex - 1; i++) {</span>
<span class="nc" id="L2832">					builder.append(&quot;   &quot;);</span>
				}

<span class="fc bfc" id="L2835" title="All 2 branches covered.">				if (nodeIndex &gt; 0) {</span>
<span class="fc" id="L2836">					builder.append(&quot;+--&quot;);</span>
				}

<span class="fc" id="L2839">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L2840" title="All 2 branches covered.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall
<span class="fc" id="L2842">					builder.append(QuaxUtil.funString(oExp));</span>
				} else {
					// member
<span class="fc" id="L2845">					builder.append(QuaxUtil.getMemberUniqueName(oExp));</span>
				}

<span class="fc" id="L2848">				return TreeNodeCallback.CONTINUE;</span>
			}
		});

<span class="fc" id="L2852">		return builder.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.10.201208310627</span></div></body></html>