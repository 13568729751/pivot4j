<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Quax.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Pivot4J</a> &gt; <a href="index.html" class="el_package">com.eyeq.pivot4j.query</a> &gt; <span class="el_source">Quax.java</span></div><h1>Quax.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/*</span>
 * ====================================================================
 * This software is subject to the terms of the Common Public License
 * Agreement, available at the following URL:
 *   http://www.opensource.org/licenses/cpl.html .
 * You must accept the terms of that agreement to use this software.
 * ====================================================================
 */
package com.eyeq.pivot4j.query;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.olap4j.OlapException;
import org.olap4j.Position;
import org.olap4j.metadata.Dimension;
import org.olap4j.metadata.Hierarchy;
import org.olap4j.metadata.Level;
import org.olap4j.metadata.Member;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.eyeq.pivot4j.PivotException;
import com.eyeq.pivot4j.StateHolder;
import com.eyeq.pivot4j.mdx.Exp;
import com.eyeq.pivot4j.mdx.SetExp;
import com.eyeq.pivot4j.mdx.Syntax;
import com.eyeq.pivot4j.util.TreeNode;
import com.eyeq.pivot4j.util.TreeNodeCallback;

<span class="fc" id="L37">public class Quax implements StateHolder {</span>

<span class="fc" id="L39">	protected static Logger logger = LoggerFactory.getLogger(Quax.class);</span>

	private int nDimension;

	private List&lt;Hierarchy&gt; hiers;

	// currently, we can handle the following Funcalls
	// member.children, member.descendants, level.members
	// other funcalls are &quot;unknown functions&quot;
	private boolean[] containsUF;

	private List[] ufMemberLists; // if there are unknonwn functions

	// private UnknownFunction[] unknownFunctions;
<span class="fc" id="L53">	private TreeNode&lt;Exp&gt; posTreeRoot = null; // Position tree used in normal</span>
												// mode

	private int ordinal; // ordinal of query axis, never changed by swap

<span class="fc" id="L58">	private boolean qubonMode = false;</span>

<span class="fc" id="L60">	private boolean hierarchizeNeeded = false;</span>

	// if there are multiple hierarchies on this quax,
	// &quot;nHierExclude&quot; hierarchies (from right to left)
	// will *not* be included to the Hierarchize Function.
	// So MDX like
	// Crossjoin(Hierarchize(Dim1.A + Dim1.A.Children), {Measures.A.
	// Measures.B})
	// will be generated, so that the Measures are excluded from Hierarchize.
<span class="fc" id="L69">	private int nHierExclude = 0;</span>

<span class="fc" id="L71">	private CalcSetMode generateMode = CalcSetMode.Simple;</span>

<span class="fc" id="L73">	private int generateIndex = -1; // we handle generate for only 1 dimension</span>

<span class="fc" id="L75">	private Object expGenerate = null;</span>

<span class="fc" id="L77">	private Collection&lt;QuaxChangeListener&gt; changeListeners = new ArrayList&lt;QuaxChangeListener&gt;();</span>

<span class="fc" id="L79">	private Map&lt;Member, Boolean&gt; canExpandMemberMap = new HashMap&lt;Member, Boolean&gt;();</span>

<span class="fc" id="L81">	private Map&lt;List&lt;Member&gt;, Boolean&gt; canExpandPosMap = new HashMap&lt;List&lt;Member&gt;, Boolean&gt;();</span>

<span class="fc" id="L83">	private Map&lt;Member, Boolean&gt; canCollapseMemberMap = new HashMap&lt;Member, Boolean&gt;();</span>

<span class="fc" id="L85">	private Map&lt;List&lt;Member&gt;, Boolean&gt; canCollapsePosMap = new HashMap&lt;List&lt;Member&gt;, Boolean&gt;();</span>

	/**
	 * @param ordinal
	 */
<span class="fc" id="L90">	public Quax(int ordinal) {</span>
<span class="fc" id="L91">		this.ordinal = ordinal;</span>
<span class="fc" id="L92">	}</span>

	/**
	 * register change listener
	 * 
	 * @param listener
	 */
	public void addChangeListener(QuaxChangeListener listener) {
<span class="fc" id="L100">		changeListeners.add(listener);</span>
<span class="fc" id="L101">	}</span>

	/**
	 * unregister change listener
	 * 
	 * @param listener
	 */
	public void removeChangeListener(QuaxChangeListener listener) {
<span class="nc" id="L109">		changeListeners.remove(listener);</span>
<span class="nc" id="L110">	}</span>

	/**
	 * Handle change
	 * 
	 * @param changedByNavigator
	 *            true if the memberset was changed by the navigator
	 */
	protected void fireQuaxChanged(boolean changedByNavigator) {
<span class="fc" id="L119">		QuaxChangeEvent e = new QuaxChangeEvent(this, changedByNavigator);</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">		for (QuaxChangeListener listener : changeListeners) {</span>
<span class="fc" id="L121">			listener.quaxChanged(e);</span>
		}

<span class="fc" id="L124">		canExpandMemberMap.clear();</span>
<span class="fc" id="L125">		canExpandPosMap.clear();</span>
<span class="fc" id="L126">		canCollapseMemberMap.clear();</span>
<span class="fc" id="L127">		canCollapsePosMap.clear();</span>
<span class="fc" id="L128">	}</span>

	/**
	 * Initialize quax from result positions
	 * 
	 * @param positions
	 */
	public void initialize(List&lt;Position&gt; positions) {
		List&lt;List&lt;Member&gt;&gt; posMembers;

<span class="fc" id="L138">		int nDimension = 0;</span>

<span class="fc" id="L140">		this.hierarchizeNeeded = false;</span>
<span class="fc" id="L141">		this.nHierExclude = 0;</span>
<span class="fc" id="L142">		this.qubonMode = true;</span>

<span class="pc bpc" id="L144" title="1 of 2 branches missed.">		if (positions.isEmpty()) {</span>
			// the axis does not have any positions
<span class="nc" id="L146">			posMembers = new ArrayList&lt;List&lt;Member&gt;&gt;(0);</span>
<span class="nc" id="L147">			setHierarchies(new ArrayList&lt;Hierarchy&gt;(0));</span>
<span class="nc" id="L148">			return;</span>
		} else {
<span class="fc" id="L150">			nDimension = positions.get(0).getMembers().size();</span>
<span class="fc" id="L151">			posMembers = new ArrayList&lt;List&lt;Member&gt;&gt;(positions.size());</span>

<span class="fc bfc" id="L153" title="All 2 branches covered.">			for (Position position : positions) {</span>
<span class="fc" id="L154">				posMembers.add(new ArrayList&lt;Member&gt;(position.getMembers()));</span>
			}
		}

<span class="fc" id="L158">		List&lt;Hierarchy&gt; hiers = new ArrayList&lt;Hierarchy&gt;(nDimension);</span>

<span class="fc" id="L160">		List&lt;Member&gt; firstMembers = posMembers.get(0);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">		for (Member member : firstMembers) {</span>
<span class="fc" id="L162">			hiers.add(member.getLevel().getHierarchy());</span>
		}

<span class="fc" id="L165">		setHierarchies(hiers);</span>
<span class="fc" id="L166">		initPositions(posMembers);</span>

		// initialize the dimension flags
		// if there is only one set node per dimension,
		// we are in qubon mode
<span class="fc" id="L171">		posTreeRoot.walkTree(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback check qubon mode
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L177">				int iDim = node.getLevel();</span>

<span class="fc bfc" id="L179" title="All 2 branches covered.">				if (iDim == Quax.this.nDimension) {</span>
<span class="fc" id="L180">					return TreeNodeCallback.BREAK; // bottom reached</span>
				}

<span class="fc bfc" id="L183" title="All 2 branches covered.">				if (node.getChildren().size() == 1) {</span>
<span class="fc" id="L184">					return TreeNodeCallback.CONTINUE; // continue next level</span>
				} else {
					// more than one child - break out
<span class="fc" id="L187">					Quax.this.qubonMode = false;</span>
<span class="fc" id="L188">					return TreeNodeCallback.BREAK;</span>
				}
			}
		});

<span class="fc bfc" id="L193" title="All 2 branches covered.">		if (qubonMode) {</span>
<span class="fc" id="L194">			nHierExclude = nDimension - 1; // nothing hierarchized</span>
		}
<span class="fc" id="L196">	}</span>

	/**
	 * Initialize position member list after first result gotten
	 * 
	 * @param posMemStart
	 */
	private void initPositions(List&lt;List&lt;Member&gt;&gt; posMemStart) {
		// no positions - no tree
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">		if (posMemStart.isEmpty()) {</span>
<span class="nc" id="L206">			this.posTreeRoot = null;</span>
<span class="nc" id="L207">			return;</span>
		}

		// before the position tree is created,
		// we want to hierarchize
		/*
		 * if (nDimension &gt; 1) hierarchizePositions(aPosMemStart);
		 */

		// init position tree
<span class="fc" id="L217">		this.posTreeRoot = new TreeNode&lt;Exp&gt;(null); // root</span>
<span class="fc" id="L218">		int end = addToPosTree(posMemStart, 0, posMemStart.size(), 0,</span>
<span class="fc" id="L219">				posTreeRoot);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">		while (end &lt; posMemStart.size()) {</span>
<span class="fc" id="L221">			end = addToPosTree(posMemStart, end, posMemStart.size(), 0,</span>
<span class="fc" id="L222">					posTreeRoot);</span>
		}

		// try to factor out the members of the last dimension
<span class="fc" id="L226">		posTreeRoot.walkTree(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback create member set for last dimension
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L232">				int dimIndex = node.getLevel();</span>

<span class="fc bfc" id="L234" title="All 2 branches covered.">				if (dimIndex == Quax.this.nDimension - 1) {</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">					if (node.getChildren().size() &lt;= 1) {</span>
<span class="fc" id="L236">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					}
					// continue
					// next
					// sibling
					// more than one child in last dimension
					// create a single set function node
<span class="fc" id="L243">					Exp[] memArray = new Exp[node.getChildren().size()];</span>
<span class="fc" id="L244">					int i = 0;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">					for (TreeNode&lt;Exp&gt; child : node.getChildren()) {</span>
<span class="fc" id="L246">						memArray[i++] = child.getReference();</span>
					}

<span class="fc" id="L249">					node.getChildren().clear();</span>

<span class="fc" id="L251">					Exp oFun = QuaxUtil.createFunCall(&quot;{}&quot;, memArray,</span>
<span class="fc" id="L252">							Syntax.Braces);</span>

<span class="fc" id="L254">					TreeNode&lt;Exp&gt; newChild = new TreeNode&lt;Exp&gt;(oFun);</span>
<span class="fc" id="L255">					node.addChild(newChild);</span>

<span class="fc" id="L257">					return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
					// sibling
				}
<span class="fc" id="L260">				return TreeNodeCallback.CONTINUE;</span>
			}
		});

<span class="fc" id="L264">		this.containsUF = new boolean[nDimension]; // init false</span>
<span class="fc" id="L265">		this.ufMemberLists = new List[nDimension];</span>

<span class="pc bpc" id="L267" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L268">			logger.debug(&quot;after initPositions &quot; + this.toString());</span>
		}
<span class="fc" id="L270">	}</span>

	/**
	 * add members of dimension to tree recursively
	 * 
	 * @param posMembers
	 *            positon member array
	 * @param startIndex
	 *            start position for this dimension
	 * @param endIndex
	 *            end position for this dimension
	 * @param dimIndex
	 *            index of this dimension
	 * @param parentNode
	 *            parent node (previous dimension)
	 * @return index of position where the member of this dimension changes
	 */
	protected int addToPosTree(List&lt;List&lt;Member&gt;&gt; posMembers, int startIndex,
			int endIndex, int dimIndex, TreeNode&lt;Exp&gt; parentNode) {
<span class="fc" id="L289">		Member currentOfDim = posMembers.get(startIndex).get(dimIndex);</span>

<span class="fc" id="L291">		Exp exp = QuaxUtil.expForMember(currentOfDim);</span>
<span class="fc" id="L292">		TreeNode&lt;Exp&gt; newNode = new TreeNode&lt;Exp&gt;(exp);</span>
<span class="fc" id="L293">		parentNode.addChild(newNode);</span>

		// check range where member of this dimension is constant
<span class="fc" id="L296">		int endRange = startIndex + 1;</span>
<span class="pc bfc" id="L297" title="All 2 branches covered.">		for (; endRange &lt; endIndex; endRange++) {</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">			if (!posMembers.get(endRange).get(dimIndex).equals(currentOfDim)) {</span>
<span class="fc" id="L299">				break;</span>
			}
		}

<span class="fc" id="L303">		int nextDim = dimIndex + 1;</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">		if (nextDim &lt; nDimension) {</span>
<span class="fc" id="L305">			int endChild = addToPosTree(posMembers, startIndex, endRange,</span>
<span class="fc" id="L306">					nextDim, newNode);</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">			while (endChild &lt; endRange) {</span>
<span class="nc" id="L308">				endChild = addToPosTree(posMembers, endChild, endRange,</span>
<span class="nc" id="L309">						nextDim, newNode);</span>
			}
		}

<span class="fc" id="L313">		return endRange;</span>
	}

	/**
	 * @return
	 */
	public int getNDimension() {
<span class="nc" id="L320">		return nDimension;</span>
	}

	/**
	 * @return posTreeRoot
	 */
	public TreeNode&lt;Exp&gt; getPosTreeRoot() {
<span class="nc" id="L327">		return posTreeRoot;</span>
	}

	/**
	 * @param posTreeRoot
	 * @param hiersChanged
	 */
	public void setPosTreeRoot(TreeNode&lt;Exp&gt; posTreeRoot, boolean hiersChanged) {
<span class="nc" id="L335">		this.posTreeRoot = posTreeRoot;</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">		if (hiersChanged) {</span>
			// count dimensions, set hierarchies
<span class="nc" id="L339">			TreeNode&lt;Exp&gt; firstNode = posTreeRoot;</span>

<span class="nc" id="L341">			List&lt;Hierarchy&gt; hiersList = new ArrayList&lt;Hierarchy&gt;();</span>
<span class="nc" id="L342">			List&lt;TreeNode&lt;Exp&gt;&gt; children = firstNode.getChildren();</span>

<span class="nc bnc" id="L344" title="All 2 branches missed.">			while (children.size() &gt; 0) {</span>
<span class="nc" id="L345">				firstNode = children.get(0);</span>
<span class="nc" id="L346">				Exp oExp = firstNode.getReference();</span>

				Hierarchy hier;
				try {
<span class="nc" id="L350">					hier = QuaxUtil.hierForExp(oExp);</span>
<span class="nc" id="L351">				} catch (UnknownExpressionException e) {</span>
<span class="nc" id="L352">					throw new PivotException(</span>
<span class="nc" id="L353">							&quot;Could not determine Hierarchy for set : &quot;</span>
<span class="nc" id="L354">									+ e.getExpression());</span>
				}

<span class="nc" id="L357">				hiersList.add(hier);</span>

<span class="nc" id="L359">				++nDimension;</span>
<span class="nc" id="L360">				children = firstNode.getChildren();</span>
			}

<span class="nc" id="L363">			hiers = hiersList;</span>

<span class="nc" id="L365">			nDimension = hiers.size();</span>

<span class="nc" id="L367">			containsUF = new boolean[nDimension]; // init false</span>
<span class="nc" id="L368">			ufMemberLists = new List[nDimension];</span>

			// go through nodes and check for Unknown functions
			// only one unknown function is possible in one hierarchy
<span class="nc" id="L372">			posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

				/**
				 * callback find unknown functions
				 */
				public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L378">					int nodeIndex = node.getLevel() - 1;</span>

<span class="nc" id="L380">					Exp oExp = node.getReference();</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">					if (!QuaxUtil.canHandle(oExp)) {</span>
						// indicate that dimension i contains an unknown
						// function,
						// which cannot be handled in some cases.
						// this will cause the member list of this dimension to
						// be stored
<span class="nc" id="L387">						containsUF[nodeIndex] = true;</span>
					}

<span class="nc" id="L390">					return TreeNodeCallback.CONTINUE;</span>
				}
			});
		}
<span class="nc" id="L394">	}</span>

	public int getGenerateIndex() {
<span class="nc" id="L397">		return generateIndex;</span>
	}

	public void setGenerateIndex(int i) {
<span class="nc" id="L401">		this.generateIndex = i;</span>
<span class="nc" id="L402">	}</span>

	public CalcSetMode getGenerateMode() {
<span class="nc" id="L405">		return generateMode;</span>
	}

	public void setGenerateMode(CalcSetMode mode) {
<span class="nc" id="L409">		this.generateMode = mode;</span>
<span class="nc" id="L410">	}</span>

	/**
	 * reset generate &quot;topcount&quot;
	 */
	public void resetGenerate() {
<span class="nc" id="L416">		this.generateMode = CalcSetMode.Simple;</span>
<span class="nc" id="L417">		this.generateIndex = -1;</span>
<span class="nc" id="L418">		this.expGenerate = null;</span>
<span class="nc" id="L419">	}</span>

	/**
	 * @return Returns the nHierExclude.
	 */
	public int getNHierExclude() {
<span class="nc" id="L425">		return nHierExclude;</span>
	}

	/**
	 * @param hierExclude
	 *            The nHierExclude to set.
	 */
	public void setNHierExclude(int hierExclude) {
<span class="nc" id="L433">		this.nHierExclude = hierExclude;</span>
<span class="nc" id="L434">	}</span>

	/**
	 * only allow expand/collapse left of a &quot;sticky topcount&quot;
	 */
	private boolean allowNavigate(Member member, boolean qubon) {
<span class="fc" id="L440">		int iDim = dimIdx(member.getDimension());</span>
<span class="fc" id="L441">		return allowNavigate(iDim, qubon);</span>
	}

	/**
	 * Only allow expand/collapse left of a &quot;sticky topcount&quot;
	 */
	private boolean allowNavigate(int dimIndex, boolean qubon) {
<span class="pc bpc" id="L448" title="5 of 6 branches missed.">		if (qubon &amp;&amp; generateIndex &gt;= 0 &amp;&amp; generateMode == CalcSetMode.Sticky</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">				&amp;&amp; dimIndex == generateIndex) {</span>
<span class="nc" id="L450">			return false;</span>
<span class="pc bpc" id="L451" title="2 of 4 branches missed.">		} else if (!qubon &amp;&amp; generateIndex &gt;= 0</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">				&amp;&amp; generateMode == CalcSetMode.Sticky</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">				&amp;&amp; dimIndex &gt;= generateIndex) {</span>
<span class="nc" id="L454">			return false;</span>
		} else {
<span class="fc" id="L456">			return true;</span>
		}
	}

	/**
	 * @return
	 */
	public boolean isHierarchizeNeeded() {
<span class="fc" id="L464">		return hierarchizeNeeded;</span>
	}

	/**
	 * @param b
	 */
	public void setHierarchizeNeeded(boolean b) {
<span class="nc" id="L471">		hierarchizeNeeded = b;</span>
<span class="nc" id="L472">	}</span>

	/**
	 * get Ordinal for axis, this is the immutable id of the quax
	 * 
	 * @return ordinal
	 */
	public int getOrdinal() {
<span class="nc" id="L480">		return ordinal;</span>
	}

	/**
	 * @return hierarchies
	 */
	public List&lt;Hierarchy&gt; getHierarchies() {
<span class="nc" id="L487">		return hiers;</span>
	}

	/**
	 * @param hierarchies
	 */
	public void setHierarchies(List&lt;Hierarchy&gt; hierarchies) {
<span class="fc" id="L494">		this.hiers = hierarchies;</span>
<span class="fc" id="L495">		this.nDimension = hierarchies.size();</span>
<span class="fc" id="L496">	}</span>

	/**
	 * @return
	 */
	public boolean isQubonMode() {
<span class="nc" id="L502">		return qubonMode;</span>
	}

	/**
	 * @param qubonMode
	 */
	public void setQubonMode(boolean qubonMode) {
<span class="nc" id="L509">		this.qubonMode = qubonMode;</span>
<span class="nc" id="L510">	}</span>

	/**
	 * Find out, whether axis contains dimension
	 * 
	 * @param dim
	 * @return index of dimension, -1 if not there
	 */
	public int dimIdx(Dimension dim) {
<span class="pc bpc" id="L519" title="2 of 4 branches missed.">		if (hiers == null || hiers.isEmpty()) {</span>
<span class="nc" id="L520">			return -1; // quax was not initialized yet</span>
		}

<span class="fc" id="L523">		int i = 0;</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">		for (Hierarchy hierarchy : hiers) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">			if (hierarchy.getDimension().equals(dim)) {</span>
<span class="fc" id="L526">				return i;</span>
			}

<span class="fc" id="L529">			i++;</span>
		}

<span class="fc" id="L532">		return -1;</span>
	}

	/**
	 * Regenerate the position tree as crossjoin between sets
	 * 
	 * @param hiersChanged
	 *            indicates that the hierarchies were changed
	 */
	public void regeneratePosTree(List&lt;Exp&gt; sets, boolean hiersChanged) {
<span class="nc bnc" id="L542" title="All 2 branches missed.">		if (hiersChanged) {</span>
<span class="nc" id="L543">			this.nDimension = sets.size();</span>
<span class="nc" id="L544">			this.hiers = new ArrayList&lt;Hierarchy&gt;(nDimension);</span>

<span class="nc bnc" id="L546" title="All 2 branches missed.">			for (Exp set : sets) {</span>
				try {
<span class="nc" id="L548">					hiers.add(QuaxUtil.hierForExp(set));</span>
<span class="nc" id="L549">				} catch (UnknownExpressionException e) {</span>
<span class="nc" id="L550">					throw new PivotException(&quot;Unknown expression : &quot;</span>
<span class="nc" id="L551">							+ e.getExpression());</span>
				}
			}

<span class="nc" id="L555">			this.containsUF = new boolean[nDimension]; // init false</span>
<span class="nc" id="L556">			this.ufMemberLists = new List[nDimension];</span>
<span class="nc" id="L557">			this.generateIndex = 0;</span>
<span class="nc" id="L558">			this.generateMode = CalcSetMode.Simple;</span>
		}

<span class="nc bnc" id="L561" title="All 2 branches missed.">		if (posTreeRoot == null) {</span>
<span class="nc" id="L562">			return;</span>
		}

<span class="nc" id="L565">		posTreeRoot.getChildren().clear();</span>

<span class="nc" id="L567">		TreeNode&lt;Exp&gt; current = posTreeRoot;</span>

		// it would be fine, if we could get rid of an existing Hierarchize
		// - but this is not easy to decide.
		// we will not do it, if there is a &quot;children&quot; function call
		// not on the highest Level. This indicates that we have drilled
		// down any member.
<span class="nc" id="L574">		this.nHierExclude = 0;</span>

<span class="nc" id="L576">		int nChildrenFound = 0;</span>
<span class="nc" id="L577">		boolean childrenFound = false;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">		for (int i = 0; i &lt; nDimension; i++) {</span>
			TreeNode&lt;Exp&gt; newNode;

<span class="nc" id="L581">			Exp set = sets.get(i);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">			if (set instanceof SetExp) {</span>
<span class="nc" id="L583">				SetExp setx = (SetExp) set;</span>
<span class="nc" id="L584">				newNode = new TreeNode&lt;Exp&gt;(setx.getExpression());</span>

<span class="nc" id="L586">				CalcSetMode mode = setx.getMode();</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">				if (mode != CalcSetMode.Simple) {</span>
<span class="nc" id="L588">					this.generateMode = mode;</span>
<span class="nc" id="L589">					this.generateIndex = i;</span>
<span class="nc" id="L590">					this.expGenerate = setx.getExpression();</span>
				}
			} else {
				// can we remove an existing &quot;hierarchize needed&quot;?
<span class="nc" id="L594">				boolean bChildrenFound = findChildrenCall(set, 0);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">				if (bChildrenFound) {</span>
<span class="nc" id="L596">					childrenFound = true;</span>
<span class="nc" id="L597">					nChildrenFound = i + 1;</span>
				}

<span class="nc" id="L600">				newNode = new TreeNode&lt;Exp&gt;(set);</span>
<span class="nc bnc" id="L601" title="All 4 branches missed.">				if (generateIndex == i &amp;&amp; generateMode == CalcSetMode.Sticky) {</span>
					// there was a sticky generate on this hier
					// reset, if set expression is different now
<span class="nc bnc" id="L604" title="All 2 branches missed.">					if (!set.equals(expGenerate)) {</span>
<span class="nc" id="L605">						resetGenerate();</span>
					}
				}
			}
<span class="nc" id="L609">			current.addChild(newNode);</span>
<span class="nc" id="L610">			current = newNode;</span>

<span class="nc bnc" id="L612" title="All 2 branches missed.">			if (!QuaxUtil.canHandle(newNode.getReference())) {</span>
				// indicate that dimension i contains an unknown function,
				// which cannot be handled in some cases.
				// this will cause the member list of this dimension to be
				// stored
<span class="nc" id="L617">				containsUF[i] = true;</span>
			}
		}

<span class="nc" id="L621">		this.qubonMode = true;</span>
<span class="nc" id="L622">		this.nHierExclude = nDimension - nChildrenFound;</span>

<span class="nc bnc" id="L624" title="All 2 branches missed.">		if (!childrenFound) {</span>
<span class="nc" id="L625">			this.hierarchizeNeeded = false;</span>
		}
<span class="nc" id="L627">	}</span>

	/**
	 * Recursively find &quot;children&quot; Funcall
	 */
	private boolean findChildrenCall(Exp oExp, int level) {
<span class="nc bnc" id="L633" title="All 2 branches missed.">		if (!QuaxUtil.isFunCall(oExp))</span>
<span class="nc" id="L634">			return false; // member or level or ...</span>
<span class="nc bnc" id="L635" title="All 4 branches missed.">		if (level &gt; 0 &amp;&amp; QuaxUtil.isFunCallTo(oExp, &quot;children&quot;)) {</span>
<span class="nc" id="L636">			return true;</span>
		}

<span class="nc" id="L639">		int argCount = QuaxUtil.funCallArgCount(oExp);</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">		for (int i = 0; i &lt; argCount; i++) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">			if (findChildrenCall(QuaxUtil.funCallArg(oExp, i), level + 1)) {</span>
<span class="nc" id="L642">				return true;</span>
			}
		}

<span class="nc" id="L646">		return false;</span>
	}

	/**
	 * Check, whether a member in a specific position path can be expanded
	 * 
	 * @param memberPath
	 *            position path to be expanded
	 */
	public boolean canExpand(List&lt;Member&gt; memberPath) {
<span class="fc" id="L656">		int dimIndex = memberPath.size() - 1;</span>

		// we only allow expand / collapse for a dimension
		// left of a &quot;sticky topcount&quot;
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">		if (!allowNavigate(dimIndex, false)) {</span>
<span class="nc" id="L661">			return false;</span>
		}

		// first check the cache
<span class="fc bfc" id="L665" title="All 2 branches covered.">		if (canExpandPosMap.containsKey(memberPath)) {</span>
<span class="fc" id="L666">			Boolean bCanExpand = (Boolean) canExpandPosMap.get(memberPath);</span>
<span class="fc" id="L667">			return bCanExpand.booleanValue();</span>
		}

		// loop over Position Tree
		// reject expansion, if the axis already contains child-positions
<span class="fc" id="L672">		boolean childFound = checkChildPosition(memberPath);</span>

		// cache the result
<span class="fc bfc" id="L675" title="All 2 branches covered.">		Boolean bool = new Boolean(!childFound);</span>
<span class="fc" id="L676">		canExpandPosMap.put(memberPath, bool);</span>

<span class="fc bfc" id="L678" title="All 2 branches covered.">		return !childFound;</span>
	}

	/**
	 * Expand position path
	 * 
	 * @param memberPath
	 */
	public void expand(List&lt;Member&gt; memberPath) {
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">		if (qubonMode) {</span>
<span class="nc" id="L688">			resolveUnions();</span>

<span class="nc bnc" id="L690" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L691">				logger.debug(&quot;Expand after resolveUnions &quot; + this.toString());</span>
			}
		}

<span class="fc" id="L695">		int dimIndex = memberPath.size() - 1;</span>

		// update the position member tree
		// assume mPath = (Product.Drink,Time.2003,Customers.USA)
		// 1. find the node N1 for (Product.Drink,Time.2003)
		// 2. add the child node Customers.USA.Children to the node N1
		//
		// if the node N1 for (Product.Drink,Time.2003) was not found:
		// we look for a matching node and find for instance
		// node N2 = (Product.AllProducts.Children,Time.2003)
		// here, we cannot append Customers.USA.Children as a child node.
		// we add a new branch
		// (Product.Drink,Time.2003,Customers.USA.Children) to the tree.

<span class="fc" id="L709">		TreeNode&lt;Exp&gt; bestNode = findBestNode(memberPath);</span>
<span class="fc" id="L710">		int bestNodeIndex = bestNode.getLevel() - 1;</span>

		// add branch at startNode
		// example
		// dimensions: Product,MaritalStatus,Gender,Customer
		// mPath to Drill Down = (Product.AllProducts, MaritalStatus.M,
		// Gender.AllGender)
		// MaritalStatus.AllMaritalStatus was drilled down so best match is
		// (Product.AllProducts)
		// add the branch from MaritalStatus to this node giving
		// (Product.AllProducts,MaritalStatus.M,Gender.AllGender.children)
		// for the Customer Dimension, add all nodes matching
		// (Product.AllProducts, MaritalStatus.M, Gender.AllGender, * )

		List&lt;TreeNode&lt;Exp&gt;&gt; tailNodeList;
<span class="pc bpc" id="L725" title="1 of 2 branches missed.">		if (memberPath.size() &lt; nDimension) {</span>
<span class="nc" id="L726">			tailNodeList = collectTailNodes(posTreeRoot, memberPath);</span>
		} else {
<span class="fc" id="L728">			tailNodeList = Collections.emptyList();</span>
		}

		TreeNode&lt;Exp&gt; newNode;

<span class="fc" id="L733">		Exp oMember = QuaxUtil.expForMember(memberPath.get(dimIndex));</span>
<span class="fc" id="L734">		Exp fChildren = QuaxUtil.createFunCall(&quot;Children&quot;,</span>
<span class="fc" id="L735">				new Exp[] { oMember }, Syntax.Property);</span>

<span class="fc" id="L737">		TreeNode&lt;Exp&gt; parent = bestNode;</span>

		// if bestNode is matching mPath[iDim]
		// we will add the children Funcall to its parent
		// otherwise create path from bestNode to mPath[iDim-1] and
		// add the children FunCall there
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">		if (bestNodeIndex == dimIndex) {</span>
<span class="fc" id="L744">			parent = bestNode.getParent();</span>
		} else {
<span class="nc bnc" id="L746" title="All 2 branches missed.">			for (int i = bestNodeIndex + 1; i &lt; memberPath.size() - 1; i++) {</span>
<span class="nc" id="L747">				oMember = QuaxUtil.expForMember(memberPath.get(i));</span>
<span class="nc" id="L748">				newNode = new TreeNode&lt;Exp&gt;(oMember);</span>

<span class="nc" id="L750">				parent.addChild(newNode);</span>
<span class="nc" id="L751">				parent = newNode;</span>
			}
		}

		// any dimension left and including iDim will *not* be excluded from
		// hierarchize
<span class="fc" id="L757">		int n = nDimension - dimIndex - 1;</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">		if (n &lt; nHierExclude) {</span>
<span class="nc" id="L759">			this.nHierExclude = n;</span>
		}

<span class="fc" id="L762">		newNode = new TreeNode&lt;Exp&gt;(fChildren);</span>
<span class="fc" id="L763">		parent.addChild(newNode);</span>

<span class="pc bpc" id="L765" title="1 of 2 branches missed.">		if (memberPath.size() &lt; nDimension) {</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">			for (TreeNode&lt;Exp&gt; tailNode : tailNodeList) {</span>
<span class="nc" id="L767">				newNode.addChild(tailNode.deepCopy());</span>
			}
		}

<span class="pc bpc" id="L771" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L772">			logger.debug(&quot;After expand &quot; + this.toString());</span>
		}

<span class="fc" id="L775">		this.qubonMode = false;</span>
<span class="fc" id="L776">		this.hierarchizeNeeded = true;</span>

<span class="fc" id="L778">		fireQuaxChanged(false);</span>
<span class="fc" id="L779">	}</span>

	/**
	 * Check, whether a member can be expanded
	 * 
	 * @param member
	 *            member to be expanded
	 */
	public boolean canExpand(Member member) {
		// we only allow expand / collapse for a dimension
		// left of a &quot;sticky topcount&quot;
<span class="pc bpc" id="L790" title="1 of 2 branches missed.">		if (!allowNavigate(member, false)) {</span>
<span class="nc" id="L791">			return false;</span>
		}

		// first check the cache
<span class="fc bfc" id="L795" title="All 2 branches covered.">		if (canExpandMemberMap.containsKey(member)) {</span>
<span class="fc" id="L796">			boolean canExpand = canExpandMemberMap.get(member);</span>
<span class="fc" id="L797">			return canExpand;</span>
		}

		// loop over Position Tree
		// reject expansion, if the axis already contains children of member
<span class="fc bfc" id="L802" title="All 2 branches covered.">		boolean found = !findMemberChild(member);</span>

		// cache the result
<span class="fc" id="L805">		canExpandMemberMap.put(member, found);</span>

<span class="fc" id="L807">		return found;</span>
	}

	/**
	 * Expand member all over position tree
	 * 
	 * @param member
	 */
	public void expand(final Member member) {
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">		if (qubonMode) {</span>
<span class="nc" id="L817">			resolveUnions();</span>

<span class="nc bnc" id="L819" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L820">				logger.debug(&quot;Expand after resolveUnions &quot; + this.toString());</span>
			}
		}

		// old stuff, always hierarchize everything
<span class="fc" id="L825">		this.nHierExclude = 0;</span>

<span class="fc" id="L827">		final int dimIndex = this.dimIdx(member.getDimension());</span>
<span class="fc" id="L828">		final List&lt;TreeNode&lt;Exp&gt;&gt; nodesForMember = new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;();</span>

		// update the position member tree
		// wherever we find monMember, expand it
		// collect all nodes for monMember in workList
<span class="fc" id="L833">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching member Path exactly
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L839">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="fc" id="L841">					return TreeNodeCallback.CONTINUE; // we are below iDim,</span>
					// don't care
				}

				// iDimNode == iDim
				// node Exp must contain children of member[iDim]
<span class="fc" id="L847">				Exp oExp = node.getReference();</span>
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">				if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">					if (QuaxUtil.equalMember(oExp, member)) {</span>
<span class="fc" id="L850">						nodesForMember.add(node);</span>
					}
				} else {
					// must be FunCall
<span class="nc bnc" id="L854" title="All 2 branches missed.">					if (isMemberInFunCall(oExp, member, dimIndex)) {</span>
<span class="nc" id="L855">						nodesForMember.add(node);</span>
					}
				}

<span class="fc" id="L859">				return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
				// sibling
			}
		});

		// add children of member to each node in list
<span class="fc" id="L865">		Exp oMember = QuaxUtil.expForMember(member);</span>
<span class="fc" id="L866">		Exp fChildren = QuaxUtil.createFunCall(&quot;Children&quot;,</span>
<span class="fc" id="L867">				new Exp[] { oMember }, Syntax.Property);</span>

<span class="fc bfc" id="L869" title="All 2 branches covered.">		for (TreeNode&lt;Exp&gt; node : nodesForMember) {</span>
<span class="fc" id="L870">			TreeNode&lt;Exp&gt; newNode = new TreeNode&lt;Exp&gt;(fChildren);</span>

<span class="pc bpc" id="L872" title="1 of 2 branches missed.">			for (TreeNode&lt;Exp&gt; child : node.getChildren()) {</span>
<span class="nc" id="L873">				newNode.addChild(child.deepCopy());</span>
			}

<span class="fc" id="L876">			TreeNode&lt;Exp&gt; parent = node.getParent();</span>
<span class="fc" id="L877">			parent.addChild(newNode);</span>
		}

<span class="pc bpc" id="L880" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L881">			logger.debug(&quot;After expand member &quot; + this.toString());</span>
		}

<span class="fc" id="L884">		this.hierarchizeNeeded = true;</span>

<span class="fc" id="L886">		fireQuaxChanged(false);</span>
<span class="fc" id="L887">	}</span>

	/**
	 * Check, whether a member path can be collapsed this is true if there is a
	 * child position path
	 * 
	 * @param memberPath
	 *            position path to be collapsed
	 */
	public boolean canCollapse(List&lt;Member&gt; memberPath) {
<span class="fc" id="L897">		int dimIndex = memberPath.size() - 1;</span>

		// we only allow expand / collapse for a dimension
		// left of a &quot;sticky topcount&quot;
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">		if (!allowNavigate(dimIndex, false)) {</span>
<span class="nc" id="L902">			return false;</span>
		}

		// first check the cache
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">		if (canCollapsePosMap.containsKey(memberPath)) {</span>
<span class="nc" id="L907">			boolean canCollapse = canCollapsePosMap.get(memberPath);</span>
<span class="nc" id="L908">			return canCollapse;</span>
		}

		// loop over Position Tree
		// collapse is possible, if the axis already contains child-positions
<span class="fc" id="L913">		boolean childFound = checkChildPosition(memberPath);</span>

		// cache the result
<span class="fc" id="L916">		canCollapsePosMap.put(memberPath, childFound);</span>

<span class="fc" id="L918">		return childFound;</span>
	}

	/**
	 * Remove child positions of mPath from position tree
	 * 
	 * @param memberPath
	 *            member path to be collapsed
	 */
	public void collapse(final List&lt;Member&gt; memberPath) {
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">		if (qubonMode) {</span>
<span class="nc" id="L929">			resolveUnions();</span>

<span class="nc bnc" id="L931" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L932">				logger.debug(&quot;Collapse after resolveUnions &quot; + this.toString());</span>
			}
		}

<span class="fc" id="L936">		final int dimIndex = memberPath.size() - 1;</span>

<span class="fc" id="L938">		int pathSize = memberPath.size();</span>

		// determine FunCall nodes to be split
<span class="fc" id="L941">		final List&lt;List&lt;TreeNode&lt;Exp&gt;&gt;&gt; splitLists = new ArrayList&lt;List&lt;TreeNode&lt;Exp&gt;&gt;&gt;(</span>
<span class="fc" id="L942">				pathSize);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">		for (int i = 0; i &lt; pathSize; i++) {</span>
<span class="fc" id="L944">			splitLists.add(new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;());</span>
		}

<span class="fc" id="L947">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback Find child paths of member path. Collect FunCall nodes
			 * above in List. We have a list for any dimension, so that we can
			 * avoid dependency conflicts when we split the FunCalls.
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
				// check, whether this node matches mPath
<span class="fc" id="L956">				Exp oExp = node.getReference();</span>

<span class="fc" id="L958">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="pc bpc" id="L960" title="1 of 2 branches missed.">					if (QuaxUtil.isMember(oExp)) {</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">						if (QuaxUtil.equalMember(oExp,</span>
<span class="fc" id="L962">								memberPath.get(nodeIndex))) {</span>
<span class="fc" id="L963">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="fc" id="L965">							return TreeNodeCallback.CONTINUE_SIBLING;</span>
						}
					} else {
						// Funcall
<span class="nc bnc" id="L969" title="All 2 branches missed.">						if (isMemberInFunCall(oExp, memberPath.get(nodeIndex),</span>
<span class="nc" id="L970">								nodeIndex)) {</span>
<span class="nc" id="L971">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="nc" id="L973">							return TreeNodeCallback.CONTINUE_SIBLING;</span>
						}
					}
				}
				// idi == iDim
				// oExp *must* be descendant of mPath[iDim] to get deleted
<span class="fc" id="L979">				boolean found = false;</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">				if (QuaxUtil.isMember(oExp)) {</span>
					// Member
<span class="pc bpc" id="L982" title="1 of 2 branches missed.">					if (QuaxUtil.isDescendant(memberPath.get(dimIndex), oExp)) {</span>
<span class="nc" id="L983">						found = true;</span>
					}
				} else {
					// FunCall
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">					if (isChildOfMemberInFunCall(oExp,</span>
<span class="fc" id="L988">							memberPath.get(dimIndex), dimIndex)) {</span>
<span class="fc" id="L989">						found = true;</span>
					}
				}

<span class="fc bfc" id="L993" title="All 2 branches covered.">				if (found) {</span>
					// add this node and all parent nodes, if they are funcalls,
					// to split list
<span class="fc" id="L996">					int level = node.getLevel();</span>
<span class="fc" id="L997">					TreeNode&lt;Exp&gt; currentNode = node;</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">					while (level &gt; 0) {</span>
<span class="fc" id="L999">						Exp o = currentNode.getReference();</span>
<span class="fc bfc" id="L1000" title="All 2 branches covered.">						if (!QuaxUtil.isMember(o)) {</span>
<span class="fc" id="L1001">							List&lt;TreeNode&lt;Exp&gt;&gt; list = splitLists</span>
<span class="fc" id="L1002">									.get(level - 1);</span>
							// Funcall
<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">							if (!list.contains(currentNode)) {</span>
<span class="fc" id="L1005">								list.add(currentNode);</span>
							}
						}
<span class="fc" id="L1008">						currentNode = currentNode.getParent();</span>
<span class="fc" id="L1009">						level = currentNode.getLevel();</span>
					}
				}
<span class="fc" id="L1012">				return TreeNodeCallback.CONTINUE_SIBLING;</span>
			} // handleTreeNode
		});

		// split all FunCall nodes collected in worklist
		// start with higher levels to avoid dependency conflicts
<span class="fc bfc" id="L1018" title="All 2 branches covered.">		for (int i = pathSize - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L1019">			List&lt;TreeNode&lt;Exp&gt;&gt; list = splitLists.get(i);</span>
<span class="fc" id="L1020">			Member member = memberPath.get(i);</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">			for (TreeNode&lt;Exp&gt; node : list) {</span>
<span class="fc" id="L1022">				splitFunCall(node, member, i);</span>
			}
		}

		// remove child Paths of mPath from position tree
		// collect nodes to be deleted
<span class="fc" id="L1028">		final List&lt;TreeNode&lt;Exp&gt;&gt; removeList = new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;();</span>

<span class="fc" id="L1030">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>
			/**
			 * callback remove child nodes of member path, first collect nodes
			 * in workList
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
				// check, whether this node matches mPath
<span class="fc" id="L1037">				Exp oExp = node.getReference();</span>
<span class="fc" id="L1038">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">					if (QuaxUtil.isMember(oExp)) {</span>
<span class="fc bfc" id="L1041" title="All 2 branches covered.">						if (QuaxUtil.equalMember(oExp,</span>
<span class="fc" id="L1042">								memberPath.get(nodeIndex))) {</span>
<span class="fc" id="L1043">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="fc" id="L1045">							return TreeNodeCallback.CONTINUE_SIBLING;</span>
						}
					} else {
						// FunCall
						// cannot match as we just did the split of FunCalls
<span class="nc" id="L1050">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					}
<span class="pc bpc" id="L1052" title="1 of 2 branches missed.">				} else if (nodeIndex == dimIndex) {</span>
					// *must* be descendant of mPath[iDim] to get deleted
<span class="fc bfc" id="L1054" title="All 2 branches covered.">					if (!QuaxUtil.isMember(oExp)) {</span>
						// FunCall
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">						if (QuaxUtil.isFunCallTo(oExp, &quot;Children&quot;)) {</span>
<span class="fc" id="L1057">							Exp oMember = QuaxUtil.funCallArg(oExp, 0);</span>

<span class="fc" id="L1059">							if (QuaxUtil.expForMember(memberPath.get(dimIndex))</span>
<span class="pc bpc" id="L1060" title="1 of 2 branches missed.">									.equals(oMember)</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">									|| QuaxUtil.isDescendant(</span>
<span class="nc" id="L1062">											memberPath.get(dimIndex), oMember)) {</span>
<span class="fc" id="L1063">								removeList.add(node); // add to delete list</span>
							}
<span class="nc bnc" id="L1065" title="All 2 branches missed.">						} else if (QuaxUtil.isFunCallTo(oExp, &quot;{}&quot;)) {</span>
							// set of members may be there as result of split,
							// we will remove any descendant member from the
							// set.
							// if the set is empty thereafter, we will add the
							// node
							// to the remove list.
<span class="nc" id="L1072">							int argCount = QuaxUtil.funCallArgCount(oExp);</span>
<span class="nc" id="L1073">							List&lt;Exp&gt; removeMembers = new ArrayList&lt;Exp&gt;();</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">							for (int i = 0; i &lt; argCount; i++) {</span>
<span class="nc" id="L1075">								Exp oSetMember = QuaxUtil.funCallArg(oExp, i);</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">								if (QuaxUtil.isDescendant(</span>
<span class="nc" id="L1077">										memberPath.get(dimIndex), oSetMember)) {</span>
<span class="nc" id="L1078">									removeMembers.add(oSetMember);</span>
								}
							}
<span class="nc" id="L1081">							int nRemove = removeMembers.size();</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">							if (nRemove == argCount) {</span>
								// all memers in set are descendants, remove the
								// node
<span class="nc" id="L1085">								removeList.add(node); // add to delete list</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">							} else if (nRemove &gt; 0) {</span>
								// remove descendant nodes from set
<span class="nc" id="L1088">								Exp[] remaining = new Exp[argCount - nRemove];</span>
<span class="nc" id="L1089">								int j = 0;</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">								for (int i = 0; i &lt; argCount; i++) {</span>
<span class="nc" id="L1091">									Exp oSetMember = QuaxUtil.funCallArg(oExp,</span>
<span class="nc" id="L1092">											i);</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">									if (!removeMembers.contains(oSetMember)) {</span>
<span class="nc" id="L1094">										remaining[j++] = oSetMember;</span>
									}
								}

<span class="nc bnc" id="L1098" title="All 2 branches missed.">								if (remaining.length == 1) {</span>
<span class="nc" id="L1099">									node.setReference(remaining[0]); // single</span>
									// member
								} else {
<span class="nc" id="L1102">									Exp newSet = QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L1103">											remaining, Syntax.Braces);</span>
<span class="nc" id="L1104">									node.setReference(newSet);</span>
								}
							}
<span class="nc bnc" id="L1107" title="All 2 branches missed.">						} else if (QuaxUtil.isFunCallTo(oExp, &quot;Union&quot;)) {</span>
							// HHTASK Cleanup, always use
							// removeDescendantsFromFunCall
<span class="nc" id="L1110">							Exp oRemain = removeDescendantsFromFunCall(oExp,</span>
<span class="nc" id="L1111">									memberPath.get(dimIndex), dimIndex);</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">							if (oRemain == null) {</span>
<span class="nc" id="L1113">								removeList.add(node);</span>
							} else {
<span class="nc" id="L1115">								node.setReference(oRemain);</span>
							}
						}
<span class="fc" id="L1118">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">					} else if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">						if (QuaxUtil.isDescendant(memberPath.get(dimIndex),</span>
<span class="fc" id="L1121">								oExp)) {</span>
<span class="nc" id="L1122">							removeList.add(node);</span>
						}
					}
<span class="fc" id="L1125">					return TreeNodeCallback.CONTINUE_SIBLING;</span>
					// always break on level iDim, next sibling
				} else {
					// should never get here
<span class="nc" id="L1129">					throw new PivotException(&quot;Unexpected tree node level &quot;</span>
<span class="nc" id="L1130">							+ nodeIndex + &quot; &quot;</span>
<span class="nc" id="L1131">							+ QuaxUtil.memberString(memberPath));</span>
				}
			}
		});

		// remove nodes collected in work list
<span class="fc bfc" id="L1137" title="All 2 branches covered.">		for (TreeNode&lt;Exp&gt; nodeToRemove : removeList) {</span>
<span class="fc" id="L1138">			removePathToNode(nodeToRemove);</span>
		}

		// any dimension left and including iDim will *not* be excluded from
		// hierarchize
<span class="fc" id="L1143">		int n = nDimension - dimIndex - 1;</span>
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">		if (n &lt; nHierExclude) {</span>
<span class="nc" id="L1145">			this.nHierExclude = n;</span>
		}

<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L1149">			logger.debug(&quot;After collapse &quot; + this.toString());</span>
		}

<span class="fc" id="L1152">		fireQuaxChanged(false);</span>
<span class="fc" id="L1153">	}</span>

	/**
	 * Check, whether a member path can be collapsed this is true if there is a
	 * child position path
	 * 
	 * @param member
	 *            position path to be collapsed
	 */
	public boolean canCollapse(Member member) {
		// we only allow expand / collapse for a dimension
		// left of a &quot;sticky topcount&quot;
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">		if (!allowNavigate(member, false)) {</span>
<span class="nc" id="L1166">			return false;</span>
		}

		// first check the cache
<span class="pc bpc" id="L1170" title="1 of 2 branches missed.">		if (canCollapseMemberMap.containsKey(member)) {</span>
<span class="nc" id="L1171">			boolean canCollapse = canCollapseMemberMap.get(member);</span>
<span class="nc" id="L1172">			return canCollapse;</span>
		}

		// loop over Position Tree
		// can collapse, if we find a descendant of member
<span class="fc" id="L1177">		boolean found = findMemberChild(member);</span>

		// cache the result
<span class="fc" id="L1180">		canCollapseMemberMap.put(member, found);</span>

<span class="fc" id="L1182">		return found;</span>
	}

	/**
	 * Remove child nodes of monMember
	 * 
	 * @param member
	 *            member to be collapsed
	 */
	public void collapse(final Member member) {
<span class="pc bpc" id="L1192" title="1 of 2 branches missed.">		if (qubonMode) {</span>
<span class="nc" id="L1193">			resolveUnions();</span>

<span class="nc bnc" id="L1195" title="All 2 branches missed.">			if (logger.isDebugEnabled()) {</span>
<span class="nc" id="L1196">				logger.debug(&quot;collapse member after resolveUnions &quot;</span>
<span class="nc" id="L1197">						+ this.toString());</span>
			}
		}

<span class="fc" id="L1201">		final int dimIndex = this.dimIdx(member.getDimension());</span>

<span class="fc" id="L1203">		final List&lt;TreeNode&lt;Exp&gt;&gt; nodesForMember = new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;();</span>

		// update the position member tree
		// wherever we find a descendant node of monMember, split and remove it
		// collect all descendant nodes for monMember in workList
<span class="fc" id="L1208">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching member Path exactly
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1214">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="fc" id="L1216">					return TreeNodeCallback.CONTINUE; // we are below iDim,</span>
					// don't care
				}

				// iDimNode == iDim
				// node Exp must contain children of member[iDim]
<span class="fc" id="L1222">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">				if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">					if (QuaxUtil.isDescendant(member, oExp)) {</span>
<span class="nc" id="L1225">						nodesForMember.add(node);</span>
					}
				} else {
					// must be FunCall
<span class="pc bpc" id="L1229" title="1 of 2 branches missed.">					if (isDescendantOfMemberInFunCall(oExp, member, nodeIndex)) {</span>
<span class="fc" id="L1230">						nodesForMember.add(node);</span>
					}
				}
<span class="fc" id="L1233">				return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
				// sibling
			}
		});

<span class="fc bfc" id="L1238" title="All 2 branches covered.">		for (TreeNode&lt;Exp&gt; node : nodesForMember) {</span>
<span class="fc" id="L1239">			Exp oExp = node.getReference();</span>
<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">			if (QuaxUtil.isMember(oExp)) {</span>
<span class="nc" id="L1241">				removePathToNode(node);</span>
			} else {
				// FunCall
<span class="fc" id="L1244">				Exp oComplement = removeDescendantsFromFunCall(oExp, member,</span>
<span class="fc" id="L1245">						dimIndex);</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">				if (oComplement == null) {</span>
<span class="fc" id="L1247">					removePathToNode(node);</span>
				} else {
<span class="nc" id="L1249">					node.setReference(oComplement); // replace node object by</span>
													// complement
				}
			}
		}

<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">		if (logger.isDebugEnabled()) {</span>
<span class="fc" id="L1256">			logger.debug(&quot;After collapse &quot; + this.toString());</span>
		}

<span class="fc" id="L1259">		fireQuaxChanged(false);</span>
<span class="fc" id="L1260">	}</span>

	/**
	 * drill down is possible if there is no sticky generate
	 */
	public boolean canDrillDown(Member member) {
<span class="nc" id="L1266">		return allowNavigate(member, true);</span>
	}

	/**
	 * Drill down
	 * 
	 * @param member
	 *            drill down member
	 */
	public void drillDown(Member member) {
<span class="nc" id="L1276">		final int dimIndex = this.dimIdx(member.getDimension());</span>

		// collect the Exp's of all dimensions except iDim
<span class="nc" id="L1279">		List&lt;Exp&gt; sets = new ArrayList&lt;Exp&gt;(nDimension);</span>

<span class="nc" id="L1281">		Exp oMember = QuaxUtil.expForMember(member);</span>
<span class="nc" id="L1282">		Exp fChildren = QuaxUtil.createFunCall(&quot;Children&quot;,</span>
<span class="nc" id="L1283">				new Exp[] { oMember }, Syntax.Property);</span>

<span class="nc bnc" id="L1285" title="All 2 branches missed.">		for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">			if (i == dimIndex) {</span>
				// replace drilldown dimension by member.children
<span class="nc" id="L1288">				sets.add(fChildren);</span>
			} else {
				// generate exp for all nodes of this dimension
<span class="nc" id="L1291">				sets.add(genExpForDim(i));</span>
			}
		}

		// regenerate the position tree as crossjoin of sets
<span class="nc" id="L1296">		regeneratePosTree(sets, false);</span>

<span class="nc" id="L1298">		fireQuaxChanged(false);</span>
<span class="nc" id="L1299">	}</span>

	/**
	 * Drill up is possible if at least one member in the tree is not at the top
	 * level of this hierarchy.
	 */
	public boolean canDrillUp(Hierarchy hierarchy) {
<span class="nc" id="L1306">		final int dimIndex = this.dimIdx(hierarchy.getDimension());</span>

<span class="nc bnc" id="L1308" title="All 2 branches missed.">		if (!allowNavigate(dimIndex, true)) {</span>
<span class="nc" id="L1309">			return false;</span>
		}

<span class="nc" id="L1312">		int result = posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * Callback check for member of hierarchy not on top level
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L1318">				int nodeIndex = node.getLevel() - 1;</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="nc" id="L1320">					return TreeNodeCallback.CONTINUE;</span>
				}

				// iDimNode == workInt
<span class="nc" id="L1324">				Exp oExp = node.getReference();</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall
<span class="nc bnc" id="L1327" title="All 2 branches missed.">					if (isFunCallNotTopLevel(oExp, nodeIndex)) {</span>
<span class="nc" id="L1328">						return TreeNodeCallback.BREAK; // got it</span>
					} else {
<span class="nc" id="L1330">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					}
				} else {
					// member
<span class="nc bnc" id="L1334" title="All 2 branches missed.">					if (QuaxUtil.levelDepthForMember(oExp) &gt; 0) {</span>
<span class="nc" id="L1335">						return TreeNodeCallback.BREAK; // got it</span>
					} else {
<span class="nc" id="L1337">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					}
				}
			}
		});

<span class="nc bnc" id="L1343" title="All 2 branches missed.">		return (result == TreeNodeCallback.BREAK);</span>
	}

	/**
	 * Drill up
	 * 
	 * @param hierarchy
	 *            drill down member
	 */
	public void drillUp(Hierarchy hierarchy) {
<span class="nc" id="L1353">		int dimIndex = dimIdx(hierarchy.getDimension());</span>

		// collect the Exp's of all dimensions
<span class="nc" id="L1356">		List&lt;Exp&gt; sets = new ArrayList&lt;Exp&gt;(nDimension);</span>

<span class="nc bnc" id="L1358" title="All 2 branches missed.">		for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">			if (i == dimIndex) {</span>
				// replace drillup dimension by drillup set
<span class="nc" id="L1361">				sets.add(drillupExp(dimIndex, hierarchy));</span>
			} else {
<span class="nc" id="L1363">				sets.add(genExpForDim(i));</span>
			}
		}

		// regenerate the position tree as crossjoin of sets
<span class="nc" id="L1368">		regeneratePosTree(sets, false);</span>

<span class="nc" id="L1370">		fireQuaxChanged(false);</span>
<span class="nc" id="L1371">	}</span>

	/**
	 * MDX Generation generate Exp from tree
	 * 
	 * @return Exp for axis set
	 */
	public Exp genExp(boolean genHierarchize) {
<span class="pc bpc" id="L1379" title="3 of 4 branches missed.">		if (generateMode != CalcSetMode.Simple &amp;&amp; generateIndex &gt; 0) {</span>
<span class="nc" id="L1380">			return genGenerateExp(genHierarchize);</span>
		} else {
<span class="fc" id="L1382">			return genNormalExp(genHierarchize);</span>
		}
	}

	/**
	 * Normal MDX Generation - no Generate
	 * 
	 * @return Exp for axis set
	 */
	private Exp genNormalExp(boolean genHierarchize) {
<span class="fc" id="L1392">		ExpGenerator expGenerator = new ExpGenerator();</span>

<span class="fc bfc" id="L1394" title="All 2 branches covered.">		if (!genHierarchize) {</span>
			// no Hierarchize
<span class="fc" id="L1396">			expGenerator.init(posTreeRoot, hiers.size());</span>
<span class="fc" id="L1397">			return expGenerator.generate();</span>
		}

		// do we need a special hierarchize ?
		// this will be true, if nHierExclude &gt; 0
<span class="pc bpc" id="L1402" title="1 of 2 branches missed.">		if (nHierExclude == 0) {</span>
			// no special hierarchize needed
<span class="fc" id="L1404">			expGenerator.init(posTreeRoot, hiers.size());</span>

<span class="fc" id="L1406">			Exp exp = expGenerator.generate();</span>
			// Hierarchize around &quot;everything&quot;
<span class="fc" id="L1408">			return QuaxUtil.createFunCall(&quot;Hierarchize&quot;, new Exp[] { exp },</span>
<span class="fc" id="L1409">					Syntax.Function);</span>
		}

		// special hierarchize to be generated
		// the Qubon Mode Hierarchies are factored out,
		// as they consist only of a single set of members.
		// the left expression will be generated and then hierarchized,
		// *before* beeing crossjoined to the right Expression.
<span class="nc" id="L1417">		return genLeftRight(expGenerator, nDimension - nHierExclude,</span>
<span class="nc" id="L1418">				nHierExclude);</span>
	}

	/**
	 * Generate an expression with hierarchize for the hierarchies &lt;
	 * nHierExclude without hierarchize for the hierarchies &gt;= nHierExclude
	 */
	private Exp genLeftRight(ExpGenerator expGenerator, int leftDepth,
			int rightDepth) {
		// generate left expression to be hierarchized
<span class="nc" id="L1428">		Exp leftExp = null;</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">		if (leftDepth &gt; 0) {</span>
<span class="nc" id="L1430">			TreeNode&lt;Exp&gt; leftRoot = posTreeRoot.deepCopyPrune(leftDepth);</span>
<span class="nc" id="L1431">			leftRoot.setReference(null);</span>

<span class="nc" id="L1433">			List&lt;Hierarchy&gt; leftHiers = new ArrayList&lt;Hierarchy&gt;(leftDepth);</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">			for (int i = 0; i &lt; leftDepth; i++) {</span>
<span class="nc" id="L1435">				leftHiers.add(hiers.get(i));</span>
			}

<span class="nc" id="L1438">			expGenerator.init(leftRoot, leftHiers.size());</span>

<span class="nc" id="L1440">			leftExp = QuaxUtil.createFunCall(&quot;Hierarchize&quot;,</span>
<span class="nc" id="L1441">					new Exp[] { expGenerator.generate() }, Syntax.Function);</span>
		}

		// generate the right expression, not to be hierarchized
<span class="nc" id="L1445">		Exp rightExp = null;</span>

<span class="nc" id="L1447">		List&lt;Hierarchy&gt; rightHiers = new ArrayList&lt;Hierarchy&gt;(rightDepth);</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">		for (int i = 0; i &lt; rightDepth; i++) {</span>
<span class="nc" id="L1449">			rightHiers.add(hiers.get(leftDepth + i));</span>
		}

		// go down to the first hier to be excluded from hierarchize
		// note: the subtree tree under any node of the hierarchy above
		// is always the same, so we can replicate any subtree under
		// a node of hierarchy nLeft-1
<span class="nc" id="L1456">		TreeNode&lt;Exp&gt; rightRoot = new TreeNode&lt;Exp&gt;(null);</span>
<span class="nc" id="L1457">		TreeNode&lt;Exp&gt; current = posTreeRoot;</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">		for (int i = 0; i &lt; leftDepth; i++) {</span>
<span class="nc" id="L1459">			List&lt;TreeNode&lt;Exp&gt;&gt; list = current.getChildren();</span>
<span class="nc" id="L1460">			current = list.get(0);</span>
		}

<span class="nc" id="L1463">		List&lt;TreeNode&lt;Exp&gt;&gt; list = current.getChildren();</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">		for (TreeNode&lt;Exp&gt; node : list) {</span>
<span class="nc" id="L1465">			rightRoot.addChild(node.deepCopy());</span>
		}

<span class="nc" id="L1468">		expGenerator.init(rightRoot, rightHiers.size());</span>

<span class="nc" id="L1470">		rightExp = expGenerator.generate();</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">		if (leftExp == null) {</span>
<span class="nc" id="L1472">			return rightExp;</span>
		}

<span class="nc" id="L1475">		Exp exp = QuaxUtil.createFunCall(&quot;CrossJoin&quot;, new Exp[] { leftExp,</span>
<span class="nc" id="L1476">				rightExp }, Syntax.Function);</span>

<span class="nc" id="L1478">		return exp;</span>
	}

	/**
	 * MDX Generation for Generate
	 * 
	 * @return Exp for axis set
	 */
	private Exp genGenerateExp(boolean genHierarchize) {
<span class="nc" id="L1487">		ExpGenerator expGenerator = new ExpGenerator();</span>

		// Generate(GSet, FSet) to be generated
		// hierarchies &gt;= generateIndex will not be &quot;hierarchized&quot;
		// we expect the hierarchies &gt;= generateIndex to be excluded
		// from hierarchize.
<span class="nc bnc" id="L1493" title="All 4 branches missed.">		if (nDimension - generateIndex &gt; nHierExclude &amp;&amp; logger.isWarnEnabled()) {</span>
<span class="nc" id="L1494">			logger.warn(&quot;Unexpected values: nHierExclude=&quot; + nHierExclude</span>
<span class="nc" id="L1495">					+ &quot; generateIndex=&quot; + generateIndex);</span>
		}

		// assume following situation:
		// 3 hierarchies
		// time - customers - product
		// we want top 5 customers, generated for each time member
		// 1. step
		// generate expression until customers (only time here), result = set1
		// if neccessary, put hierarchize around
		// 2. step
		// Generate(set1, Topcount(Crossjoin ({Time.Currentmember}, Set for
		// Customers),
		// 5, condition))
		// result = set2
		// 3.step
		// append the tail nodes , here Product
		// Crossjoin(set2 , Product dimension nodes)
		//
		// 1. step left expression, potentially hierarchized

<span class="nc" id="L1516">		Exp leftExp = null;</span>
		// if nHierExclude &gt; nDimension - generateIndex
		// and nHierExclude &lt; nDimension
		// the the left expression (inside Generate) will be partly
		// hierarchized
<span class="nc bnc" id="L1521" title="All 4 branches missed.">		if (genHierarchize &amp;&amp; nHierExclude &gt; nDimension - generateIndex</span>
<span class="nc bnc" id="L1522" title="All 2 branches missed.">				&amp;&amp; nHierExclude &lt; nDimension) {</span>
<span class="nc" id="L1523">			int leftDepth = nDimension - nHierExclude;</span>
<span class="nc" id="L1524">			int rightDepth = generateIndex - leftDepth;</span>

<span class="nc" id="L1526">			leftExp = genLeftRight(expGenerator, leftDepth, rightDepth);</span>
		} else {
<span class="nc" id="L1528">			TreeNode&lt;Exp&gt; leftRoot = posTreeRoot.deepCopyPrune(generateIndex);</span>
<span class="nc" id="L1529">			leftRoot.setReference(null);</span>

<span class="nc" id="L1531">			List&lt;Hierarchy&gt; leftHiers = new ArrayList&lt;Hierarchy&gt;(generateIndex);</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">			for (int i = 0; i &lt; generateIndex; i++) {</span>
<span class="nc" id="L1533">				leftHiers.add(hiers.get(i));</span>
			}

<span class="nc" id="L1536">			expGenerator.init(leftRoot, leftHiers.size());</span>
<span class="nc" id="L1537">			leftExp = expGenerator.generate();</span>

<span class="nc bnc" id="L1539" title="All 2 branches missed.">			if (genHierarchize) {</span>
<span class="nc" id="L1540">				leftExp = QuaxUtil.createFunCall(&quot;Hierarchize&quot;,</span>
<span class="nc" id="L1541">						new Exp[] { leftExp }, Syntax.Function);</span>
			}
		}

		// 2. step Generate(set1, Topcount())
<span class="nc" id="L1546">		TreeNode&lt;Exp&gt; topCountNode = posTreeRoot;</span>
		// top count node can be anything like topcount, bottomcount, filter
<span class="nc bnc" id="L1548" title="All 2 branches missed.">		for (int i = 0; i &lt;= generateIndex; i++) {</span>
			// the path to the topcount node at generateIndex does not matter
<span class="nc" id="L1550">			List&lt;TreeNode&lt;Exp&gt;&gt; children = topCountNode.getChildren();</span>
<span class="nc" id="L1551">			topCountNode = children.get(0);</span>
		}

<span class="nc" id="L1554">		Exp topcount = topCountNode.getReference();</span>
		// we have to replace the &quot;set&quot; of the topcount function
<span class="nc" id="L1556">		Exp origTopcountSet = QuaxUtil.funCallArg(topcount, 0);</span>

		// generate the Tuple of dimension.currentmember until generateIndex
<span class="nc" id="L1559">		Exp currentMembersTuple = genCurrentTuple();</span>
<span class="nc" id="L1560">		Exp ocj = QuaxUtil.createFunCall(&quot;Crossjoin&quot;, new Exp[] {</span>
<span class="nc" id="L1561">				currentMembersTuple, origTopcountSet }, Syntax.Function);</span>

		// replace the topcout original set
<span class="nc" id="L1564">		String fun = QuaxUtil.funCallName(topcount);</span>

<span class="nc" id="L1566">		int n = QuaxUtil.funCallArgCount(topcount);</span>
<span class="nc" id="L1567">		Exp[] args = new Exp[n];</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">		for (int i = 1; i &lt; n; i++) {</span>
<span class="nc" id="L1569">			args[i] = QuaxUtil.funCallArg(topcount, i);</span>
		}

<span class="nc" id="L1572">		args[0] = ocj;</span>

<span class="nc" id="L1574">		Exp newTopcount = QuaxUtil.createFunCall(fun, args, Syntax.Function);</span>
<span class="nc" id="L1575">		Exp oGenerate = QuaxUtil.createFunCall(&quot;Generate&quot;, new Exp[] { leftExp,</span>
<span class="nc" id="L1576">				newTopcount }, Syntax.Function);</span>

<span class="nc bnc" id="L1578" title="All 2 branches missed.">		if (generateIndex + 1 == nDimension) {</span>
<span class="nc" id="L1579">			return oGenerate;</span>
		}

		// 3. step append the tail nodes
		// generate CrossJoin
<span class="nc" id="L1584">		int nRight = nDimension - generateIndex - 1;</span>
<span class="nc" id="L1585">		Hierarchy[] rightHiers = new Hierarchy[nRight];</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">		for (int i = 1; i &lt;= nRight; i++) {</span>
<span class="nc" id="L1587">			rightHiers[nRight - i] = hiers.get(nDimension - i);</span>
		}

<span class="nc" id="L1590">		TreeNode&lt;Exp&gt; root = new TreeNode&lt;Exp&gt;(null);</span>
<span class="nc" id="L1591">		List&lt;TreeNode&lt;Exp&gt;&gt; list = topCountNode.getChildren();</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">		for (TreeNode&lt;Exp&gt; node : list) {</span>
<span class="nc" id="L1593">			root.addChild(node.deepCopy());</span>
		}

<span class="nc" id="L1596">		expGenerator.init(root, rightHiers.length);</span>
<span class="nc" id="L1597">		Exp rightExp = expGenerator.generate();</span>

<span class="nc" id="L1599">		Exp exp = QuaxUtil.createFunCall(&quot;CrossJoin&quot;, new Exp[] { oGenerate,</span>
<span class="nc" id="L1600">				rightExp }, Syntax.Function);</span>

<span class="nc" id="L1602">		return exp;</span>
	}

	/**
	 * Generate {(dim1.Currentmember, dim2.Currentmember, ... )}
	 */
	private Exp genCurrentTuple() {
<span class="nc" id="L1609">		Exp[] currentsOfDim = new Exp[generateIndex];</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">		for (int i = 0; i &lt; currentsOfDim.length; i++) {</span>
<span class="nc" id="L1611">			Dimension dim = hiers.get(i).getDimension();</span>

<span class="nc" id="L1613">			currentsOfDim[i] = QuaxUtil.createFunCall(&quot;CurrentMember&quot;,</span>
<span class="nc" id="L1614">					new Exp[] { QuaxUtil.expForDim(dim) }, Syntax.Property);</span>
		}

		Exp oTuple;
<span class="nc bnc" id="L1618" title="All 2 branches missed.">		if (generateIndex &gt; 1) {</span>
<span class="nc" id="L1619">			oTuple = QuaxUtil.createFunCall(&quot;()&quot;, currentsOfDim,</span>
<span class="nc" id="L1620">					Syntax.Parentheses);</span>
		} else {
<span class="nc" id="L1622">			oTuple = currentsOfDim[0]; // just dimension.currentmember</span>
		}

		// generate set braces around tuple
<span class="nc" id="L1626">		Exp oSet = QuaxUtil.createFunCall(&quot;{}&quot;, new Exp[] { oTuple },</span>
<span class="nc" id="L1627">				Syntax.Braces);</span>

<span class="nc" id="L1629">		return oSet;</span>
	}

	/**
	 * @return true if child position can be found
	 */
	private boolean checkChildPosition(final List&lt;Member&gt; memberPath) {

<span class="fc" id="L1637">		int result = posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching member Path exactly
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1643">				int dimIndex = memberPath.size() - 1;</span>
<span class="fc" id="L1644">				int nodeIndex = node.getLevel() - 1;</span>

<span class="fc" id="L1646">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L1647" title="All 2 branches covered.">				if (nodeIndex &lt; dimIndex) {</span>
					// node Exp must match member[iDim]
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">					if (QuaxUtil.isMember(oExp)) {</span>
<span class="fc bfc" id="L1650" title="All 2 branches covered.">						if (QuaxUtil.equalMember(oExp,</span>
<span class="fc" id="L1651">								memberPath.get(nodeIndex))) {</span>
<span class="fc" id="L1652">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="fc" id="L1654">							return TreeNodeCallback.CONTINUE_SIBLING; // continue</span>
							// next
							// sibling
						}
					} else {
						// must be FunCall
<span class="nc bnc" id="L1660" title="All 2 branches missed.">						if (isMemberInFunCall(oExp, memberPath.get(nodeIndex),</span>
<span class="nc" id="L1661">								nodeIndex)) {</span>
<span class="nc" id="L1662">							return TreeNodeCallback.CONTINUE;</span>
						} else {
<span class="nc" id="L1664">							return TreeNodeCallback.CONTINUE_SIBLING; // continue</span>
							// next
							// sibling
						}
					}
				}

				// iDimNode == iDim
				// node Exp must contain children of member[iDim]
<span class="fc bfc" id="L1673" title="All 2 branches covered.">				if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L1674" title="1 of 2 branches missed.">					if (QuaxUtil.checkParent(memberPath.get(nodeIndex), oExp)) {</span>
<span class="nc" id="L1675">						return TreeNodeCallback.BREAK; // found</span>
					} else {
<span class="fc" id="L1677">						return TreeNodeCallback.CONTINUE_SIBLING; // continue</span>
						// next
						// sibling
					}
				} else {
					// must be FunCall
<span class="fc bfc" id="L1683" title="All 2 branches covered.">					if (isChildOfMemberInFunCall(oExp,</span>
<span class="fc" id="L1684">							memberPath.get(nodeIndex), nodeIndex)) {</span>
<span class="fc" id="L1685">						return TreeNodeCallback.BREAK; // found</span>
					} else {
<span class="fc" id="L1687">						return TreeNodeCallback.CONTINUE_SIBLING; // continue</span>
						// next
						// sibling
					}
				}
			}
		});

<span class="fc bfc" id="L1695" title="All 2 branches covered.">		return (result == TreeNodeCallback.BREAK);</span>
	}

	/**
	 * Resolve the qubon mode unions and crossjoins only used in &quot;old&quot; expand
	 * mode
	 */
	private void resolveUnions() {
<span class="nc" id="L1703">		final List&lt;List&lt;Exp&gt;&gt; setLists = new ArrayList&lt;List&lt;Exp&gt;&gt;(nDimension);</span>

<span class="nc bnc" id="L1705" title="All 2 branches missed.">		for (int i = 0; i &lt; nDimension; i++) {</span>
<span class="nc" id="L1706">			setLists.add(new ArrayList&lt;Exp&gt;());</span>
		}

<span class="nc" id="L1709">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback resolve sets of any dimension
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L1715">				int nodeIndex = node.getLevel() - 1;</span>
<span class="nc" id="L1716">				Exp oExp = node.getReference();</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall
<span class="nc" id="L1719">					funToList(oExp, setLists.get(nodeIndex));</span>
				} else {
					// member
<span class="nc" id="L1722">					setLists.get(nodeIndex).add(oExp);</span>
				}
<span class="nc" id="L1724">				return TreeNodeCallback.CONTINUE;</span>
			}
		});

		// unions and sets are resolved, now resolve crossjoins
<span class="nc" id="L1729">		this.posTreeRoot = new TreeNode&lt;Exp&gt;(null);</span>
<span class="nc" id="L1730">		crossJoinTree(setLists, posTreeRoot, 0);</span>

<span class="nc" id="L1732">		this.qubonMode = false;</span>
<span class="nc" id="L1733">	}</span>

	/**
	 * Find the best tree node for member path (longest match)
	 */
	private TreeNode&lt;Exp&gt; findBestNode(final List&lt;Member&gt; memberPath) {
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L1740">		final TreeNode&lt;Exp&gt;[] bestNode = new TreeNode[1];</span>
<span class="fc" id="L1741">		bestNode[0] = posTreeRoot;</span>

<span class="fc" id="L1743">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching member Path exactly
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1749">				int dimIndex = memberPath.size() - 1;</span>
<span class="fc" id="L1750">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc" id="L1751">				Exp oExp = node.getReference();</span>

<span class="pc bpc" id="L1753" title="1 of 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
<span class="nc" id="L1754">					return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
					// sibling
				}

<span class="pc bpc" id="L1758" title="1 of 2 branches missed.">				if (QuaxUtil.equalMember(oExp, memberPath.get(nodeIndex))) {</span>
					// match
<span class="fc bfc" id="L1760" title="All 2 branches covered.">					if (nodeIndex == dimIndex) {</span>
						// found exactly matching node
<span class="fc" id="L1762">						bestNode[0] = node;</span>
<span class="fc" id="L1763">						return TreeNodeCallback.BREAK;</span>
					} else {
						// best match up to now
<span class="fc" id="L1766">						bestNode[0] = node;</span>
<span class="fc" id="L1767">						return TreeNodeCallback.CONTINUE;</span>
					}
				} else {
					// no match
<span class="nc" id="L1771">					return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
					// sibling
				}
			}
		});

<span class="fc" id="L1777">		return bestNode[0];</span>
	}

	/**
	 * Collect tail nodes for all nodes matching member path
	 */
	private List&lt;TreeNode&lt;Exp&gt;&gt; collectTailNodes(TreeNode&lt;Exp&gt; startNode,
			final List&lt;Member&gt; memberPath) {

<span class="nc" id="L1786">		final List&lt;TreeNode&lt;Exp&gt;&gt; tailNodes = new ArrayList&lt;TreeNode&lt;Exp&gt;&gt;();</span>
<span class="nc" id="L1787">		startNode.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find node matching mPath collect tail nodes
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L1793">				int dimIndex = memberPath.size() - 1;</span>
<span class="nc" id="L1794">				int nodeIndex = node.getLevel() - 1;</span>

<span class="nc" id="L1796">				Exp oExp = node.getReference();</span>
<span class="nc" id="L1797">				boolean match = false;</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">				if (QuaxUtil.isMember(oExp)) {</span>
					// exp is member
<span class="nc bnc" id="L1800" title="All 2 branches missed.">					if (QuaxUtil.equalMember(oExp, memberPath.get(nodeIndex))) {</span>
<span class="nc" id="L1801">						match = true;</span>
					}
				} else {
					// must be FunCall
<span class="nc bnc" id="L1805" title="All 2 branches missed.">					if (isMemberInFunCall(oExp, memberPath.get(nodeIndex),</span>
<span class="nc" id="L1806">							nodeIndex)) {</span>
<span class="nc" id="L1807">						match = true;</span>
					}
				}

<span class="nc bnc" id="L1811" title="All 2 branches missed.">				if (match) {</span>
<span class="nc bnc" id="L1812" title="All 2 branches missed.">					if (nodeIndex == dimIndex) {</span>
						// add the children to the tail list
<span class="nc" id="L1814">						tailNodes.addAll(node.getChildren());</span>
<span class="nc" id="L1815">						return TreeNodeCallback.CONTINUE_SIBLING;</span>
					} else {
						// iDimNode &lt; iDim
<span class="nc" id="L1818">						return TreeNodeCallback.CONTINUE;</span>
					}
				} else
<span class="nc" id="L1821">					return TreeNodeCallback.CONTINUE_SIBLING; // no match,</span>
				// continue next
				// sibling
			}
		});

<span class="nc" id="L1827">		return tailNodes;</span>
	}

	private boolean findMemberChild(final Member member) {
<span class="fc" id="L1831">		final int iDim = this.dimIdx(member.getDimension());</span>

<span class="fc" id="L1833">		int result = posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback find child node of member
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L1839">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc bfc" id="L1840" title="All 2 branches covered.">				if (nodeIndex &lt; iDim) {</span>
<span class="fc" id="L1841">					return TreeNodeCallback.CONTINUE; // we are below iDim,</span>
					// don't care
				}

				// iDimNode == iDim
				// node Exp must contain children of member[iDim]
<span class="fc" id="L1847">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L1848" title="All 2 branches covered.">				if (QuaxUtil.isMember(oExp)) {</span>
<span class="pc bpc" id="L1849" title="1 of 2 branches missed.">					if (QuaxUtil.checkParent(member, oExp)) {</span>
<span class="nc" id="L1850">						return TreeNodeCallback.BREAK; // found</span>
					}
				} else {
					// must be FunCall
<span class="pc bpc" id="L1854" title="1 of 2 branches missed.">					if (isChildOfMemberInFunCall(oExp, member, nodeIndex)) {</span>
<span class="fc" id="L1855">						return TreeNodeCallback.BREAK; // found</span>
					}
				}
<span class="fc" id="L1858">				return TreeNodeCallback.CONTINUE_SIBLING; // continue next</span>
				// sibling
			}
		});

<span class="fc bfc" id="L1863" title="All 2 branches covered.">		return (result == TreeNodeCallback.BREAK);</span>
	}

	/**
	 * Build tree resolving crossjoin
	 * 
	 * @param currentNode
	 * @param dimIndex
	 */
	private void crossJoinTree(List&lt;List&lt;Exp&gt;&gt; setLists,
			TreeNode&lt;Exp&gt; currentNode, int dimIndex) {
<span class="nc bnc" id="L1874" title="All 2 branches missed.">		for (Exp oExp : setLists.get(dimIndex)) {</span>
<span class="nc" id="L1875">			TreeNode&lt;Exp&gt; newNode = new TreeNode&lt;Exp&gt;(oExp);</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">			if (dimIndex &lt; nDimension - 1) {</span>
<span class="nc" id="L1877">				crossJoinTree(setLists, newNode, dimIndex + 1);</span>
			}

<span class="nc" id="L1880">			currentNode.addChild(newNode);</span>
		}
<span class="nc" id="L1882">	}</span>

	/**
	 * Split Funcall to node and complement
	 */
	private void splitFunCall(TreeNode&lt;Exp&gt; funCall, Member member,
			int hierIndex) {
<span class="fc" id="L1889">		Exp oExp = funCall.getReference();</span>

		// it is possible (if the split member is of dimension to be collapsed),
		// that this funcall does not contain member.
		// Then - there is nothing to split.
<span class="pc bpc" id="L1894" title="1 of 2 branches missed.">		if (!isMemberInFunCall(oExp, member, funCall.getLevel() - 1)) {</span>
<span class="fc" id="L1895">			return; // nothing to split</span>
		}

<span class="nc" id="L1898">		Exp oComplement = createComplement(oExp, member, hierIndex); // can be</span>
																		// null
<span class="nc bnc" id="L1900" title="All 2 branches missed.">		if (oComplement == null) {</span>
			// this means, that the set resolves to a single member,
			// mPath[iDimNode]
<span class="nc" id="L1903">			funCall.setReference(QuaxUtil.expForMember(member));</span>
			// nothing to split
<span class="nc" id="L1905">			return;</span>
		}

		// split the Funcall
<span class="nc" id="L1909">		TreeNode&lt;Exp&gt; newNodeComplement = new TreeNode&lt;Exp&gt;(oComplement);</span>
<span class="nc" id="L1910">		TreeNode&lt;Exp&gt; newNodeMember = new TreeNode&lt;Exp&gt;(</span>
<span class="nc" id="L1911">				QuaxUtil.expForMember(member));</span>

		// add the children
<span class="nc bnc" id="L1914" title="All 2 branches missed.">		for (TreeNode&lt;Exp&gt; child : funCall.getChildren()) {</span>
<span class="nc" id="L1915">			newNodeComplement.addChild(child.deepCopy());</span>
<span class="nc" id="L1916">			newNodeMember.addChild(child.deepCopy());</span>
		}

<span class="nc" id="L1919">		TreeNode&lt;Exp&gt; insert = funCall.getParent();</span>
<span class="nc" id="L1920">		funCall.remove();</span>

<span class="nc" id="L1922">		insert.addChild(newNodeComplement);</span>
<span class="nc" id="L1923">		insert.addChild(newNodeMember);</span>
<span class="nc" id="L1924">	}</span>

	/**
	 * Remove Children node
	 * 
	 * @param nodeToRemove
	 */
	private void removePathToNode(TreeNode&lt;Exp&gt; nodeToRemove) {
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">		if (nodeToRemove.getParent().getChildren().size() &gt; 1) {</span>
			// this node has siblings, just remove it
<span class="fc" id="L1934">			nodeToRemove.remove();</span>
		} else {
			// no siblings, remove the first parent node having siblings
<span class="nc" id="L1937">			TreeNode&lt;Exp&gt; parent = nodeToRemove.getParent();</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">			while (parent.getParent().getChildren().size() == 1) {</span>
<span class="nc" id="L1939">				parent = parent.getParent();</span>
			}

<span class="nc bnc" id="L1942" title="All 2 branches missed.">			if (parent.getLevel() &gt; 0) { // should always be true</span>
<span class="nc" id="L1943">				parent.remove();</span>
			}
		}
<span class="fc" id="L1946">	}</span>

	/**
	 * generate Exp for all nodes of dimension iDimension
	 * 
	 * @param dimIndex
	 * @return Exp for all nodes
	 */
	public Exp genExpForDim(int dimIndex) {
		// if we got a generate function on this hier, preserve it
<span class="nc bnc" id="L1956" title="All 4 branches missed.">		if (generateIndex &gt;= 0 &amp;&amp; generateIndex == dimIndex</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">				&amp;&amp; generateMode != CalcSetMode.Simple) {</span>
<span class="nc" id="L1958">			TreeNode&lt;Exp&gt; topCountNode = posTreeRoot.getChildren().get(0);</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">			for (int i = 0; i &lt; generateIndex; i++) {</span>
				// the path to the topcount node at generateIndex does not
				// matter
<span class="nc" id="L1962">				List&lt;TreeNode&lt;Exp&gt;&gt; children = topCountNode.getChildren();</span>
<span class="nc" id="L1963">				topCountNode = children.get(0);</span>
			}

<span class="nc" id="L1966">			Exp topcount = topCountNode.getReference();</span>

<span class="nc" id="L1968">			SetExp setexp = new SetExp(generateMode, topcount,</span>
<span class="nc" id="L1969">					hiers.get(dimIndex));</span>

<span class="nc" id="L1971">			return setexp;</span>
		}

<span class="nc" id="L1974">		List&lt;Exp&gt; funCallList = collectFunCalls(dimIndex);</span>
<span class="nc" id="L1975">		List&lt;Exp&gt; memberList = collectMembers(dimIndex);</span>

<span class="nc" id="L1977">		cleanupMemberList(funCallList, memberList, dimIndex);</span>

<span class="nc bnc" id="L1979" title="All 4 branches missed.">		if (funCallList.isEmpty() &amp;&amp; memberList.size() == 1) {</span>
<span class="nc" id="L1980">			return memberList.get(0); // single member only</span>
		}

<span class="nc" id="L1983">		Exp mSet = null;</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">		if (memberList.size() &gt; 0) {</span>
<span class="nc" id="L1985">			Exp[] aExp = memberList.toArray(new Exp[0]);</span>
<span class="nc" id="L1986">			mSet = QuaxUtil.createFunCall(&quot;{}&quot;, aExp, Syntax.Braces);</span>
		}

<span class="nc bnc" id="L1989" title="All 2 branches missed.">		if (funCallList.isEmpty()) {</span>
<span class="nc" id="L1990">			return mSet;</span>
		}

<span class="nc bnc" id="L1993" title="All 4 branches missed.">		if (funCallList.size() == 1 &amp;&amp; mSet == null) {</span>
<span class="nc" id="L1994">			return funCallList.get(0);</span>
		}

		Exp set;

		int start;
<span class="nc bnc" id="L2000" title="All 2 branches missed.">		if (mSet != null) {</span>
<span class="nc" id="L2001">			set = mSet;</span>
<span class="nc" id="L2002">			start = 0;</span>
		} else {
<span class="nc" id="L2004">			set = funCallList.get(0);</span>
<span class="nc" id="L2005">			start = 1;</span>
		}
<span class="nc bnc" id="L2007" title="All 2 branches missed.">		for (int j = start; j &lt; funCallList.size(); j++) {</span>
<span class="nc" id="L2008">			set = QuaxUtil.createFunCall(&quot;Union&quot;,</span>
<span class="nc" id="L2009">					new Exp[] { set, funCallList.get(j) }, Syntax.Function);</span>
		}

<span class="nc" id="L2012">		return set;</span>
	}

	/**
	 * Create drillup expression for dimension
	 * 
	 * @param dimIndex
	 *            dimension to be drilled up
	 * @return
	 */
	private Exp drillupExp(int dimIndex, Hierarchy hierarchy) {
		// the drillup logic is:
		// for all members of this dimension find the deepest level.
		// find the members of this deepest level
		// find the grandfathers of those deepest members
		// drill up goes to the children of those grandfathers.
		// special cases:
		// the deepest level has all members (level.members)
		// the drillup goes to parent_level.members

<span class="nc" id="L2032">		final int[] maxLevel = new int[1];</span>
<span class="nc" id="L2033">		maxLevel[0] = 0;</span>

<span class="nc" id="L2035">		List&lt;Exp&gt; drillupList = collectDrillup(dimIndex, maxLevel);</span>

<span class="nc" id="L2037">		Exp expForHier = null;</span>
<span class="nc bnc" id="L2038" title="All 2 branches missed.">		if (maxLevel[0] == 0) {</span>
			// drillup goes to top level members
			// we generate an explicit member set rather than level.members
			// usually, this is a single member &quot;All xy&quot;
<span class="nc" id="L2042">			expForHier = QuaxUtil.topLevelMembers(hierarchy, false);</span>
		} else {
<span class="nc bnc" id="L2044" title="All 2 branches missed.">			if (drillupList.size() == 1) {</span>
<span class="nc" id="L2045">				expForHier = drillupList.get(0);</span>
			} else {
				// more than 1 set expression , need union
<span class="nc bnc" id="L2048" title="All 2 branches missed.">				for (Exp oExp : drillupList) {</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">					if (expForHier == null) {</span>
<span class="nc" id="L2050">						expForHier = oExp;</span>
					} else {
<span class="nc" id="L2052">						expForHier = QuaxUtil.createFunCall(&quot;Union&quot;, new Exp[] {</span>
<span class="nc" id="L2053">								expForHier, oExp }, Syntax.Function);</span>
					}
				}
			}
		}

<span class="nc" id="L2059">		return expForHier;</span>
	}

	/**
	 * Collect drillup Exps of dimension i
	 * 
	 * @param dimIndex
	 */
	private List&lt;Exp&gt; collectDrillup(final int dimIndex, final int[] maxLevel) {
<span class="nc" id="L2068">		final List&lt;Exp&gt; drillupList = new ArrayList&lt;Exp&gt;();</span>

<span class="nc" id="L2070">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback collect GrandFathers of deepest for dimension workInt
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L2076">				int nodeIndex = node.getLevel() - 1;</span>
<span class="nc bnc" id="L2077" title="All 2 branches missed.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="nc" id="L2078">					return TreeNodeCallback.CONTINUE;</span>
				}

				// iDimNode == workInt
<span class="nc" id="L2082">				Exp oExp = node.getReference();</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall
<span class="nc" id="L2085">					addFunCallToDrillup(drillupList, oExp, maxLevel);</span>
				} else {
					// member
<span class="nc" id="L2088">					Member m = QuaxUtil.memberForExp(oExp);</span>
<span class="nc" id="L2089">					QuaxUtil.addMemberUncles(drillupList, m, maxLevel);</span>
				}

<span class="nc" id="L2092">				return TreeNodeCallback.CONTINUE_SIBLING;</span>
			}
		});

<span class="nc" id="L2096">		return drillupList;</span>
	}

	/**
	 * Collect FunCalls of dimension iDim
	 * 
	 * @param dimIndex
	 */
	private List&lt;Exp&gt; collectFunCalls(final int dimIndex) {
<span class="nc bnc" id="L2105" title="All 2 branches missed.">		if (posTreeRoot == null) {</span>
<span class="nc" id="L2106">			return Collections.emptyList();</span>
		}

<span class="nc" id="L2109">		final List&lt;Exp&gt; funCalls = new ArrayList&lt;Exp&gt;();</span>
<span class="nc" id="L2110">		final List&lt;String&gt; uniqueNames = new ArrayList&lt;String&gt;();</span>

<span class="nc" id="L2112">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback collect Funcalls of dimension workInt
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L2118">				int nodeIndex = node.getLevel() - 1;</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="nc" id="L2120">					return TreeNodeCallback.CONTINUE;</span>
				}

				// iDimNode == workInt
<span class="nc" id="L2124">				Exp oExp = node.getReference();</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall need unique representation in order to avoid
					// doubles
<span class="nc" id="L2128">					String unique = QuaxUtil.funString(oExp).toString();</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">					if (!uniqueNames.contains(unique)) {</span>
<span class="nc" id="L2130">						funCalls.add(oExp);</span>
<span class="nc" id="L2131">						uniqueNames.add(unique);</span>
					}
				}

<span class="nc" id="L2135">				return TreeNodeCallback.CONTINUE_SIBLING;</span>
			}
		});

<span class="nc" id="L2139">		return funCalls;</span>
	}

	/**
	 * Remove members from member list being in FunCall list
	 * 
	 * @param funCalls
	 * @param memberList
	 * @param dimIndex
	 */
	private void cleanupMemberList(List&lt;Exp&gt; funCalls, List&lt;Exp&gt; memberList,
			int dimIndex) {
<span class="nc bnc" id="L2151" title="All 4 branches missed.">		if (!funCalls.isEmpty() &amp;&amp; !memberList.isEmpty()) {</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">			MemberLoop: for (Iterator&lt;Exp&gt; itMem = memberList.iterator(); itMem</span>
<span class="nc" id="L2153">					.hasNext();) {</span>
<span class="nc" id="L2154">				Exp oMember = itMem.next();</span>

<span class="nc" id="L2156">				Member m = QuaxUtil.memberForExp(oMember);</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">				for (Iterator&lt;Exp&gt; itFun = funCalls.iterator(); itFun.hasNext();) {</span>
<span class="nc" id="L2158">					Exp oFun = itFun.next();</span>
<span class="nc bnc" id="L2159" title="All 2 branches missed.">					if (isMemberInFunCall(oFun, m, dimIndex)) {</span>
<span class="nc" id="L2160">						itMem.remove();</span>
<span class="nc" id="L2161">						continue MemberLoop;</span>
					}
				}
			}
		}
<span class="nc" id="L2166">	}</span>

	/**
	 * Collect Members of dimension iDim
	 * 
	 * @param dimIndex
	 */
	private List&lt;Exp&gt; collectMembers(final int dimIndex) {
<span class="nc bnc" id="L2174" title="All 2 branches missed.">		if (posTreeRoot == null) {</span>
<span class="nc" id="L2175">			return Collections.emptyList();</span>
		}

<span class="nc" id="L2178">		final List&lt;Exp&gt; memberList = new ArrayList&lt;Exp&gt;();</span>

<span class="nc" id="L2180">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback collect Funcalls of dimension workInt
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="nc" id="L2186">				int nodeIndex = node.getLevel() - 1;</span>
<span class="nc bnc" id="L2187" title="All 2 branches missed.">				if (nodeIndex &lt; dimIndex) {</span>
<span class="nc" id="L2188">					return TreeNodeCallback.CONTINUE;</span>
				}

				// iDimNode == workInt
<span class="nc" id="L2192">				Exp oExp = node.getReference();</span>
<span class="nc bnc" id="L2193" title="All 4 branches missed.">				if (QuaxUtil.isMember(oExp) &amp;&amp; !memberList.contains(oExp)) {</span>
<span class="nc" id="L2194">					memberList.add(oExp);</span>
				}

<span class="nc" id="L2197">				return TreeNodeCallback.CONTINUE_SIBLING;</span>
			}
		});

<span class="nc" id="L2201">		return memberList;</span>
	}

	/**
	 * Add a Funcall to Drillup list
	 */
	private void addFunCallToDrillup(List&lt;Exp&gt; list, Exp oFun, int[] maxLevel) {
<span class="nc bnc" id="L2208" title="All 2 branches missed.">		if (QuaxUtil.isFunCallTo(oFun, &quot;Union&quot;)) {</span>
<span class="nc bnc" id="L2209" title="All 2 branches missed.">			for (int i = 0; i &lt; 2; i++) {</span>
<span class="nc" id="L2210">				Exp fExp = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc" id="L2211">				addFunCallToDrillup(list, fExp, maxLevel);</span>
			}
<span class="nc bnc" id="L2213" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;{}&quot;)) {</span>
			// set of members
<span class="nc bnc" id="L2215" title="All 2 branches missed.">			for (int i = 0; i &lt; QuaxUtil.funCallArgCount(oFun); i++) {</span>
<span class="nc" id="L2216">				Exp oMember = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc" id="L2217">				Member m = QuaxUtil.memberForExp(oMember);</span>
<span class="nc" id="L2218">				QuaxUtil.addMemberUncles(list, m, maxLevel);</span>
			}
<span class="nc bnc" id="L2220" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Children&quot;)) {</span>
<span class="nc" id="L2221">			Exp oMember = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2222">			Member m = QuaxUtil.memberForExp(oMember);</span>
<span class="nc" id="L2223">			QuaxUtil.addMemberSiblings(list, m, maxLevel);</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Descendants&quot;)) {</span>
<span class="nc" id="L2225">			Exp oMember = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2226">			Member m = QuaxUtil.memberForExp(oMember);</span>
<span class="nc" id="L2227">			Exp oLevel = QuaxUtil.funCallArg(oFun, 1);</span>
<span class="nc" id="L2228">			Level lev = QuaxUtil.levelForExp(oLevel);</span>

<span class="nc" id="L2230">			int level = m.getLevel().getDepth();</span>
<span class="nc" id="L2231">			int levlev = lev.getDepth();</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">			if (levlev == level + 1) {</span>
<span class="nc" id="L2233">				QuaxUtil.addMemberSiblings(list, m, maxLevel); // same as</span>
																// children
<span class="nc bnc" id="L2235" title="All 2 branches missed.">			} else if (levlev == level + 2) {</span>
<span class="nc" id="L2236">				QuaxUtil.addMemberChildren(list, m, maxLevel); // m *is*</span>
																// grandfather
			} else {
				// add descendants of parent level
<span class="nc" id="L2240">				Level parentLevel = QuaxUtil.getParentLevel(lev);</span>
<span class="nc" id="L2241">				QuaxUtil.addMemberDescendants(list, m, parentLevel, maxLevel);</span>
			}
<span class="nc bnc" id="L2243" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Members&quot;)) {</span>
			// add parent level members
<span class="nc" id="L2245">			Exp oLevel = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2246">			Level lev = QuaxUtil.levelForExp(oLevel);</span>

<span class="nc" id="L2248">			int levlev = lev.getDepth();</span>
<span class="nc bnc" id="L2249" title="All 2 branches missed.">			if (levlev == 0) {</span>
<span class="nc" id="L2250">				return; // cannot drill up</span>
			}

<span class="nc" id="L2253">			Level parentLevel = QuaxUtil.getParentLevel(lev);</span>
<span class="nc" id="L2254">			QuaxUtil.addLevelMembers(list, parentLevel, maxLevel);</span>
		} else {
			// must be Top/Bottom Function with arg[0] being base set
<span class="nc" id="L2257">			Exp oFun2 = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2258">			addFunCallToDrillup(list, oFun2, maxLevel); // do not have a better</span>
														// solution
		}
<span class="nc" id="L2261">	}</span>

	/**
	 * Add FunCall to list
	 * 
	 * @param oFun
	 * @param list
	 */
	private void funToList(Exp oFun, List&lt;Exp&gt; list) {
<span class="nc bnc" id="L2270" title="All 2 branches missed.">		if (QuaxUtil.isFunCallTo(oFun, &quot;Union&quot;)) {</span>
<span class="nc" id="L2271">			Exp arg0 = QuaxUtil.funCallArg(oFun, 0);</span>
<span class="nc" id="L2272">			Exp arg1 = QuaxUtil.funCallArg(oFun, 1);</span>

<span class="nc" id="L2274">			funToList(arg0, list);</span>
<span class="nc" id="L2275">			funToList(arg1, list);</span>
<span class="nc bnc" id="L2276" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;{}&quot;)) {</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">			for (int i = 0; i &lt; QuaxUtil.funCallArgCount(oFun); i++) {</span>
				// member sets are resolved to single members
<span class="nc" id="L2279">				Exp oMember = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc" id="L2280">				list.add(oMember);</span>
			}
		} else {
<span class="nc" id="L2283">			list.add(oFun);</span>
		}
<span class="nc" id="L2285">	}</span>

	/**
	 * Check, whether member is in set defined by funcall
	 * 
	 * @param oExp
	 *            set funcall
	 * @param member
	 * @return
	 */
	private boolean isMemberInFunCall(Exp oExp, Member member, int hierIndex) {
<span class="fc" id="L2296">		boolean result = false;</span>

		try {
<span class="fc" id="L2299">			result = QuaxUtil.isMemberInFunCall(oExp, member);</span>
<span class="nc" id="L2300">		} catch (UnknownExpressionException e) {</span>
			// it is an Unkown FunCall
			// assume &quot;true&quot; if the member is in the List for this dimension
<span class="nc bnc" id="L2303" title="All 2 branches missed.">			if (ufMemberLists[hierIndex] == null)</span>
<span class="nc" id="L2304">				throw new PivotException(</span>
<span class="nc" id="L2305">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2306">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>

<span class="nc" id="L2308">			result = ufMemberLists[hierIndex].contains(member);</span>
		}

<span class="fc" id="L2311">		return result;</span>
	}

	/**
	 * Check whether a Funcall does NOT resolve to top level of hierarchy
	 */
	private boolean isFunCallNotTopLevel(Exp oExp, int hierIndex) {
<span class="nc" id="L2318">		boolean result = false;</span>

		try {
<span class="nc" id="L2321">			result = QuaxUtil.isFunCallNotTopLevel(oExp);</span>
<span class="nc" id="L2322">		} catch (UnknownExpressionException e) {</span>
			// it is an Unkown FunCall
			// assume &quot;true&quot; if the member is in the List for this dimension
<span class="nc bnc" id="L2325" title="All 2 branches missed.">			if (ufMemberLists[hierIndex] == null) {</span>
<span class="nc" id="L2326">				throw new PivotException(</span>
<span class="nc" id="L2327">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2328">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2331">			List&lt;Member&gt; members = ufMemberLists[hierIndex];</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">			for (Member member : members) {</span>
<span class="nc bnc" id="L2333" title="All 2 branches missed.">				if (member.getLevel().getDepth() &gt; 0) {</span>
<span class="nc" id="L2334">					result = true;</span>
<span class="nc" id="L2335">					break;</span>
				}
			}
		}

<span class="nc" id="L2340">		return result;</span>
	}

	/**
	 * Check whether a Funcall contains child of member
	 */
	private boolean isChildOfMemberInFunCall(Exp oExp, Member member,
			int hierIndex) {
<span class="fc" id="L2348">		boolean result = false;</span>

		try {
<span class="fc" id="L2351">			result = QuaxUtil.isChildOfMemberInFunCall(oExp, member);</span>
<span class="nc" id="L2352">		} catch (UnknownExpressionException e) {</span>
			// it is an Unkown FunCall
			// assume &quot;true&quot; if the member List for this dimension contains
			// child of member
<span class="nc bnc" id="L2356" title="All 2 branches missed.">			if (ufMemberLists[hierIndex] == null) {</span>
<span class="nc" id="L2357">				throw new PivotException(</span>
<span class="nc" id="L2358">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2359">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2362">			List&lt;Member&gt; members = ufMemberLists[hierIndex];</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2364" title="All 2 branches missed.">				if (QuaxUtil.checkParent(member, QuaxUtil.expForMember(m))) {</span>
<span class="nc" id="L2365">					result = true;</span>
<span class="nc" id="L2366">					break;</span>
				}
			}
		}

<span class="fc" id="L2371">		return result;</span>
	}

	/**
	 * Check whether a Funcall contains descendant of member
	 */
	private boolean isDescendantOfMemberInFunCall(Exp oExp, Member member,
			int hierIndex) {
<span class="fc" id="L2379">		boolean result = false;</span>

		try {
<span class="fc" id="L2382">			result = QuaxUtil.isDescendantOfMemberInFunCall(oExp, member);</span>
<span class="nc" id="L2383">		} catch (UnknownExpressionException e) {</span>
			// it is an Unkown FunCall
			// assume &quot;true&quot; if the member List for this dimension contains
			// descendant of member
<span class="nc bnc" id="L2387" title="All 2 branches missed.">			if (ufMemberLists[hierIndex] == null) {</span>
<span class="nc" id="L2388">				throw new PivotException(</span>
<span class="nc" id="L2389">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2390">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2393">			List&lt;Member&gt; members = ufMemberLists[hierIndex];</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">				if (QuaxUtil.checkDescendantM(member, m)) {</span>
<span class="nc" id="L2396">					result = true;</span>
<span class="nc" id="L2397">					break;</span>
				}
			}
		}

<span class="fc" id="L2402">		return result;</span>
	}

	/**
	 * Remove descendants of member from Funcall set
	 * 
	 * @return the remainder after descendants were removed
	 */
	private Exp removeDescendantsFromFunCall(Exp oFun, Member member,
			int hierIndex) {
		try {
<span class="fc" id="L2413">			return removeDescendantsFromFunCall(oFun, member);</span>
<span class="nc" id="L2414">		} catch (UnknownExpressionException e) {</span>
			// the FunCall was not handled,
			// assume that it is an &quot;Unkown FunCall&quot; which was resolved by the
			// latest result
			// the &quot;Unknown Functions&quot; are probably not properly resolved
<span class="nc bnc" id="L2419" title="All 2 branches missed.">			if (logger.isErrorEnabled()) {</span>
<span class="nc" id="L2420">				logger.error(&quot;Unkown FunCall &quot; + QuaxUtil.funCallName(oFun));</span>
			}

<span class="nc bnc" id="L2423" title="All 2 branches missed.">			if (ufMemberLists[hierIndex] == null) {</span>
<span class="nc" id="L2424">				throw new PivotException(</span>
<span class="nc" id="L2425">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2426">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2429">			List&lt;Exp&gt; newList = new ArrayList&lt;Exp&gt;();</span>

<span class="nc" id="L2431">			List&lt;Member&gt; members = ufMemberLists[hierIndex];</span>
<span class="nc bnc" id="L2432" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2433" title="All 2 branches missed.">				if (!QuaxUtil.checkDescendantM(member, m)) {</span>
<span class="nc" id="L2434">					newList.add(QuaxUtil.expForMember(m));</span>
				}
			}

<span class="nc" id="L2438">			return QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L2439">					newList.toArray(new Exp[newList.size()]), Syntax.Braces);</span>
		}
	}

	/**
	 * Remove descendants of member from Funcall set
	 * 
	 * @return the remainder after descendants were removed
	 */
	private Exp removeDescendantsFromFunCall(Exp oFun, Member member)
			throws UnknownExpressionException {
<span class="pc bpc" id="L2450" title="1 of 2 branches missed.">		if (QuaxUtil.isFunCallTo(oFun, &quot;Children&quot;)) {</span>
			// as we know, that there is a descendent of m in x.children,
			// we know that *all* x.children are descendants of m
<span class="fc" id="L2453">			return null;</span>
<span class="nc bnc" id="L2454" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Descendants&quot;)) {</span>
			// as we know, that there is a descendent of m in x.descendants
			// we know that *all* x.descendants are descendants of m
<span class="nc" id="L2457">			return null;</span>
<span class="nc bnc" id="L2458" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Members&quot;)) {</span>
<span class="nc" id="L2459">			Level level = member.getLevel();</span>

			List&lt;Member&gt; members;
			try {
<span class="nc" id="L2463">				members = level.getMembers();</span>
<span class="nc" id="L2464">			} catch (OlapException e) {</span>
<span class="nc" id="L2465">				throw new PivotException(e);</span>
			}

<span class="nc" id="L2468">			List&lt;Member&gt; remainder = new ArrayList&lt;Member&gt;(members.size());</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2470" title="All 2 branches missed.">				if (!QuaxUtil.isDescendant(member, m))</span>
<span class="nc" id="L2471">					remainder.add(m);</span>
			}

<span class="nc" id="L2474">			return QuaxUtil.createMemberSet(remainder);</span>
<span class="nc bnc" id="L2475" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;{}&quot;)) {</span>
<span class="nc" id="L2476">			List&lt;Member&gt; remainder = new ArrayList&lt;Member&gt;();</span>

<span class="nc bnc" id="L2478" title="All 2 branches missed.">			for (int i = 0; i &lt; QuaxUtil.funCallArgCount(oFun); i++) {</span>
<span class="nc" id="L2479">				Exp arg = QuaxUtil.funCallArg(oFun, i);</span>

<span class="nc bnc" id="L2481" title="All 2 branches missed.">				if (!QuaxUtil.isDescendant(member, arg)) {</span>
<span class="nc" id="L2482">					remainder.add(QuaxUtil.memberForExp(arg));</span>
				}
			}

<span class="nc" id="L2486">			return QuaxUtil.createMemberSet(remainder);</span>
<span class="nc bnc" id="L2487" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Union&quot;)) {</span>
<span class="nc" id="L2488">			Exp[] uargs = new Exp[2];</span>
<span class="nc" id="L2489">			uargs[0] = removeDescendantsFromFunCall(</span>
<span class="nc" id="L2490">					QuaxUtil.funCallArg(oFun, 0), member);</span>
<span class="nc" id="L2491">			uargs[1] = removeDescendantsFromFunCall(</span>
<span class="nc" id="L2492">					QuaxUtil.funCallArg(oFun, 0), member);</span>

<span class="nc bnc" id="L2494" title="All 4 branches missed.">			if (uargs[0] == null &amp;&amp; uargs[1] == null) {</span>
<span class="nc" id="L2495">				return null;</span>
			}

<span class="nc bnc" id="L2498" title="All 2 branches missed.">			if (uargs[1] == null) {</span>
<span class="nc" id="L2499">				return uargs[0];</span>
			}

<span class="nc bnc" id="L2502" title="All 2 branches missed.">			if (uargs[0] == null) {</span>
<span class="nc" id="L2503">				return uargs[1];</span>
			}

<span class="nc bnc" id="L2506" title="All 2 branches missed.">			if (QuaxUtil.isMember(uargs[0])) {</span>
<span class="nc" id="L2507">				uargs[0] = QuaxUtil.createFunCall(&quot;{}&quot;, new Exp[] { uargs[0] },</span>
<span class="nc" id="L2508">						Syntax.Braces);</span>
			}

<span class="nc bnc" id="L2511" title="All 2 branches missed.">			if (QuaxUtil.isMember(uargs[1])) {</span>
<span class="nc" id="L2512">				uargs[1] = QuaxUtil.createFunCall(&quot;{}&quot;, new Exp[] { uargs[1] },</span>
<span class="nc" id="L2513">						Syntax.Braces);</span>
			}

<span class="nc bnc" id="L2516" title="All 2 branches missed.">			if (QuaxUtil.isFunCallTo(uargs[0], &quot;{}&quot;)</span>
<span class="nc bnc" id="L2517" title="All 2 branches missed.">					&amp;&amp; QuaxUtil.isFunCallTo(uargs[1], &quot;{}&quot;)) {</span>
<span class="nc" id="L2518">				return unionOfSets(uargs[0], uargs[1]);</span>
			}

<span class="nc" id="L2521">			return QuaxUtil.createFunCall(&quot;Union&quot;, uargs, Syntax.Function);</span>
		}

<span class="nc" id="L2524">		throw new UnknownExpressionException(QuaxUtil.funCallName(oFun));</span>
	}

	/**
	 * Determine complement set (set minus member)
	 */
	private Exp createComplement(Exp oFun, Member member, int hierIndex) {
		try {
<span class="nc" id="L2532">			return createComplement(oFun, member);</span>
<span class="nc" id="L2533">		} catch (UnknownExpressionException e) {</span>
			// the FunCall was not handled,
			// assume that it is an &quot;Unkown FunCall&quot; which was resolved by the
			// latest result
			// the &quot;Unknown Functions&quot; are probably not properly resolved
<span class="nc bnc" id="L2538" title="All 2 branches missed.">			if (logger.isErrorEnabled()) {</span>
<span class="nc" id="L2539">				logger.error(&quot;Unkown FunCall &quot; + QuaxUtil.funCallName(oFun));</span>
			}

<span class="nc bnc" id="L2542" title="All 2 branches missed.">			if (ufMemberLists[hierIndex] == null) {</span>
<span class="nc" id="L2543">				throw new PivotException(</span>
<span class="nc" id="L2544">						&quot;Unknow Function - no member list, dimension=&quot;</span>
<span class="nc" id="L2545">								+ hierIndex + &quot; function=&quot; + e.getExpression());</span>
			}

<span class="nc" id="L2548">			List&lt;Exp&gt; newList = new ArrayList&lt;Exp&gt;();</span>

<span class="nc" id="L2550">			List&lt;Member&gt; members = ufMemberLists[hierIndex];</span>
<span class="nc bnc" id="L2551" title="All 2 branches missed.">			for (Member m : members) {</span>
<span class="nc bnc" id="L2552" title="All 2 branches missed.">				if (!member.equals(m)) {</span>
<span class="nc" id="L2553">					newList.add(QuaxUtil.expForMember(m));</span>
				}
			}

<span class="nc" id="L2557">			return QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L2558">					newList.toArray(new Exp[newList.size()]), Syntax.Braces);</span>
		}
	}

	/**
	 * Determine complement set (set minus member)
	 * 
	 * @throws UnknownExpressionException
	 */
	private Exp createComplement(Exp oFun, Member member)
			throws UnknownExpressionException {
<span class="nc bnc" id="L2569" title="All 2 branches missed.">		if (QuaxUtil.isFunCallTo(oFun, &quot;Children&quot;)) {</span>
<span class="nc" id="L2570">			Exp oParent = QuaxUtil.funCallArg(oFun, 0);</span>

			// if member is NOT a child of Funcall arg, then the complement is
			// the original set
<span class="nc" id="L2574">			Exp oMember = QuaxUtil.expForMember(member);</span>
<span class="nc bnc" id="L2575" title="All 2 branches missed.">			if (!QuaxUtil.checkChild(member, oParent)) {</span>
<span class="nc" id="L2576">				return oFun;</span>
			}

<span class="nc" id="L2579">			List&lt;Exp&gt; oChildren = QuaxUtil.getChildMembers(oParent);</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">			if (oChildren.size() &lt; 2) {</span>
<span class="nc" id="L2581">				return null;</span>
			}

<span class="nc" id="L2584">			Exp[] mComplement = new Exp[oChildren.size() - 1];</span>
<span class="nc" id="L2585">			int ii = 0;</span>
<span class="nc bnc" id="L2586" title="All 2 branches missed.">			for (Exp child : oChildren) {</span>
<span class="nc bnc" id="L2587" title="All 2 branches missed.">				if (!child.equals(oMember)) {</span>
<span class="nc" id="L2588">					mComplement[ii++] = child;</span>
				}
			}

<span class="nc bnc" id="L2592" title="All 2 branches missed.">			if (mComplement.length == 1) {</span>
<span class="nc" id="L2593">				return mComplement[0]; // single member</span>
			}

<span class="nc" id="L2596">			Exp oComplement = QuaxUtil.createFunCall(&quot;{}&quot;, mComplement,</span>
<span class="nc" id="L2597">					Syntax.Braces);</span>

<span class="nc" id="L2599">			return oComplement;</span>
<span class="nc bnc" id="L2600" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;{}&quot;)) {</span>
<span class="nc" id="L2601">			int nComp = 0;</span>
<span class="nc" id="L2602">			int nArg = QuaxUtil.funCallArgCount(oFun);</span>

<span class="nc" id="L2604">			Exp oMember = QuaxUtil.expForMember(member);</span>
<span class="nc bnc" id="L2605" title="All 2 branches missed.">			for (int i = 0; i &lt; nArg; i++) {</span>
<span class="nc" id="L2606">				Exp o = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">				if (!(o.equals(oMember))) {</span>
<span class="nc" id="L2608">					++nComp;</span>
				}
			}

<span class="nc bnc" id="L2612" title="All 2 branches missed.">			if (nComp == 0) {</span>
<span class="nc" id="L2613">				return null;</span>
			}

<span class="nc bnc" id="L2616" title="All 2 branches missed.">			if (nComp == nArg) {</span>
				// complement = same
<span class="nc" id="L2618">				return oFun;</span>
			}

<span class="nc" id="L2621">			Exp[] mComplement = new Exp[nComp];</span>
<span class="nc" id="L2622">			int ii = 0;</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">			for (int i = 0; i &lt; nArg; i++) {</span>
<span class="nc" id="L2624">				Exp o = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc bnc" id="L2625" title="All 2 branches missed.">				if (!(o.equals(oMember)))</span>
<span class="nc" id="L2626">					mComplement[ii++] = o;</span>
			}

<span class="nc bnc" id="L2629" title="All 2 branches missed.">			if (mComplement.length == 1) {</span>
<span class="nc" id="L2630">				return mComplement[0]; // single member</span>
			}

<span class="nc" id="L2633">			Exp oComplement = QuaxUtil.createFunCall(&quot;{}&quot;, mComplement,</span>
<span class="nc" id="L2634">					Syntax.Braces);</span>

<span class="nc" id="L2636">			return oComplement;</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">		} else if (QuaxUtil.isFunCallTo(oFun, &quot;Union&quot;)) {</span>
			// Union of FunCalls, recursive
			// Complement(Union(a,b)) = Union(Complement(a), Complement(b))
<span class="nc" id="L2640">			Exp[] complements = new Exp[2];</span>
<span class="nc bnc" id="L2641" title="All 2 branches missed.">			for (int i = 0; i &lt; 2; i++) {</span>
<span class="nc" id="L2642">				Exp o = QuaxUtil.funCallArg(oFun, i);</span>
<span class="nc" id="L2643">				complements[i] = createComplement(o, member);</span>
			}

<span class="nc bnc" id="L2646" title="All 4 branches missed.">			if (complements[0] == null &amp;&amp; complements[1] == null) {</span>
<span class="nc" id="L2647">				return null;</span>
<span class="nc bnc" id="L2648" title="All 4 branches missed.">			} else if (complements[0] != null &amp;&amp; complements[1] == null) {</span>
<span class="nc" id="L2649">				return complements[0]; // No Union needed</span>
<span class="nc bnc" id="L2650" title="All 4 branches missed.">			} else if (complements[0] == null &amp;&amp; complements[1] != null) {</span>
<span class="nc" id="L2651">				return complements[1]; // No Union needed</span>
			} else {
				// complement can be single member
<span class="nc bnc" id="L2654" title="All 2 branches missed.">				if (!QuaxUtil.isFunCall(complements[0])) {</span>
<span class="nc" id="L2655">					complements[0] = QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L2656">							new Exp[] { complements[0] }, Syntax.Braces);</span>
				}

<span class="nc bnc" id="L2659" title="All 2 branches missed.">				if (!QuaxUtil.isFunCall(complements[1])) {</span>
<span class="nc" id="L2660">					complements[1] = QuaxUtil.createFunCall(&quot;{}&quot;,</span>
<span class="nc" id="L2661">							new Exp[] { complements[1] }, Syntax.Braces);</span>
				}

<span class="nc bnc" id="L2664" title="All 2 branches missed.">				if (QuaxUtil.isFunCallTo(complements[0], &quot;{}&quot;)</span>
<span class="nc bnc" id="L2665" title="All 2 branches missed.">						&amp;&amp; QuaxUtil.isFunCallTo(complements[1], &quot;{}&quot;)) {</span>
					// create single set as union ow two sets
<span class="nc" id="L2667">					return unionOfSets(complements[0], complements[1]);</span>
				}

<span class="nc" id="L2670">				Exp newUnion = QuaxUtil.createFunCall(&quot;Union&quot;, complements,</span>
<span class="nc" id="L2671">						Syntax.Function);</span>

<span class="nc" id="L2673">				return newUnion;</span>
			}
		}

		// the fun call is not supported
<span class="nc" id="L2678">		throw new UnknownExpressionException(QuaxUtil.funCallName(oFun));</span>
	}

	/**
	 * Create new set as union of 2 sets
	 */
	private Exp unionOfSets(Exp set1, Exp set2) {
		// create single set as union ow two sets
<span class="nc" id="L2686">		int n1 = QuaxUtil.funCallArgCount(set1);</span>
<span class="nc" id="L2687">		int n2 = QuaxUtil.funCallArgCount(set2);</span>

<span class="nc" id="L2689">		Exp[] newSet = new Exp[n1 + n2];</span>
<span class="nc" id="L2690">		int i = 0;</span>
<span class="nc bnc" id="L2691" title="All 2 branches missed.">		for (int j = 0; j &lt; n1; j++) {</span>
<span class="nc" id="L2692">			newSet[i++] = QuaxUtil.funCallArg(set1, j);</span>
		}

<span class="nc bnc" id="L2695" title="All 2 branches missed.">		for (int j = 0; j &lt; n2; j++) {</span>
<span class="nc" id="L2696">			newSet[i++] = QuaxUtil.funCallArg(set2, j);</span>
		}
<span class="nc" id="L2698">		return QuaxUtil.createFunCall(&quot;{}&quot;, newSet, Syntax.Braces);</span>
	}

	/**
	 * @param iHier
	 *            index of Hierarchy
	 * @param list
	 *            Member List
	 */
	public void setHierMemberList(int iHier, List list) {
<span class="nc" id="L2708">		ufMemberLists[iHier] = list;</span>
<span class="nc" id="L2709">	}</span>

	/**
	 * 
	 * @param iHier
	 *            index of Hierarchy
	 * @return true, if the Hierarchy has an unknown function
	 */
	public boolean isUnknownFunction(int iHier) {
<span class="nc" id="L2718">		return containsUF[iHier];</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.eyeq.pivot4j.StateHolder#bookmarkState()
	 */
	public Serializable bookmarkState() {
		// TODO Auto-generated method stub
<span class="nc" id="L2728">		return null;</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.eyeq.pivot4j.StateHolder#restoreState(java.io.Serializable)
	 */
	public void restoreState(Serializable bookmark) {
		// TODO Auto-generated method stub

<span class="nc" id="L2739">	}</span>

	/**
	 * String representation (debugging)
	 * 
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
<span class="fc" id="L2748">		final StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L2749">		builder.append(&quot;Number of hierarchies excluded from HIEARARCHIZE=&quot;</span>
<span class="fc" id="L2750">				+ nHierExclude);</span>
<span class="fc" id="L2751">		builder.append('\n');</span>

<span class="pc bpc" id="L2753" title="1 of 2 branches missed.">		if (posTreeRoot == null) {</span>
<span class="nc" id="L2754">			builder.append(&quot;Root=null&quot;);</span>
<span class="nc" id="L2755">			return builder.toString();</span>
		}

<span class="fc" id="L2758">		posTreeRoot.walkChildren(new TreeNodeCallback&lt;Exp&gt;() {</span>

			/**
			 * callback quax to String
			 */
			public int handleTreeNode(TreeNode&lt;Exp&gt; node) {
<span class="fc" id="L2764">				int nodeIndex = node.getLevel() - 1;</span>
<span class="fc" id="L2765">				builder.append(&quot;\n&quot;);</span>

<span class="pc bpc" id="L2767" title="1 of 2 branches missed.">				for (int i = 0; i &lt; nodeIndex - 1; i++) {</span>
<span class="nc" id="L2768">					builder.append(&quot;   &quot;);</span>
				}

<span class="fc bfc" id="L2771" title="All 2 branches covered.">				if (nodeIndex &gt; 0) {</span>
<span class="fc" id="L2772">					builder.append(&quot;+--&quot;);</span>
				}

<span class="fc" id="L2775">				Exp oExp = node.getReference();</span>
<span class="fc bfc" id="L2776" title="All 2 branches covered.">				if (!QuaxUtil.isMember(oExp)) {</span>
					// FunCall
<span class="fc" id="L2778">					builder.append(QuaxUtil.funString(oExp));</span>
				} else {
					// member
<span class="fc" id="L2781">					builder.append(QuaxUtil.getMemberUniqueName(oExp));</span>
				}

<span class="fc" id="L2784">				return TreeNodeCallback.CONTINUE;</span>
			}
		});

<span class="fc" id="L2788">		return builder.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.5.10.201208310627</span></div></body></html>